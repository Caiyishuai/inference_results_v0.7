// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: object_detection/protos/preprocessor.proto

#ifndef PROTOBUF_object_5fdetection_2fprotos_2fpreprocessor_2eproto__INCLUDED
#define PROTOBUF_object_5fdetection_2fprotos_2fpreprocessor_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace object_detection {
namespace protos {
class AutoAugmentImage;
class AutoAugmentImageDefaultTypeInternal;
extern AutoAugmentImageDefaultTypeInternal _AutoAugmentImage_default_instance_;
class ConvertClassLogitsToSoftmax;
class ConvertClassLogitsToSoftmaxDefaultTypeInternal;
extern ConvertClassLogitsToSoftmaxDefaultTypeInternal _ConvertClassLogitsToSoftmax_default_instance_;
class DropLabelProbabilistically;
class DropLabelProbabilisticallyDefaultTypeInternal;
extern DropLabelProbabilisticallyDefaultTypeInternal _DropLabelProbabilistically_default_instance_;
class NormalizeImage;
class NormalizeImageDefaultTypeInternal;
extern NormalizeImageDefaultTypeInternal _NormalizeImage_default_instance_;
class PreprocessingStep;
class PreprocessingStepDefaultTypeInternal;
extern PreprocessingStepDefaultTypeInternal _PreprocessingStep_default_instance_;
class RGBtoGray;
class RGBtoGrayDefaultTypeInternal;
extern RGBtoGrayDefaultTypeInternal _RGBtoGray_default_instance_;
class RandomAbsolutePadImage;
class RandomAbsolutePadImageDefaultTypeInternal;
extern RandomAbsolutePadImageDefaultTypeInternal _RandomAbsolutePadImage_default_instance_;
class RandomAdjustBrightness;
class RandomAdjustBrightnessDefaultTypeInternal;
extern RandomAdjustBrightnessDefaultTypeInternal _RandomAdjustBrightness_default_instance_;
class RandomAdjustContrast;
class RandomAdjustContrastDefaultTypeInternal;
extern RandomAdjustContrastDefaultTypeInternal _RandomAdjustContrast_default_instance_;
class RandomAdjustHue;
class RandomAdjustHueDefaultTypeInternal;
extern RandomAdjustHueDefaultTypeInternal _RandomAdjustHue_default_instance_;
class RandomAdjustSaturation;
class RandomAdjustSaturationDefaultTypeInternal;
extern RandomAdjustSaturationDefaultTypeInternal _RandomAdjustSaturation_default_instance_;
class RandomBlackPatches;
class RandomBlackPatchesDefaultTypeInternal;
extern RandomBlackPatchesDefaultTypeInternal _RandomBlackPatches_default_instance_;
class RandomCropImage;
class RandomCropImageDefaultTypeInternal;
extern RandomCropImageDefaultTypeInternal _RandomCropImage_default_instance_;
class RandomCropPadImage;
class RandomCropPadImageDefaultTypeInternal;
extern RandomCropPadImageDefaultTypeInternal _RandomCropPadImage_default_instance_;
class RandomCropToAspectRatio;
class RandomCropToAspectRatioDefaultTypeInternal;
extern RandomCropToAspectRatioDefaultTypeInternal _RandomCropToAspectRatio_default_instance_;
class RandomDistortColor;
class RandomDistortColorDefaultTypeInternal;
extern RandomDistortColorDefaultTypeInternal _RandomDistortColor_default_instance_;
class RandomHorizontalFlip;
class RandomHorizontalFlipDefaultTypeInternal;
extern RandomHorizontalFlipDefaultTypeInternal _RandomHorizontalFlip_default_instance_;
class RandomImageScale;
class RandomImageScaleDefaultTypeInternal;
extern RandomImageScaleDefaultTypeInternal _RandomImageScale_default_instance_;
class RandomJitterBoxes;
class RandomJitterBoxesDefaultTypeInternal;
extern RandomJitterBoxesDefaultTypeInternal _RandomJitterBoxes_default_instance_;
class RandomPadImage;
class RandomPadImageDefaultTypeInternal;
extern RandomPadImageDefaultTypeInternal _RandomPadImage_default_instance_;
class RandomPixelValueScale;
class RandomPixelValueScaleDefaultTypeInternal;
extern RandomPixelValueScaleDefaultTypeInternal _RandomPixelValueScale_default_instance_;
class RandomRGBtoGray;
class RandomRGBtoGrayDefaultTypeInternal;
extern RandomRGBtoGrayDefaultTypeInternal _RandomRGBtoGray_default_instance_;
class RandomResizeMethod;
class RandomResizeMethodDefaultTypeInternal;
extern RandomResizeMethodDefaultTypeInternal _RandomResizeMethod_default_instance_;
class RandomRotation90;
class RandomRotation90DefaultTypeInternal;
extern RandomRotation90DefaultTypeInternal _RandomRotation90_default_instance_;
class RandomSelfConcatImage;
class RandomSelfConcatImageDefaultTypeInternal;
extern RandomSelfConcatImageDefaultTypeInternal _RandomSelfConcatImage_default_instance_;
class RandomVerticalFlip;
class RandomVerticalFlipDefaultTypeInternal;
extern RandomVerticalFlipDefaultTypeInternal _RandomVerticalFlip_default_instance_;
class RemapLabels;
class RemapLabelsDefaultTypeInternal;
extern RemapLabelsDefaultTypeInternal _RemapLabels_default_instance_;
class ResizeImage;
class ResizeImageDefaultTypeInternal;
extern ResizeImageDefaultTypeInternal _ResizeImage_default_instance_;
class SSDRandomCrop;
class SSDRandomCropDefaultTypeInternal;
extern SSDRandomCropDefaultTypeInternal _SSDRandomCrop_default_instance_;
class SSDRandomCropFixedAspectRatio;
class SSDRandomCropFixedAspectRatioDefaultTypeInternal;
extern SSDRandomCropFixedAspectRatioDefaultTypeInternal _SSDRandomCropFixedAspectRatio_default_instance_;
class SSDRandomCropFixedAspectRatioOperation;
class SSDRandomCropFixedAspectRatioOperationDefaultTypeInternal;
extern SSDRandomCropFixedAspectRatioOperationDefaultTypeInternal _SSDRandomCropFixedAspectRatioOperation_default_instance_;
class SSDRandomCropOperation;
class SSDRandomCropOperationDefaultTypeInternal;
extern SSDRandomCropOperationDefaultTypeInternal _SSDRandomCropOperation_default_instance_;
class SSDRandomCropPad;
class SSDRandomCropPadDefaultTypeInternal;
extern SSDRandomCropPadDefaultTypeInternal _SSDRandomCropPad_default_instance_;
class SSDRandomCropPadFixedAspectRatio;
class SSDRandomCropPadFixedAspectRatioDefaultTypeInternal;
extern SSDRandomCropPadFixedAspectRatioDefaultTypeInternal _SSDRandomCropPadFixedAspectRatio_default_instance_;
class SSDRandomCropPadFixedAspectRatioOperation;
class SSDRandomCropPadFixedAspectRatioOperationDefaultTypeInternal;
extern SSDRandomCropPadFixedAspectRatioOperationDefaultTypeInternal _SSDRandomCropPadFixedAspectRatioOperation_default_instance_;
class SSDRandomCropPadOperation;
class SSDRandomCropPadOperationDefaultTypeInternal;
extern SSDRandomCropPadOperationDefaultTypeInternal _SSDRandomCropPadOperation_default_instance_;
class ScaleBoxesToPixelCoordinates;
class ScaleBoxesToPixelCoordinatesDefaultTypeInternal;
extern ScaleBoxesToPixelCoordinatesDefaultTypeInternal _ScaleBoxesToPixelCoordinates_default_instance_;
class SubtractChannelMean;
class SubtractChannelMeanDefaultTypeInternal;
extern SubtractChannelMeanDefaultTypeInternal _SubtractChannelMean_default_instance_;
}  // namespace protos
}  // namespace object_detection

namespace object_detection {
namespace protos {

namespace protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto

enum ResizeImage_Method {
  ResizeImage_Method_AREA = 1,
  ResizeImage_Method_BICUBIC = 2,
  ResizeImage_Method_BILINEAR = 3,
  ResizeImage_Method_NEAREST_NEIGHBOR = 4
};
bool ResizeImage_Method_IsValid(int value);
const ResizeImage_Method ResizeImage_Method_Method_MIN = ResizeImage_Method_AREA;
const ResizeImage_Method ResizeImage_Method_Method_MAX = ResizeImage_Method_NEAREST_NEIGHBOR;
const int ResizeImage_Method_Method_ARRAYSIZE = ResizeImage_Method_Method_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResizeImage_Method_descriptor();
inline const ::std::string& ResizeImage_Method_Name(ResizeImage_Method value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResizeImage_Method_descriptor(), value);
}
inline bool ResizeImage_Method_Parse(
    const ::std::string& name, ResizeImage_Method* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResizeImage_Method>(
    ResizeImage_Method_descriptor(), name, value);
}
// ===================================================================

class PreprocessingStep : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.PreprocessingStep) */ {
 public:
  PreprocessingStep();
  virtual ~PreprocessingStep();

  PreprocessingStep(const PreprocessingStep& from);

  inline PreprocessingStep& operator=(const PreprocessingStep& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PreprocessingStep(PreprocessingStep&& from) noexcept
    : PreprocessingStep() {
    *this = ::std::move(from);
  }

  inline PreprocessingStep& operator=(PreprocessingStep&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PreprocessingStep& default_instance();

  enum PreprocessingStepCase {
    kNormalizeImage = 1,
    kRandomHorizontalFlip = 2,
    kRandomPixelValueScale = 3,
    kRandomImageScale = 4,
    kRandomRgbToGray = 5,
    kRandomAdjustBrightness = 6,
    kRandomAdjustContrast = 7,
    kRandomAdjustHue = 8,
    kRandomAdjustSaturation = 9,
    kRandomDistortColor = 10,
    kRandomJitterBoxes = 11,
    kRandomCropImage = 12,
    kRandomPadImage = 13,
    kRandomCropPadImage = 14,
    kRandomCropToAspectRatio = 15,
    kRandomBlackPatches = 16,
    kRandomResizeMethod = 17,
    kScaleBoxesToPixelCoordinates = 18,
    kResizeImage = 19,
    kSubtractChannelMean = 20,
    kSsdRandomCrop = 21,
    kSsdRandomCropPad = 22,
    kSsdRandomCropFixedAspectRatio = 23,
    kSsdRandomCropPadFixedAspectRatio = 24,
    kRandomVerticalFlip = 25,
    kRandomRotation90 = 26,
    kRgbToGray = 27,
    kConvertClassLogitsToSoftmax = 28,
    kRandomAbsolutePadImage = 29,
    kRandomSelfConcatImage = 30,
    kAutoaugmentImage = 31,
    kDropLabelProbabilistically = 32,
    kRemapLabels = 33,
    PREPROCESSING_STEP_NOT_SET = 0,
  };

  static inline const PreprocessingStep* internal_default_instance() {
    return reinterpret_cast<const PreprocessingStep*>(
               &_PreprocessingStep_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(PreprocessingStep* other);
  friend void swap(PreprocessingStep& a, PreprocessingStep& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PreprocessingStep* New() const PROTOBUF_FINAL { return New(NULL); }

  PreprocessingStep* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PreprocessingStep& from);
  void MergeFrom(const PreprocessingStep& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PreprocessingStep* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .object_detection.protos.NormalizeImage normalize_image = 1;
  bool has_normalize_image() const;
  void clear_normalize_image();
  static const int kNormalizeImageFieldNumber = 1;
  const ::object_detection::protos::NormalizeImage& normalize_image() const;
  ::object_detection::protos::NormalizeImage* mutable_normalize_image();
  ::object_detection::protos::NormalizeImage* release_normalize_image();
  void set_allocated_normalize_image(::object_detection::protos::NormalizeImage* normalize_image);

  // optional .object_detection.protos.RandomHorizontalFlip random_horizontal_flip = 2;
  bool has_random_horizontal_flip() const;
  void clear_random_horizontal_flip();
  static const int kRandomHorizontalFlipFieldNumber = 2;
  const ::object_detection::protos::RandomHorizontalFlip& random_horizontal_flip() const;
  ::object_detection::protos::RandomHorizontalFlip* mutable_random_horizontal_flip();
  ::object_detection::protos::RandomHorizontalFlip* release_random_horizontal_flip();
  void set_allocated_random_horizontal_flip(::object_detection::protos::RandomHorizontalFlip* random_horizontal_flip);

  // optional .object_detection.protos.RandomPixelValueScale random_pixel_value_scale = 3;
  bool has_random_pixel_value_scale() const;
  void clear_random_pixel_value_scale();
  static const int kRandomPixelValueScaleFieldNumber = 3;
  const ::object_detection::protos::RandomPixelValueScale& random_pixel_value_scale() const;
  ::object_detection::protos::RandomPixelValueScale* mutable_random_pixel_value_scale();
  ::object_detection::protos::RandomPixelValueScale* release_random_pixel_value_scale();
  void set_allocated_random_pixel_value_scale(::object_detection::protos::RandomPixelValueScale* random_pixel_value_scale);

  // optional .object_detection.protos.RandomImageScale random_image_scale = 4;
  bool has_random_image_scale() const;
  void clear_random_image_scale();
  static const int kRandomImageScaleFieldNumber = 4;
  const ::object_detection::protos::RandomImageScale& random_image_scale() const;
  ::object_detection::protos::RandomImageScale* mutable_random_image_scale();
  ::object_detection::protos::RandomImageScale* release_random_image_scale();
  void set_allocated_random_image_scale(::object_detection::protos::RandomImageScale* random_image_scale);

  // optional .object_detection.protos.RandomRGBtoGray random_rgb_to_gray = 5;
  bool has_random_rgb_to_gray() const;
  void clear_random_rgb_to_gray();
  static const int kRandomRgbToGrayFieldNumber = 5;
  const ::object_detection::protos::RandomRGBtoGray& random_rgb_to_gray() const;
  ::object_detection::protos::RandomRGBtoGray* mutable_random_rgb_to_gray();
  ::object_detection::protos::RandomRGBtoGray* release_random_rgb_to_gray();
  void set_allocated_random_rgb_to_gray(::object_detection::protos::RandomRGBtoGray* random_rgb_to_gray);

  // optional .object_detection.protos.RandomAdjustBrightness random_adjust_brightness = 6;
  bool has_random_adjust_brightness() const;
  void clear_random_adjust_brightness();
  static const int kRandomAdjustBrightnessFieldNumber = 6;
  const ::object_detection::protos::RandomAdjustBrightness& random_adjust_brightness() const;
  ::object_detection::protos::RandomAdjustBrightness* mutable_random_adjust_brightness();
  ::object_detection::protos::RandomAdjustBrightness* release_random_adjust_brightness();
  void set_allocated_random_adjust_brightness(::object_detection::protos::RandomAdjustBrightness* random_adjust_brightness);

  // optional .object_detection.protos.RandomAdjustContrast random_adjust_contrast = 7;
  bool has_random_adjust_contrast() const;
  void clear_random_adjust_contrast();
  static const int kRandomAdjustContrastFieldNumber = 7;
  const ::object_detection::protos::RandomAdjustContrast& random_adjust_contrast() const;
  ::object_detection::protos::RandomAdjustContrast* mutable_random_adjust_contrast();
  ::object_detection::protos::RandomAdjustContrast* release_random_adjust_contrast();
  void set_allocated_random_adjust_contrast(::object_detection::protos::RandomAdjustContrast* random_adjust_contrast);

  // optional .object_detection.protos.RandomAdjustHue random_adjust_hue = 8;
  bool has_random_adjust_hue() const;
  void clear_random_adjust_hue();
  static const int kRandomAdjustHueFieldNumber = 8;
  const ::object_detection::protos::RandomAdjustHue& random_adjust_hue() const;
  ::object_detection::protos::RandomAdjustHue* mutable_random_adjust_hue();
  ::object_detection::protos::RandomAdjustHue* release_random_adjust_hue();
  void set_allocated_random_adjust_hue(::object_detection::protos::RandomAdjustHue* random_adjust_hue);

  // optional .object_detection.protos.RandomAdjustSaturation random_adjust_saturation = 9;
  bool has_random_adjust_saturation() const;
  void clear_random_adjust_saturation();
  static const int kRandomAdjustSaturationFieldNumber = 9;
  const ::object_detection::protos::RandomAdjustSaturation& random_adjust_saturation() const;
  ::object_detection::protos::RandomAdjustSaturation* mutable_random_adjust_saturation();
  ::object_detection::protos::RandomAdjustSaturation* release_random_adjust_saturation();
  void set_allocated_random_adjust_saturation(::object_detection::protos::RandomAdjustSaturation* random_adjust_saturation);

  // optional .object_detection.protos.RandomDistortColor random_distort_color = 10;
  bool has_random_distort_color() const;
  void clear_random_distort_color();
  static const int kRandomDistortColorFieldNumber = 10;
  const ::object_detection::protos::RandomDistortColor& random_distort_color() const;
  ::object_detection::protos::RandomDistortColor* mutable_random_distort_color();
  ::object_detection::protos::RandomDistortColor* release_random_distort_color();
  void set_allocated_random_distort_color(::object_detection::protos::RandomDistortColor* random_distort_color);

  // optional .object_detection.protos.RandomJitterBoxes random_jitter_boxes = 11;
  bool has_random_jitter_boxes() const;
  void clear_random_jitter_boxes();
  static const int kRandomJitterBoxesFieldNumber = 11;
  const ::object_detection::protos::RandomJitterBoxes& random_jitter_boxes() const;
  ::object_detection::protos::RandomJitterBoxes* mutable_random_jitter_boxes();
  ::object_detection::protos::RandomJitterBoxes* release_random_jitter_boxes();
  void set_allocated_random_jitter_boxes(::object_detection::protos::RandomJitterBoxes* random_jitter_boxes);

  // optional .object_detection.protos.RandomCropImage random_crop_image = 12;
  bool has_random_crop_image() const;
  void clear_random_crop_image();
  static const int kRandomCropImageFieldNumber = 12;
  const ::object_detection::protos::RandomCropImage& random_crop_image() const;
  ::object_detection::protos::RandomCropImage* mutable_random_crop_image();
  ::object_detection::protos::RandomCropImage* release_random_crop_image();
  void set_allocated_random_crop_image(::object_detection::protos::RandomCropImage* random_crop_image);

  // optional .object_detection.protos.RandomPadImage random_pad_image = 13;
  bool has_random_pad_image() const;
  void clear_random_pad_image();
  static const int kRandomPadImageFieldNumber = 13;
  const ::object_detection::protos::RandomPadImage& random_pad_image() const;
  ::object_detection::protos::RandomPadImage* mutable_random_pad_image();
  ::object_detection::protos::RandomPadImage* release_random_pad_image();
  void set_allocated_random_pad_image(::object_detection::protos::RandomPadImage* random_pad_image);

  // optional .object_detection.protos.RandomCropPadImage random_crop_pad_image = 14;
  bool has_random_crop_pad_image() const;
  void clear_random_crop_pad_image();
  static const int kRandomCropPadImageFieldNumber = 14;
  const ::object_detection::protos::RandomCropPadImage& random_crop_pad_image() const;
  ::object_detection::protos::RandomCropPadImage* mutable_random_crop_pad_image();
  ::object_detection::protos::RandomCropPadImage* release_random_crop_pad_image();
  void set_allocated_random_crop_pad_image(::object_detection::protos::RandomCropPadImage* random_crop_pad_image);

  // optional .object_detection.protos.RandomCropToAspectRatio random_crop_to_aspect_ratio = 15;
  bool has_random_crop_to_aspect_ratio() const;
  void clear_random_crop_to_aspect_ratio();
  static const int kRandomCropToAspectRatioFieldNumber = 15;
  const ::object_detection::protos::RandomCropToAspectRatio& random_crop_to_aspect_ratio() const;
  ::object_detection::protos::RandomCropToAspectRatio* mutable_random_crop_to_aspect_ratio();
  ::object_detection::protos::RandomCropToAspectRatio* release_random_crop_to_aspect_ratio();
  void set_allocated_random_crop_to_aspect_ratio(::object_detection::protos::RandomCropToAspectRatio* random_crop_to_aspect_ratio);

  // optional .object_detection.protos.RandomBlackPatches random_black_patches = 16;
  bool has_random_black_patches() const;
  void clear_random_black_patches();
  static const int kRandomBlackPatchesFieldNumber = 16;
  const ::object_detection::protos::RandomBlackPatches& random_black_patches() const;
  ::object_detection::protos::RandomBlackPatches* mutable_random_black_patches();
  ::object_detection::protos::RandomBlackPatches* release_random_black_patches();
  void set_allocated_random_black_patches(::object_detection::protos::RandomBlackPatches* random_black_patches);

  // optional .object_detection.protos.RandomResizeMethod random_resize_method = 17;
  bool has_random_resize_method() const;
  void clear_random_resize_method();
  static const int kRandomResizeMethodFieldNumber = 17;
  const ::object_detection::protos::RandomResizeMethod& random_resize_method() const;
  ::object_detection::protos::RandomResizeMethod* mutable_random_resize_method();
  ::object_detection::protos::RandomResizeMethod* release_random_resize_method();
  void set_allocated_random_resize_method(::object_detection::protos::RandomResizeMethod* random_resize_method);

  // optional .object_detection.protos.ScaleBoxesToPixelCoordinates scale_boxes_to_pixel_coordinates = 18;
  bool has_scale_boxes_to_pixel_coordinates() const;
  void clear_scale_boxes_to_pixel_coordinates();
  static const int kScaleBoxesToPixelCoordinatesFieldNumber = 18;
  const ::object_detection::protos::ScaleBoxesToPixelCoordinates& scale_boxes_to_pixel_coordinates() const;
  ::object_detection::protos::ScaleBoxesToPixelCoordinates* mutable_scale_boxes_to_pixel_coordinates();
  ::object_detection::protos::ScaleBoxesToPixelCoordinates* release_scale_boxes_to_pixel_coordinates();
  void set_allocated_scale_boxes_to_pixel_coordinates(::object_detection::protos::ScaleBoxesToPixelCoordinates* scale_boxes_to_pixel_coordinates);

  // optional .object_detection.protos.ResizeImage resize_image = 19;
  bool has_resize_image() const;
  void clear_resize_image();
  static const int kResizeImageFieldNumber = 19;
  const ::object_detection::protos::ResizeImage& resize_image() const;
  ::object_detection::protos::ResizeImage* mutable_resize_image();
  ::object_detection::protos::ResizeImage* release_resize_image();
  void set_allocated_resize_image(::object_detection::protos::ResizeImage* resize_image);

  // optional .object_detection.protos.SubtractChannelMean subtract_channel_mean = 20;
  bool has_subtract_channel_mean() const;
  void clear_subtract_channel_mean();
  static const int kSubtractChannelMeanFieldNumber = 20;
  const ::object_detection::protos::SubtractChannelMean& subtract_channel_mean() const;
  ::object_detection::protos::SubtractChannelMean* mutable_subtract_channel_mean();
  ::object_detection::protos::SubtractChannelMean* release_subtract_channel_mean();
  void set_allocated_subtract_channel_mean(::object_detection::protos::SubtractChannelMean* subtract_channel_mean);

  // optional .object_detection.protos.SSDRandomCrop ssd_random_crop = 21;
  bool has_ssd_random_crop() const;
  void clear_ssd_random_crop();
  static const int kSsdRandomCropFieldNumber = 21;
  const ::object_detection::protos::SSDRandomCrop& ssd_random_crop() const;
  ::object_detection::protos::SSDRandomCrop* mutable_ssd_random_crop();
  ::object_detection::protos::SSDRandomCrop* release_ssd_random_crop();
  void set_allocated_ssd_random_crop(::object_detection::protos::SSDRandomCrop* ssd_random_crop);

  // optional .object_detection.protos.SSDRandomCropPad ssd_random_crop_pad = 22;
  bool has_ssd_random_crop_pad() const;
  void clear_ssd_random_crop_pad();
  static const int kSsdRandomCropPadFieldNumber = 22;
  const ::object_detection::protos::SSDRandomCropPad& ssd_random_crop_pad() const;
  ::object_detection::protos::SSDRandomCropPad* mutable_ssd_random_crop_pad();
  ::object_detection::protos::SSDRandomCropPad* release_ssd_random_crop_pad();
  void set_allocated_ssd_random_crop_pad(::object_detection::protos::SSDRandomCropPad* ssd_random_crop_pad);

  // optional .object_detection.protos.SSDRandomCropFixedAspectRatio ssd_random_crop_fixed_aspect_ratio = 23;
  bool has_ssd_random_crop_fixed_aspect_ratio() const;
  void clear_ssd_random_crop_fixed_aspect_ratio();
  static const int kSsdRandomCropFixedAspectRatioFieldNumber = 23;
  const ::object_detection::protos::SSDRandomCropFixedAspectRatio& ssd_random_crop_fixed_aspect_ratio() const;
  ::object_detection::protos::SSDRandomCropFixedAspectRatio* mutable_ssd_random_crop_fixed_aspect_ratio();
  ::object_detection::protos::SSDRandomCropFixedAspectRatio* release_ssd_random_crop_fixed_aspect_ratio();
  void set_allocated_ssd_random_crop_fixed_aspect_ratio(::object_detection::protos::SSDRandomCropFixedAspectRatio* ssd_random_crop_fixed_aspect_ratio);

  // optional .object_detection.protos.SSDRandomCropPadFixedAspectRatio ssd_random_crop_pad_fixed_aspect_ratio = 24;
  bool has_ssd_random_crop_pad_fixed_aspect_ratio() const;
  void clear_ssd_random_crop_pad_fixed_aspect_ratio();
  static const int kSsdRandomCropPadFixedAspectRatioFieldNumber = 24;
  const ::object_detection::protos::SSDRandomCropPadFixedAspectRatio& ssd_random_crop_pad_fixed_aspect_ratio() const;
  ::object_detection::protos::SSDRandomCropPadFixedAspectRatio* mutable_ssd_random_crop_pad_fixed_aspect_ratio();
  ::object_detection::protos::SSDRandomCropPadFixedAspectRatio* release_ssd_random_crop_pad_fixed_aspect_ratio();
  void set_allocated_ssd_random_crop_pad_fixed_aspect_ratio(::object_detection::protos::SSDRandomCropPadFixedAspectRatio* ssd_random_crop_pad_fixed_aspect_ratio);

  // optional .object_detection.protos.RandomVerticalFlip random_vertical_flip = 25;
  bool has_random_vertical_flip() const;
  void clear_random_vertical_flip();
  static const int kRandomVerticalFlipFieldNumber = 25;
  const ::object_detection::protos::RandomVerticalFlip& random_vertical_flip() const;
  ::object_detection::protos::RandomVerticalFlip* mutable_random_vertical_flip();
  ::object_detection::protos::RandomVerticalFlip* release_random_vertical_flip();
  void set_allocated_random_vertical_flip(::object_detection::protos::RandomVerticalFlip* random_vertical_flip);

  // optional .object_detection.protos.RandomRotation90 random_rotation90 = 26;
  bool has_random_rotation90() const;
  void clear_random_rotation90();
  static const int kRandomRotation90FieldNumber = 26;
  const ::object_detection::protos::RandomRotation90& random_rotation90() const;
  ::object_detection::protos::RandomRotation90* mutable_random_rotation90();
  ::object_detection::protos::RandomRotation90* release_random_rotation90();
  void set_allocated_random_rotation90(::object_detection::protos::RandomRotation90* random_rotation90);

  // optional .object_detection.protos.RGBtoGray rgb_to_gray = 27;
  bool has_rgb_to_gray() const;
  void clear_rgb_to_gray();
  static const int kRgbToGrayFieldNumber = 27;
  const ::object_detection::protos::RGBtoGray& rgb_to_gray() const;
  ::object_detection::protos::RGBtoGray* mutable_rgb_to_gray();
  ::object_detection::protos::RGBtoGray* release_rgb_to_gray();
  void set_allocated_rgb_to_gray(::object_detection::protos::RGBtoGray* rgb_to_gray);

  // optional .object_detection.protos.ConvertClassLogitsToSoftmax convert_class_logits_to_softmax = 28;
  bool has_convert_class_logits_to_softmax() const;
  void clear_convert_class_logits_to_softmax();
  static const int kConvertClassLogitsToSoftmaxFieldNumber = 28;
  const ::object_detection::protos::ConvertClassLogitsToSoftmax& convert_class_logits_to_softmax() const;
  ::object_detection::protos::ConvertClassLogitsToSoftmax* mutable_convert_class_logits_to_softmax();
  ::object_detection::protos::ConvertClassLogitsToSoftmax* release_convert_class_logits_to_softmax();
  void set_allocated_convert_class_logits_to_softmax(::object_detection::protos::ConvertClassLogitsToSoftmax* convert_class_logits_to_softmax);

  // optional .object_detection.protos.RandomAbsolutePadImage random_absolute_pad_image = 29;
  bool has_random_absolute_pad_image() const;
  void clear_random_absolute_pad_image();
  static const int kRandomAbsolutePadImageFieldNumber = 29;
  const ::object_detection::protos::RandomAbsolutePadImage& random_absolute_pad_image() const;
  ::object_detection::protos::RandomAbsolutePadImage* mutable_random_absolute_pad_image();
  ::object_detection::protos::RandomAbsolutePadImage* release_random_absolute_pad_image();
  void set_allocated_random_absolute_pad_image(::object_detection::protos::RandomAbsolutePadImage* random_absolute_pad_image);

  // optional .object_detection.protos.RandomSelfConcatImage random_self_concat_image = 30;
  bool has_random_self_concat_image() const;
  void clear_random_self_concat_image();
  static const int kRandomSelfConcatImageFieldNumber = 30;
  const ::object_detection::protos::RandomSelfConcatImage& random_self_concat_image() const;
  ::object_detection::protos::RandomSelfConcatImage* mutable_random_self_concat_image();
  ::object_detection::protos::RandomSelfConcatImage* release_random_self_concat_image();
  void set_allocated_random_self_concat_image(::object_detection::protos::RandomSelfConcatImage* random_self_concat_image);

  // optional .object_detection.protos.AutoAugmentImage autoaugment_image = 31;
  bool has_autoaugment_image() const;
  void clear_autoaugment_image();
  static const int kAutoaugmentImageFieldNumber = 31;
  const ::object_detection::protos::AutoAugmentImage& autoaugment_image() const;
  ::object_detection::protos::AutoAugmentImage* mutable_autoaugment_image();
  ::object_detection::protos::AutoAugmentImage* release_autoaugment_image();
  void set_allocated_autoaugment_image(::object_detection::protos::AutoAugmentImage* autoaugment_image);

  // optional .object_detection.protos.DropLabelProbabilistically drop_label_probabilistically = 32;
  bool has_drop_label_probabilistically() const;
  void clear_drop_label_probabilistically();
  static const int kDropLabelProbabilisticallyFieldNumber = 32;
  const ::object_detection::protos::DropLabelProbabilistically& drop_label_probabilistically() const;
  ::object_detection::protos::DropLabelProbabilistically* mutable_drop_label_probabilistically();
  ::object_detection::protos::DropLabelProbabilistically* release_drop_label_probabilistically();
  void set_allocated_drop_label_probabilistically(::object_detection::protos::DropLabelProbabilistically* drop_label_probabilistically);

  // optional .object_detection.protos.RemapLabels remap_labels = 33;
  bool has_remap_labels() const;
  void clear_remap_labels();
  static const int kRemapLabelsFieldNumber = 33;
  const ::object_detection::protos::RemapLabels& remap_labels() const;
  ::object_detection::protos::RemapLabels* mutable_remap_labels();
  ::object_detection::protos::RemapLabels* release_remap_labels();
  void set_allocated_remap_labels(::object_detection::protos::RemapLabels* remap_labels);

  PreprocessingStepCase preprocessing_step_case() const;
  // @@protoc_insertion_point(class_scope:object_detection.protos.PreprocessingStep)
 private:
  void set_has_normalize_image();
  void set_has_random_horizontal_flip();
  void set_has_random_pixel_value_scale();
  void set_has_random_image_scale();
  void set_has_random_rgb_to_gray();
  void set_has_random_adjust_brightness();
  void set_has_random_adjust_contrast();
  void set_has_random_adjust_hue();
  void set_has_random_adjust_saturation();
  void set_has_random_distort_color();
  void set_has_random_jitter_boxes();
  void set_has_random_crop_image();
  void set_has_random_pad_image();
  void set_has_random_crop_pad_image();
  void set_has_random_crop_to_aspect_ratio();
  void set_has_random_black_patches();
  void set_has_random_resize_method();
  void set_has_scale_boxes_to_pixel_coordinates();
  void set_has_resize_image();
  void set_has_subtract_channel_mean();
  void set_has_ssd_random_crop();
  void set_has_ssd_random_crop_pad();
  void set_has_ssd_random_crop_fixed_aspect_ratio();
  void set_has_ssd_random_crop_pad_fixed_aspect_ratio();
  void set_has_random_vertical_flip();
  void set_has_random_rotation90();
  void set_has_rgb_to_gray();
  void set_has_convert_class_logits_to_softmax();
  void set_has_random_absolute_pad_image();
  void set_has_random_self_concat_image();
  void set_has_autoaugment_image();
  void set_has_drop_label_probabilistically();
  void set_has_remap_labels();

  inline bool has_preprocessing_step() const;
  void clear_preprocessing_step();
  inline void clear_has_preprocessing_step();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  union PreprocessingStepUnion {
    PreprocessingStepUnion() {}
    ::object_detection::protos::NormalizeImage* normalize_image_;
    ::object_detection::protos::RandomHorizontalFlip* random_horizontal_flip_;
    ::object_detection::protos::RandomPixelValueScale* random_pixel_value_scale_;
    ::object_detection::protos::RandomImageScale* random_image_scale_;
    ::object_detection::protos::RandomRGBtoGray* random_rgb_to_gray_;
    ::object_detection::protos::RandomAdjustBrightness* random_adjust_brightness_;
    ::object_detection::protos::RandomAdjustContrast* random_adjust_contrast_;
    ::object_detection::protos::RandomAdjustHue* random_adjust_hue_;
    ::object_detection::protos::RandomAdjustSaturation* random_adjust_saturation_;
    ::object_detection::protos::RandomDistortColor* random_distort_color_;
    ::object_detection::protos::RandomJitterBoxes* random_jitter_boxes_;
    ::object_detection::protos::RandomCropImage* random_crop_image_;
    ::object_detection::protos::RandomPadImage* random_pad_image_;
    ::object_detection::protos::RandomCropPadImage* random_crop_pad_image_;
    ::object_detection::protos::RandomCropToAspectRatio* random_crop_to_aspect_ratio_;
    ::object_detection::protos::RandomBlackPatches* random_black_patches_;
    ::object_detection::protos::RandomResizeMethod* random_resize_method_;
    ::object_detection::protos::ScaleBoxesToPixelCoordinates* scale_boxes_to_pixel_coordinates_;
    ::object_detection::protos::ResizeImage* resize_image_;
    ::object_detection::protos::SubtractChannelMean* subtract_channel_mean_;
    ::object_detection::protos::SSDRandomCrop* ssd_random_crop_;
    ::object_detection::protos::SSDRandomCropPad* ssd_random_crop_pad_;
    ::object_detection::protos::SSDRandomCropFixedAspectRatio* ssd_random_crop_fixed_aspect_ratio_;
    ::object_detection::protos::SSDRandomCropPadFixedAspectRatio* ssd_random_crop_pad_fixed_aspect_ratio_;
    ::object_detection::protos::RandomVerticalFlip* random_vertical_flip_;
    ::object_detection::protos::RandomRotation90* random_rotation90_;
    ::object_detection::protos::RGBtoGray* rgb_to_gray_;
    ::object_detection::protos::ConvertClassLogitsToSoftmax* convert_class_logits_to_softmax_;
    ::object_detection::protos::RandomAbsolutePadImage* random_absolute_pad_image_;
    ::object_detection::protos::RandomSelfConcatImage* random_self_concat_image_;
    ::object_detection::protos::AutoAugmentImage* autoaugment_image_;
    ::object_detection::protos::DropLabelProbabilistically* drop_label_probabilistically_;
    ::object_detection::protos::RemapLabels* remap_labels_;
  } preprocessing_step_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NormalizeImage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.NormalizeImage) */ {
 public:
  NormalizeImage();
  virtual ~NormalizeImage();

  NormalizeImage(const NormalizeImage& from);

  inline NormalizeImage& operator=(const NormalizeImage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NormalizeImage(NormalizeImage&& from) noexcept
    : NormalizeImage() {
    *this = ::std::move(from);
  }

  inline NormalizeImage& operator=(NormalizeImage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NormalizeImage& default_instance();

  static inline const NormalizeImage* internal_default_instance() {
    return reinterpret_cast<const NormalizeImage*>(
               &_NormalizeImage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(NormalizeImage* other);
  friend void swap(NormalizeImage& a, NormalizeImage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NormalizeImage* New() const PROTOBUF_FINAL { return New(NULL); }

  NormalizeImage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NormalizeImage& from);
  void MergeFrom(const NormalizeImage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NormalizeImage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float original_minval = 1;
  bool has_original_minval() const;
  void clear_original_minval();
  static const int kOriginalMinvalFieldNumber = 1;
  float original_minval() const;
  void set_original_minval(float value);

  // optional float original_maxval = 2;
  bool has_original_maxval() const;
  void clear_original_maxval();
  static const int kOriginalMaxvalFieldNumber = 2;
  float original_maxval() const;
  void set_original_maxval(float value);

  // optional float target_minval = 3 [default = 0];
  bool has_target_minval() const;
  void clear_target_minval();
  static const int kTargetMinvalFieldNumber = 3;
  float target_minval() const;
  void set_target_minval(float value);

  // optional float target_maxval = 4 [default = 1];
  bool has_target_maxval() const;
  void clear_target_maxval();
  static const int kTargetMaxvalFieldNumber = 4;
  float target_maxval() const;
  void set_target_maxval(float value);

  // @@protoc_insertion_point(class_scope:object_detection.protos.NormalizeImage)
 private:
  void set_has_original_minval();
  void clear_has_original_minval();
  void set_has_original_maxval();
  void clear_has_original_maxval();
  void set_has_target_minval();
  void clear_has_target_minval();
  void set_has_target_maxval();
  void clear_has_target_maxval();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float original_minval_;
  float original_maxval_;
  float target_minval_;
  float target_maxval_;
  friend struct protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RandomHorizontalFlip : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.RandomHorizontalFlip) */ {
 public:
  RandomHorizontalFlip();
  virtual ~RandomHorizontalFlip();

  RandomHorizontalFlip(const RandomHorizontalFlip& from);

  inline RandomHorizontalFlip& operator=(const RandomHorizontalFlip& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RandomHorizontalFlip(RandomHorizontalFlip&& from) noexcept
    : RandomHorizontalFlip() {
    *this = ::std::move(from);
  }

  inline RandomHorizontalFlip& operator=(RandomHorizontalFlip&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RandomHorizontalFlip& default_instance();

  static inline const RandomHorizontalFlip* internal_default_instance() {
    return reinterpret_cast<const RandomHorizontalFlip*>(
               &_RandomHorizontalFlip_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(RandomHorizontalFlip* other);
  friend void swap(RandomHorizontalFlip& a, RandomHorizontalFlip& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RandomHorizontalFlip* New() const PROTOBUF_FINAL { return New(NULL); }

  RandomHorizontalFlip* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RandomHorizontalFlip& from);
  void MergeFrom(const RandomHorizontalFlip& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RandomHorizontalFlip* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 keypoint_flip_permutation = 1;
  int keypoint_flip_permutation_size() const;
  void clear_keypoint_flip_permutation();
  static const int kKeypointFlipPermutationFieldNumber = 1;
  ::google::protobuf::int32 keypoint_flip_permutation(int index) const;
  void set_keypoint_flip_permutation(int index, ::google::protobuf::int32 value);
  void add_keypoint_flip_permutation(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      keypoint_flip_permutation() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_keypoint_flip_permutation();

  // @@protoc_insertion_point(class_scope:object_detection.protos.RandomHorizontalFlip)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > keypoint_flip_permutation_;
  friend struct protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RandomVerticalFlip : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.RandomVerticalFlip) */ {
 public:
  RandomVerticalFlip();
  virtual ~RandomVerticalFlip();

  RandomVerticalFlip(const RandomVerticalFlip& from);

  inline RandomVerticalFlip& operator=(const RandomVerticalFlip& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RandomVerticalFlip(RandomVerticalFlip&& from) noexcept
    : RandomVerticalFlip() {
    *this = ::std::move(from);
  }

  inline RandomVerticalFlip& operator=(RandomVerticalFlip&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RandomVerticalFlip& default_instance();

  static inline const RandomVerticalFlip* internal_default_instance() {
    return reinterpret_cast<const RandomVerticalFlip*>(
               &_RandomVerticalFlip_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(RandomVerticalFlip* other);
  friend void swap(RandomVerticalFlip& a, RandomVerticalFlip& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RandomVerticalFlip* New() const PROTOBUF_FINAL { return New(NULL); }

  RandomVerticalFlip* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RandomVerticalFlip& from);
  void MergeFrom(const RandomVerticalFlip& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RandomVerticalFlip* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 keypoint_flip_permutation = 1;
  int keypoint_flip_permutation_size() const;
  void clear_keypoint_flip_permutation();
  static const int kKeypointFlipPermutationFieldNumber = 1;
  ::google::protobuf::int32 keypoint_flip_permutation(int index) const;
  void set_keypoint_flip_permutation(int index, ::google::protobuf::int32 value);
  void add_keypoint_flip_permutation(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      keypoint_flip_permutation() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_keypoint_flip_permutation();

  // @@protoc_insertion_point(class_scope:object_detection.protos.RandomVerticalFlip)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > keypoint_flip_permutation_;
  friend struct protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RandomRotation90 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.RandomRotation90) */ {
 public:
  RandomRotation90();
  virtual ~RandomRotation90();

  RandomRotation90(const RandomRotation90& from);

  inline RandomRotation90& operator=(const RandomRotation90& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RandomRotation90(RandomRotation90&& from) noexcept
    : RandomRotation90() {
    *this = ::std::move(from);
  }

  inline RandomRotation90& operator=(RandomRotation90&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RandomRotation90& default_instance();

  static inline const RandomRotation90* internal_default_instance() {
    return reinterpret_cast<const RandomRotation90*>(
               &_RandomRotation90_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(RandomRotation90* other);
  friend void swap(RandomRotation90& a, RandomRotation90& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RandomRotation90* New() const PROTOBUF_FINAL { return New(NULL); }

  RandomRotation90* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RandomRotation90& from);
  void MergeFrom(const RandomRotation90& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RandomRotation90* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:object_detection.protos.RandomRotation90)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RandomPixelValueScale : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.RandomPixelValueScale) */ {
 public:
  RandomPixelValueScale();
  virtual ~RandomPixelValueScale();

  RandomPixelValueScale(const RandomPixelValueScale& from);

  inline RandomPixelValueScale& operator=(const RandomPixelValueScale& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RandomPixelValueScale(RandomPixelValueScale&& from) noexcept
    : RandomPixelValueScale() {
    *this = ::std::move(from);
  }

  inline RandomPixelValueScale& operator=(RandomPixelValueScale&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RandomPixelValueScale& default_instance();

  static inline const RandomPixelValueScale* internal_default_instance() {
    return reinterpret_cast<const RandomPixelValueScale*>(
               &_RandomPixelValueScale_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(RandomPixelValueScale* other);
  friend void swap(RandomPixelValueScale& a, RandomPixelValueScale& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RandomPixelValueScale* New() const PROTOBUF_FINAL { return New(NULL); }

  RandomPixelValueScale* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RandomPixelValueScale& from);
  void MergeFrom(const RandomPixelValueScale& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RandomPixelValueScale* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float minval = 1 [default = 0.9];
  bool has_minval() const;
  void clear_minval();
  static const int kMinvalFieldNumber = 1;
  float minval() const;
  void set_minval(float value);

  // optional float maxval = 2 [default = 1.1];
  bool has_maxval() const;
  void clear_maxval();
  static const int kMaxvalFieldNumber = 2;
  float maxval() const;
  void set_maxval(float value);

  // @@protoc_insertion_point(class_scope:object_detection.protos.RandomPixelValueScale)
 private:
  void set_has_minval();
  void clear_has_minval();
  void set_has_maxval();
  void clear_has_maxval();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float minval_;
  float maxval_;
  friend struct protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RandomImageScale : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.RandomImageScale) */ {
 public:
  RandomImageScale();
  virtual ~RandomImageScale();

  RandomImageScale(const RandomImageScale& from);

  inline RandomImageScale& operator=(const RandomImageScale& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RandomImageScale(RandomImageScale&& from) noexcept
    : RandomImageScale() {
    *this = ::std::move(from);
  }

  inline RandomImageScale& operator=(RandomImageScale&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RandomImageScale& default_instance();

  static inline const RandomImageScale* internal_default_instance() {
    return reinterpret_cast<const RandomImageScale*>(
               &_RandomImageScale_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(RandomImageScale* other);
  friend void swap(RandomImageScale& a, RandomImageScale& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RandomImageScale* New() const PROTOBUF_FINAL { return New(NULL); }

  RandomImageScale* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RandomImageScale& from);
  void MergeFrom(const RandomImageScale& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RandomImageScale* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float min_scale_ratio = 1 [default = 0.5];
  bool has_min_scale_ratio() const;
  void clear_min_scale_ratio();
  static const int kMinScaleRatioFieldNumber = 1;
  float min_scale_ratio() const;
  void set_min_scale_ratio(float value);

  // optional float max_scale_ratio = 2 [default = 2];
  bool has_max_scale_ratio() const;
  void clear_max_scale_ratio();
  static const int kMaxScaleRatioFieldNumber = 2;
  float max_scale_ratio() const;
  void set_max_scale_ratio(float value);

  // @@protoc_insertion_point(class_scope:object_detection.protos.RandomImageScale)
 private:
  void set_has_min_scale_ratio();
  void clear_has_min_scale_ratio();
  void set_has_max_scale_ratio();
  void clear_has_max_scale_ratio();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float min_scale_ratio_;
  float max_scale_ratio_;
  friend struct protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RandomRGBtoGray : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.RandomRGBtoGray) */ {
 public:
  RandomRGBtoGray();
  virtual ~RandomRGBtoGray();

  RandomRGBtoGray(const RandomRGBtoGray& from);

  inline RandomRGBtoGray& operator=(const RandomRGBtoGray& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RandomRGBtoGray(RandomRGBtoGray&& from) noexcept
    : RandomRGBtoGray() {
    *this = ::std::move(from);
  }

  inline RandomRGBtoGray& operator=(RandomRGBtoGray&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RandomRGBtoGray& default_instance();

  static inline const RandomRGBtoGray* internal_default_instance() {
    return reinterpret_cast<const RandomRGBtoGray*>(
               &_RandomRGBtoGray_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(RandomRGBtoGray* other);
  friend void swap(RandomRGBtoGray& a, RandomRGBtoGray& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RandomRGBtoGray* New() const PROTOBUF_FINAL { return New(NULL); }

  RandomRGBtoGray* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RandomRGBtoGray& from);
  void MergeFrom(const RandomRGBtoGray& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RandomRGBtoGray* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float probability = 1 [default = 0.1];
  bool has_probability() const;
  void clear_probability();
  static const int kProbabilityFieldNumber = 1;
  float probability() const;
  void set_probability(float value);

  // @@protoc_insertion_point(class_scope:object_detection.protos.RandomRGBtoGray)
 private:
  void set_has_probability();
  void clear_has_probability();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float probability_;
  friend struct protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RandomAdjustBrightness : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.RandomAdjustBrightness) */ {
 public:
  RandomAdjustBrightness();
  virtual ~RandomAdjustBrightness();

  RandomAdjustBrightness(const RandomAdjustBrightness& from);

  inline RandomAdjustBrightness& operator=(const RandomAdjustBrightness& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RandomAdjustBrightness(RandomAdjustBrightness&& from) noexcept
    : RandomAdjustBrightness() {
    *this = ::std::move(from);
  }

  inline RandomAdjustBrightness& operator=(RandomAdjustBrightness&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RandomAdjustBrightness& default_instance();

  static inline const RandomAdjustBrightness* internal_default_instance() {
    return reinterpret_cast<const RandomAdjustBrightness*>(
               &_RandomAdjustBrightness_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(RandomAdjustBrightness* other);
  friend void swap(RandomAdjustBrightness& a, RandomAdjustBrightness& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RandomAdjustBrightness* New() const PROTOBUF_FINAL { return New(NULL); }

  RandomAdjustBrightness* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RandomAdjustBrightness& from);
  void MergeFrom(const RandomAdjustBrightness& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RandomAdjustBrightness* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float max_delta = 1 [default = 0.2];
  bool has_max_delta() const;
  void clear_max_delta();
  static const int kMaxDeltaFieldNumber = 1;
  float max_delta() const;
  void set_max_delta(float value);

  // @@protoc_insertion_point(class_scope:object_detection.protos.RandomAdjustBrightness)
 private:
  void set_has_max_delta();
  void clear_has_max_delta();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float max_delta_;
  friend struct protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RandomAdjustContrast : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.RandomAdjustContrast) */ {
 public:
  RandomAdjustContrast();
  virtual ~RandomAdjustContrast();

  RandomAdjustContrast(const RandomAdjustContrast& from);

  inline RandomAdjustContrast& operator=(const RandomAdjustContrast& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RandomAdjustContrast(RandomAdjustContrast&& from) noexcept
    : RandomAdjustContrast() {
    *this = ::std::move(from);
  }

  inline RandomAdjustContrast& operator=(RandomAdjustContrast&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RandomAdjustContrast& default_instance();

  static inline const RandomAdjustContrast* internal_default_instance() {
    return reinterpret_cast<const RandomAdjustContrast*>(
               &_RandomAdjustContrast_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(RandomAdjustContrast* other);
  friend void swap(RandomAdjustContrast& a, RandomAdjustContrast& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RandomAdjustContrast* New() const PROTOBUF_FINAL { return New(NULL); }

  RandomAdjustContrast* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RandomAdjustContrast& from);
  void MergeFrom(const RandomAdjustContrast& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RandomAdjustContrast* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float min_delta = 1 [default = 0.8];
  bool has_min_delta() const;
  void clear_min_delta();
  static const int kMinDeltaFieldNumber = 1;
  float min_delta() const;
  void set_min_delta(float value);

  // optional float max_delta = 2 [default = 1.25];
  bool has_max_delta() const;
  void clear_max_delta();
  static const int kMaxDeltaFieldNumber = 2;
  float max_delta() const;
  void set_max_delta(float value);

  // @@protoc_insertion_point(class_scope:object_detection.protos.RandomAdjustContrast)
 private:
  void set_has_min_delta();
  void clear_has_min_delta();
  void set_has_max_delta();
  void clear_has_max_delta();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float min_delta_;
  float max_delta_;
  friend struct protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RandomAdjustHue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.RandomAdjustHue) */ {
 public:
  RandomAdjustHue();
  virtual ~RandomAdjustHue();

  RandomAdjustHue(const RandomAdjustHue& from);

  inline RandomAdjustHue& operator=(const RandomAdjustHue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RandomAdjustHue(RandomAdjustHue&& from) noexcept
    : RandomAdjustHue() {
    *this = ::std::move(from);
  }

  inline RandomAdjustHue& operator=(RandomAdjustHue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RandomAdjustHue& default_instance();

  static inline const RandomAdjustHue* internal_default_instance() {
    return reinterpret_cast<const RandomAdjustHue*>(
               &_RandomAdjustHue_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(RandomAdjustHue* other);
  friend void swap(RandomAdjustHue& a, RandomAdjustHue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RandomAdjustHue* New() const PROTOBUF_FINAL { return New(NULL); }

  RandomAdjustHue* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RandomAdjustHue& from);
  void MergeFrom(const RandomAdjustHue& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RandomAdjustHue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float max_delta = 1 [default = 0.02];
  bool has_max_delta() const;
  void clear_max_delta();
  static const int kMaxDeltaFieldNumber = 1;
  float max_delta() const;
  void set_max_delta(float value);

  // @@protoc_insertion_point(class_scope:object_detection.protos.RandomAdjustHue)
 private:
  void set_has_max_delta();
  void clear_has_max_delta();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float max_delta_;
  friend struct protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RandomAdjustSaturation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.RandomAdjustSaturation) */ {
 public:
  RandomAdjustSaturation();
  virtual ~RandomAdjustSaturation();

  RandomAdjustSaturation(const RandomAdjustSaturation& from);

  inline RandomAdjustSaturation& operator=(const RandomAdjustSaturation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RandomAdjustSaturation(RandomAdjustSaturation&& from) noexcept
    : RandomAdjustSaturation() {
    *this = ::std::move(from);
  }

  inline RandomAdjustSaturation& operator=(RandomAdjustSaturation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RandomAdjustSaturation& default_instance();

  static inline const RandomAdjustSaturation* internal_default_instance() {
    return reinterpret_cast<const RandomAdjustSaturation*>(
               &_RandomAdjustSaturation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(RandomAdjustSaturation* other);
  friend void swap(RandomAdjustSaturation& a, RandomAdjustSaturation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RandomAdjustSaturation* New() const PROTOBUF_FINAL { return New(NULL); }

  RandomAdjustSaturation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RandomAdjustSaturation& from);
  void MergeFrom(const RandomAdjustSaturation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RandomAdjustSaturation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float min_delta = 1 [default = 0.8];
  bool has_min_delta() const;
  void clear_min_delta();
  static const int kMinDeltaFieldNumber = 1;
  float min_delta() const;
  void set_min_delta(float value);

  // optional float max_delta = 2 [default = 1.25];
  bool has_max_delta() const;
  void clear_max_delta();
  static const int kMaxDeltaFieldNumber = 2;
  float max_delta() const;
  void set_max_delta(float value);

  // @@protoc_insertion_point(class_scope:object_detection.protos.RandomAdjustSaturation)
 private:
  void set_has_min_delta();
  void clear_has_min_delta();
  void set_has_max_delta();
  void clear_has_max_delta();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float min_delta_;
  float max_delta_;
  friend struct protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RandomDistortColor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.RandomDistortColor) */ {
 public:
  RandomDistortColor();
  virtual ~RandomDistortColor();

  RandomDistortColor(const RandomDistortColor& from);

  inline RandomDistortColor& operator=(const RandomDistortColor& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RandomDistortColor(RandomDistortColor&& from) noexcept
    : RandomDistortColor() {
    *this = ::std::move(from);
  }

  inline RandomDistortColor& operator=(RandomDistortColor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RandomDistortColor& default_instance();

  static inline const RandomDistortColor* internal_default_instance() {
    return reinterpret_cast<const RandomDistortColor*>(
               &_RandomDistortColor_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(RandomDistortColor* other);
  friend void swap(RandomDistortColor& a, RandomDistortColor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RandomDistortColor* New() const PROTOBUF_FINAL { return New(NULL); }

  RandomDistortColor* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RandomDistortColor& from);
  void MergeFrom(const RandomDistortColor& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RandomDistortColor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 color_ordering = 1;
  bool has_color_ordering() const;
  void clear_color_ordering();
  static const int kColorOrderingFieldNumber = 1;
  ::google::protobuf::int32 color_ordering() const;
  void set_color_ordering(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:object_detection.protos.RandomDistortColor)
 private:
  void set_has_color_ordering();
  void clear_has_color_ordering();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 color_ordering_;
  friend struct protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RandomJitterBoxes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.RandomJitterBoxes) */ {
 public:
  RandomJitterBoxes();
  virtual ~RandomJitterBoxes();

  RandomJitterBoxes(const RandomJitterBoxes& from);

  inline RandomJitterBoxes& operator=(const RandomJitterBoxes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RandomJitterBoxes(RandomJitterBoxes&& from) noexcept
    : RandomJitterBoxes() {
    *this = ::std::move(from);
  }

  inline RandomJitterBoxes& operator=(RandomJitterBoxes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RandomJitterBoxes& default_instance();

  static inline const RandomJitterBoxes* internal_default_instance() {
    return reinterpret_cast<const RandomJitterBoxes*>(
               &_RandomJitterBoxes_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(RandomJitterBoxes* other);
  friend void swap(RandomJitterBoxes& a, RandomJitterBoxes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RandomJitterBoxes* New() const PROTOBUF_FINAL { return New(NULL); }

  RandomJitterBoxes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RandomJitterBoxes& from);
  void MergeFrom(const RandomJitterBoxes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RandomJitterBoxes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float ratio = 1 [default = 0.05];
  bool has_ratio() const;
  void clear_ratio();
  static const int kRatioFieldNumber = 1;
  float ratio() const;
  void set_ratio(float value);

  // @@protoc_insertion_point(class_scope:object_detection.protos.RandomJitterBoxes)
 private:
  void set_has_ratio();
  void clear_has_ratio();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float ratio_;
  friend struct protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RandomCropImage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.RandomCropImage) */ {
 public:
  RandomCropImage();
  virtual ~RandomCropImage();

  RandomCropImage(const RandomCropImage& from);

  inline RandomCropImage& operator=(const RandomCropImage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RandomCropImage(RandomCropImage&& from) noexcept
    : RandomCropImage() {
    *this = ::std::move(from);
  }

  inline RandomCropImage& operator=(RandomCropImage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RandomCropImage& default_instance();

  static inline const RandomCropImage* internal_default_instance() {
    return reinterpret_cast<const RandomCropImage*>(
               &_RandomCropImage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(RandomCropImage* other);
  friend void swap(RandomCropImage& a, RandomCropImage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RandomCropImage* New() const PROTOBUF_FINAL { return New(NULL); }

  RandomCropImage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RandomCropImage& from);
  void MergeFrom(const RandomCropImage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RandomCropImage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float random_coef = 7 [default = 0];
  bool has_random_coef() const;
  void clear_random_coef();
  static const int kRandomCoefFieldNumber = 7;
  float random_coef() const;
  void set_random_coef(float value);

  // optional bool clip_boxes = 8 [default = true];
  bool has_clip_boxes() const;
  void clear_clip_boxes();
  static const int kClipBoxesFieldNumber = 8;
  bool clip_boxes() const;
  void set_clip_boxes(bool value);

  // optional float min_object_covered = 1 [default = 1];
  bool has_min_object_covered() const;
  void clear_min_object_covered();
  static const int kMinObjectCoveredFieldNumber = 1;
  float min_object_covered() const;
  void set_min_object_covered(float value);

  // optional float min_aspect_ratio = 2 [default = 0.75];
  bool has_min_aspect_ratio() const;
  void clear_min_aspect_ratio();
  static const int kMinAspectRatioFieldNumber = 2;
  float min_aspect_ratio() const;
  void set_min_aspect_ratio(float value);

  // optional float max_aspect_ratio = 3 [default = 1.33];
  bool has_max_aspect_ratio() const;
  void clear_max_aspect_ratio();
  static const int kMaxAspectRatioFieldNumber = 3;
  float max_aspect_ratio() const;
  void set_max_aspect_ratio(float value);

  // optional float min_area = 4 [default = 0.1];
  bool has_min_area() const;
  void clear_min_area();
  static const int kMinAreaFieldNumber = 4;
  float min_area() const;
  void set_min_area(float value);

  // optional float max_area = 5 [default = 1];
  bool has_max_area() const;
  void clear_max_area();
  static const int kMaxAreaFieldNumber = 5;
  float max_area() const;
  void set_max_area(float value);

  // optional float overlap_thresh = 6 [default = 0.3];
  bool has_overlap_thresh() const;
  void clear_overlap_thresh();
  static const int kOverlapThreshFieldNumber = 6;
  float overlap_thresh() const;
  void set_overlap_thresh(float value);

  // @@protoc_insertion_point(class_scope:object_detection.protos.RandomCropImage)
 private:
  void set_has_min_object_covered();
  void clear_has_min_object_covered();
  void set_has_min_aspect_ratio();
  void clear_has_min_aspect_ratio();
  void set_has_max_aspect_ratio();
  void clear_has_max_aspect_ratio();
  void set_has_min_area();
  void clear_has_min_area();
  void set_has_max_area();
  void clear_has_max_area();
  void set_has_overlap_thresh();
  void clear_has_overlap_thresh();
  void set_has_clip_boxes();
  void clear_has_clip_boxes();
  void set_has_random_coef();
  void clear_has_random_coef();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float random_coef_;
  bool clip_boxes_;
  float min_object_covered_;
  float min_aspect_ratio_;
  float max_aspect_ratio_;
  float min_area_;
  float max_area_;
  float overlap_thresh_;
  friend struct protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RandomPadImage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.RandomPadImage) */ {
 public:
  RandomPadImage();
  virtual ~RandomPadImage();

  RandomPadImage(const RandomPadImage& from);

  inline RandomPadImage& operator=(const RandomPadImage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RandomPadImage(RandomPadImage&& from) noexcept
    : RandomPadImage() {
    *this = ::std::move(from);
  }

  inline RandomPadImage& operator=(RandomPadImage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RandomPadImage& default_instance();

  static inline const RandomPadImage* internal_default_instance() {
    return reinterpret_cast<const RandomPadImage*>(
               &_RandomPadImage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(RandomPadImage* other);
  friend void swap(RandomPadImage& a, RandomPadImage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RandomPadImage* New() const PROTOBUF_FINAL { return New(NULL); }

  RandomPadImage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RandomPadImage& from);
  void MergeFrom(const RandomPadImage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RandomPadImage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float pad_color = 5;
  int pad_color_size() const;
  void clear_pad_color();
  static const int kPadColorFieldNumber = 5;
  float pad_color(int index) const;
  void set_pad_color(int index, float value);
  void add_pad_color(float value);
  const ::google::protobuf::RepeatedField< float >&
      pad_color() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_pad_color();

  // optional int32 min_image_height = 1;
  bool has_min_image_height() const;
  void clear_min_image_height();
  static const int kMinImageHeightFieldNumber = 1;
  ::google::protobuf::int32 min_image_height() const;
  void set_min_image_height(::google::protobuf::int32 value);

  // optional int32 min_image_width = 2;
  bool has_min_image_width() const;
  void clear_min_image_width();
  static const int kMinImageWidthFieldNumber = 2;
  ::google::protobuf::int32 min_image_width() const;
  void set_min_image_width(::google::protobuf::int32 value);

  // optional int32 max_image_height = 3;
  bool has_max_image_height() const;
  void clear_max_image_height();
  static const int kMaxImageHeightFieldNumber = 3;
  ::google::protobuf::int32 max_image_height() const;
  void set_max_image_height(::google::protobuf::int32 value);

  // optional int32 max_image_width = 4;
  bool has_max_image_width() const;
  void clear_max_image_width();
  static const int kMaxImageWidthFieldNumber = 4;
  ::google::protobuf::int32 max_image_width() const;
  void set_max_image_width(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:object_detection.protos.RandomPadImage)
 private:
  void set_has_min_image_height();
  void clear_has_min_image_height();
  void set_has_min_image_width();
  void clear_has_min_image_width();
  void set_has_max_image_height();
  void clear_has_max_image_height();
  void set_has_max_image_width();
  void clear_has_max_image_width();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< float > pad_color_;
  ::google::protobuf::int32 min_image_height_;
  ::google::protobuf::int32 min_image_width_;
  ::google::protobuf::int32 max_image_height_;
  ::google::protobuf::int32 max_image_width_;
  friend struct protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RandomAbsolutePadImage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.RandomAbsolutePadImage) */ {
 public:
  RandomAbsolutePadImage();
  virtual ~RandomAbsolutePadImage();

  RandomAbsolutePadImage(const RandomAbsolutePadImage& from);

  inline RandomAbsolutePadImage& operator=(const RandomAbsolutePadImage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RandomAbsolutePadImage(RandomAbsolutePadImage&& from) noexcept
    : RandomAbsolutePadImage() {
    *this = ::std::move(from);
  }

  inline RandomAbsolutePadImage& operator=(RandomAbsolutePadImage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RandomAbsolutePadImage& default_instance();

  static inline const RandomAbsolutePadImage* internal_default_instance() {
    return reinterpret_cast<const RandomAbsolutePadImage*>(
               &_RandomAbsolutePadImage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(RandomAbsolutePadImage* other);
  friend void swap(RandomAbsolutePadImage& a, RandomAbsolutePadImage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RandomAbsolutePadImage* New() const PROTOBUF_FINAL { return New(NULL); }

  RandomAbsolutePadImage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RandomAbsolutePadImage& from);
  void MergeFrom(const RandomAbsolutePadImage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RandomAbsolutePadImage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float pad_color = 3;
  int pad_color_size() const;
  void clear_pad_color();
  static const int kPadColorFieldNumber = 3;
  float pad_color(int index) const;
  void set_pad_color(int index, float value);
  void add_pad_color(float value);
  const ::google::protobuf::RepeatedField< float >&
      pad_color() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_pad_color();

  // optional int32 max_height_padding = 1;
  bool has_max_height_padding() const;
  void clear_max_height_padding();
  static const int kMaxHeightPaddingFieldNumber = 1;
  ::google::protobuf::int32 max_height_padding() const;
  void set_max_height_padding(::google::protobuf::int32 value);

  // optional int32 max_width_padding = 2;
  bool has_max_width_padding() const;
  void clear_max_width_padding();
  static const int kMaxWidthPaddingFieldNumber = 2;
  ::google::protobuf::int32 max_width_padding() const;
  void set_max_width_padding(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:object_detection.protos.RandomAbsolutePadImage)
 private:
  void set_has_max_height_padding();
  void clear_has_max_height_padding();
  void set_has_max_width_padding();
  void clear_has_max_width_padding();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< float > pad_color_;
  ::google::protobuf::int32 max_height_padding_;
  ::google::protobuf::int32 max_width_padding_;
  friend struct protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RandomCropPadImage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.RandomCropPadImage) */ {
 public:
  RandomCropPadImage();
  virtual ~RandomCropPadImage();

  RandomCropPadImage(const RandomCropPadImage& from);

  inline RandomCropPadImage& operator=(const RandomCropPadImage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RandomCropPadImage(RandomCropPadImage&& from) noexcept
    : RandomCropPadImage() {
    *this = ::std::move(from);
  }

  inline RandomCropPadImage& operator=(RandomCropPadImage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RandomCropPadImage& default_instance();

  static inline const RandomCropPadImage* internal_default_instance() {
    return reinterpret_cast<const RandomCropPadImage*>(
               &_RandomCropPadImage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(RandomCropPadImage* other);
  friend void swap(RandomCropPadImage& a, RandomCropPadImage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RandomCropPadImage* New() const PROTOBUF_FINAL { return New(NULL); }

  RandomCropPadImage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RandomCropPadImage& from);
  void MergeFrom(const RandomCropPadImage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RandomCropPadImage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float min_padded_size_ratio = 8;
  int min_padded_size_ratio_size() const;
  void clear_min_padded_size_ratio();
  static const int kMinPaddedSizeRatioFieldNumber = 8;
  float min_padded_size_ratio(int index) const;
  void set_min_padded_size_ratio(int index, float value);
  void add_min_padded_size_ratio(float value);
  const ::google::protobuf::RepeatedField< float >&
      min_padded_size_ratio() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_min_padded_size_ratio();

  // repeated float max_padded_size_ratio = 9;
  int max_padded_size_ratio_size() const;
  void clear_max_padded_size_ratio();
  static const int kMaxPaddedSizeRatioFieldNumber = 9;
  float max_padded_size_ratio(int index) const;
  void set_max_padded_size_ratio(int index, float value);
  void add_max_padded_size_ratio(float value);
  const ::google::protobuf::RepeatedField< float >&
      max_padded_size_ratio() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_max_padded_size_ratio();

  // repeated float pad_color = 10;
  int pad_color_size() const;
  void clear_pad_color();
  static const int kPadColorFieldNumber = 10;
  float pad_color(int index) const;
  void set_pad_color(int index, float value);
  void add_pad_color(float value);
  const ::google::protobuf::RepeatedField< float >&
      pad_color() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_pad_color();

  // optional float random_coef = 7 [default = 0];
  bool has_random_coef() const;
  void clear_random_coef();
  static const int kRandomCoefFieldNumber = 7;
  float random_coef() const;
  void set_random_coef(float value);

  // optional bool clip_boxes = 11 [default = true];
  bool has_clip_boxes() const;
  void clear_clip_boxes();
  static const int kClipBoxesFieldNumber = 11;
  bool clip_boxes() const;
  void set_clip_boxes(bool value);

  // optional float min_object_covered = 1 [default = 1];
  bool has_min_object_covered() const;
  void clear_min_object_covered();
  static const int kMinObjectCoveredFieldNumber = 1;
  float min_object_covered() const;
  void set_min_object_covered(float value);

  // optional float min_aspect_ratio = 2 [default = 0.75];
  bool has_min_aspect_ratio() const;
  void clear_min_aspect_ratio();
  static const int kMinAspectRatioFieldNumber = 2;
  float min_aspect_ratio() const;
  void set_min_aspect_ratio(float value);

  // optional float max_aspect_ratio = 3 [default = 1.33];
  bool has_max_aspect_ratio() const;
  void clear_max_aspect_ratio();
  static const int kMaxAspectRatioFieldNumber = 3;
  float max_aspect_ratio() const;
  void set_max_aspect_ratio(float value);

  // optional float min_area = 4 [default = 0.1];
  bool has_min_area() const;
  void clear_min_area();
  static const int kMinAreaFieldNumber = 4;
  float min_area() const;
  void set_min_area(float value);

  // optional float max_area = 5 [default = 1];
  bool has_max_area() const;
  void clear_max_area();
  static const int kMaxAreaFieldNumber = 5;
  float max_area() const;
  void set_max_area(float value);

  // optional float overlap_thresh = 6 [default = 0.3];
  bool has_overlap_thresh() const;
  void clear_overlap_thresh();
  static const int kOverlapThreshFieldNumber = 6;
  float overlap_thresh() const;
  void set_overlap_thresh(float value);

  // @@protoc_insertion_point(class_scope:object_detection.protos.RandomCropPadImage)
 private:
  void set_has_min_object_covered();
  void clear_has_min_object_covered();
  void set_has_min_aspect_ratio();
  void clear_has_min_aspect_ratio();
  void set_has_max_aspect_ratio();
  void clear_has_max_aspect_ratio();
  void set_has_min_area();
  void clear_has_min_area();
  void set_has_max_area();
  void clear_has_max_area();
  void set_has_overlap_thresh();
  void clear_has_overlap_thresh();
  void set_has_clip_boxes();
  void clear_has_clip_boxes();
  void set_has_random_coef();
  void clear_has_random_coef();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< float > min_padded_size_ratio_;
  ::google::protobuf::RepeatedField< float > max_padded_size_ratio_;
  ::google::protobuf::RepeatedField< float > pad_color_;
  float random_coef_;
  bool clip_boxes_;
  float min_object_covered_;
  float min_aspect_ratio_;
  float max_aspect_ratio_;
  float min_area_;
  float max_area_;
  float overlap_thresh_;
  friend struct protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RandomCropToAspectRatio : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.RandomCropToAspectRatio) */ {
 public:
  RandomCropToAspectRatio();
  virtual ~RandomCropToAspectRatio();

  RandomCropToAspectRatio(const RandomCropToAspectRatio& from);

  inline RandomCropToAspectRatio& operator=(const RandomCropToAspectRatio& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RandomCropToAspectRatio(RandomCropToAspectRatio&& from) noexcept
    : RandomCropToAspectRatio() {
    *this = ::std::move(from);
  }

  inline RandomCropToAspectRatio& operator=(RandomCropToAspectRatio&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RandomCropToAspectRatio& default_instance();

  static inline const RandomCropToAspectRatio* internal_default_instance() {
    return reinterpret_cast<const RandomCropToAspectRatio*>(
               &_RandomCropToAspectRatio_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(RandomCropToAspectRatio* other);
  friend void swap(RandomCropToAspectRatio& a, RandomCropToAspectRatio& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RandomCropToAspectRatio* New() const PROTOBUF_FINAL { return New(NULL); }

  RandomCropToAspectRatio* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RandomCropToAspectRatio& from);
  void MergeFrom(const RandomCropToAspectRatio& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RandomCropToAspectRatio* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool clip_boxes = 3 [default = true];
  bool has_clip_boxes() const;
  void clear_clip_boxes();
  static const int kClipBoxesFieldNumber = 3;
  bool clip_boxes() const;
  void set_clip_boxes(bool value);

  // optional float aspect_ratio = 1 [default = 1];
  bool has_aspect_ratio() const;
  void clear_aspect_ratio();
  static const int kAspectRatioFieldNumber = 1;
  float aspect_ratio() const;
  void set_aspect_ratio(float value);

  // optional float overlap_thresh = 2 [default = 0.3];
  bool has_overlap_thresh() const;
  void clear_overlap_thresh();
  static const int kOverlapThreshFieldNumber = 2;
  float overlap_thresh() const;
  void set_overlap_thresh(float value);

  // @@protoc_insertion_point(class_scope:object_detection.protos.RandomCropToAspectRatio)
 private:
  void set_has_aspect_ratio();
  void clear_has_aspect_ratio();
  void set_has_overlap_thresh();
  void clear_has_overlap_thresh();
  void set_has_clip_boxes();
  void clear_has_clip_boxes();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool clip_boxes_;
  float aspect_ratio_;
  float overlap_thresh_;
  friend struct protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RandomBlackPatches : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.RandomBlackPatches) */ {
 public:
  RandomBlackPatches();
  virtual ~RandomBlackPatches();

  RandomBlackPatches(const RandomBlackPatches& from);

  inline RandomBlackPatches& operator=(const RandomBlackPatches& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RandomBlackPatches(RandomBlackPatches&& from) noexcept
    : RandomBlackPatches() {
    *this = ::std::move(from);
  }

  inline RandomBlackPatches& operator=(RandomBlackPatches&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RandomBlackPatches& default_instance();

  static inline const RandomBlackPatches* internal_default_instance() {
    return reinterpret_cast<const RandomBlackPatches*>(
               &_RandomBlackPatches_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(RandomBlackPatches* other);
  friend void swap(RandomBlackPatches& a, RandomBlackPatches& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RandomBlackPatches* New() const PROTOBUF_FINAL { return New(NULL); }

  RandomBlackPatches* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RandomBlackPatches& from);
  void MergeFrom(const RandomBlackPatches& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RandomBlackPatches* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float size_to_image_ratio = 3 [default = 0.1];
  bool has_size_to_image_ratio() const;
  void clear_size_to_image_ratio();
  static const int kSizeToImageRatioFieldNumber = 3;
  float size_to_image_ratio() const;
  void set_size_to_image_ratio(float value);

  // optional int32 max_black_patches = 1 [default = 10];
  bool has_max_black_patches() const;
  void clear_max_black_patches();
  static const int kMaxBlackPatchesFieldNumber = 1;
  ::google::protobuf::int32 max_black_patches() const;
  void set_max_black_patches(::google::protobuf::int32 value);

  // optional float probability = 2 [default = 0.5];
  bool has_probability() const;
  void clear_probability();
  static const int kProbabilityFieldNumber = 2;
  float probability() const;
  void set_probability(float value);

  // @@protoc_insertion_point(class_scope:object_detection.protos.RandomBlackPatches)
 private:
  void set_has_max_black_patches();
  void clear_has_max_black_patches();
  void set_has_probability();
  void clear_has_probability();
  void set_has_size_to_image_ratio();
  void clear_has_size_to_image_ratio();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float size_to_image_ratio_;
  ::google::protobuf::int32 max_black_patches_;
  float probability_;
  friend struct protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RandomResizeMethod : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.RandomResizeMethod) */ {
 public:
  RandomResizeMethod();
  virtual ~RandomResizeMethod();

  RandomResizeMethod(const RandomResizeMethod& from);

  inline RandomResizeMethod& operator=(const RandomResizeMethod& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RandomResizeMethod(RandomResizeMethod&& from) noexcept
    : RandomResizeMethod() {
    *this = ::std::move(from);
  }

  inline RandomResizeMethod& operator=(RandomResizeMethod&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RandomResizeMethod& default_instance();

  static inline const RandomResizeMethod* internal_default_instance() {
    return reinterpret_cast<const RandomResizeMethod*>(
               &_RandomResizeMethod_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(RandomResizeMethod* other);
  friend void swap(RandomResizeMethod& a, RandomResizeMethod& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RandomResizeMethod* New() const PROTOBUF_FINAL { return New(NULL); }

  RandomResizeMethod* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RandomResizeMethod& from);
  void MergeFrom(const RandomResizeMethod& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RandomResizeMethod* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 target_height = 1;
  bool has_target_height() const;
  void clear_target_height();
  static const int kTargetHeightFieldNumber = 1;
  ::google::protobuf::int32 target_height() const;
  void set_target_height(::google::protobuf::int32 value);

  // optional int32 target_width = 2;
  bool has_target_width() const;
  void clear_target_width();
  static const int kTargetWidthFieldNumber = 2;
  ::google::protobuf::int32 target_width() const;
  void set_target_width(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:object_detection.protos.RandomResizeMethod)
 private:
  void set_has_target_height();
  void clear_has_target_height();
  void set_has_target_width();
  void clear_has_target_width();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 target_height_;
  ::google::protobuf::int32 target_width_;
  friend struct protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RGBtoGray : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.RGBtoGray) */ {
 public:
  RGBtoGray();
  virtual ~RGBtoGray();

  RGBtoGray(const RGBtoGray& from);

  inline RGBtoGray& operator=(const RGBtoGray& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RGBtoGray(RGBtoGray&& from) noexcept
    : RGBtoGray() {
    *this = ::std::move(from);
  }

  inline RGBtoGray& operator=(RGBtoGray&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RGBtoGray& default_instance();

  static inline const RGBtoGray* internal_default_instance() {
    return reinterpret_cast<const RGBtoGray*>(
               &_RGBtoGray_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(RGBtoGray* other);
  friend void swap(RGBtoGray& a, RGBtoGray& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RGBtoGray* New() const PROTOBUF_FINAL { return New(NULL); }

  RGBtoGray* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RGBtoGray& from);
  void MergeFrom(const RGBtoGray& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RGBtoGray* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:object_detection.protos.RGBtoGray)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScaleBoxesToPixelCoordinates : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.ScaleBoxesToPixelCoordinates) */ {
 public:
  ScaleBoxesToPixelCoordinates();
  virtual ~ScaleBoxesToPixelCoordinates();

  ScaleBoxesToPixelCoordinates(const ScaleBoxesToPixelCoordinates& from);

  inline ScaleBoxesToPixelCoordinates& operator=(const ScaleBoxesToPixelCoordinates& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScaleBoxesToPixelCoordinates(ScaleBoxesToPixelCoordinates&& from) noexcept
    : ScaleBoxesToPixelCoordinates() {
    *this = ::std::move(from);
  }

  inline ScaleBoxesToPixelCoordinates& operator=(ScaleBoxesToPixelCoordinates&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScaleBoxesToPixelCoordinates& default_instance();

  static inline const ScaleBoxesToPixelCoordinates* internal_default_instance() {
    return reinterpret_cast<const ScaleBoxesToPixelCoordinates*>(
               &_ScaleBoxesToPixelCoordinates_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(ScaleBoxesToPixelCoordinates* other);
  friend void swap(ScaleBoxesToPixelCoordinates& a, ScaleBoxesToPixelCoordinates& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScaleBoxesToPixelCoordinates* New() const PROTOBUF_FINAL { return New(NULL); }

  ScaleBoxesToPixelCoordinates* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ScaleBoxesToPixelCoordinates& from);
  void MergeFrom(const ScaleBoxesToPixelCoordinates& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ScaleBoxesToPixelCoordinates* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:object_detection.protos.ScaleBoxesToPixelCoordinates)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResizeImage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.ResizeImage) */ {
 public:
  ResizeImage();
  virtual ~ResizeImage();

  ResizeImage(const ResizeImage& from);

  inline ResizeImage& operator=(const ResizeImage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResizeImage(ResizeImage&& from) noexcept
    : ResizeImage() {
    *this = ::std::move(from);
  }

  inline ResizeImage& operator=(ResizeImage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResizeImage& default_instance();

  static inline const ResizeImage* internal_default_instance() {
    return reinterpret_cast<const ResizeImage*>(
               &_ResizeImage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(ResizeImage* other);
  friend void swap(ResizeImage& a, ResizeImage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResizeImage* New() const PROTOBUF_FINAL { return New(NULL); }

  ResizeImage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResizeImage& from);
  void MergeFrom(const ResizeImage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResizeImage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ResizeImage_Method Method;
  static const Method AREA =
    ResizeImage_Method_AREA;
  static const Method BICUBIC =
    ResizeImage_Method_BICUBIC;
  static const Method BILINEAR =
    ResizeImage_Method_BILINEAR;
  static const Method NEAREST_NEIGHBOR =
    ResizeImage_Method_NEAREST_NEIGHBOR;
  static inline bool Method_IsValid(int value) {
    return ResizeImage_Method_IsValid(value);
  }
  static const Method Method_MIN =
    ResizeImage_Method_Method_MIN;
  static const Method Method_MAX =
    ResizeImage_Method_Method_MAX;
  static const int Method_ARRAYSIZE =
    ResizeImage_Method_Method_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Method_descriptor() {
    return ResizeImage_Method_descriptor();
  }
  static inline const ::std::string& Method_Name(Method value) {
    return ResizeImage_Method_Name(value);
  }
  static inline bool Method_Parse(const ::std::string& name,
      Method* value) {
    return ResizeImage_Method_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional int32 new_height = 1;
  bool has_new_height() const;
  void clear_new_height();
  static const int kNewHeightFieldNumber = 1;
  ::google::protobuf::int32 new_height() const;
  void set_new_height(::google::protobuf::int32 value);

  // optional int32 new_width = 2;
  bool has_new_width() const;
  void clear_new_width();
  static const int kNewWidthFieldNumber = 2;
  ::google::protobuf::int32 new_width() const;
  void set_new_width(::google::protobuf::int32 value);

  // optional .object_detection.protos.ResizeImage.Method method = 3 [default = BILINEAR];
  bool has_method() const;
  void clear_method();
  static const int kMethodFieldNumber = 3;
  ::object_detection::protos::ResizeImage_Method method() const;
  void set_method(::object_detection::protos::ResizeImage_Method value);

  // @@protoc_insertion_point(class_scope:object_detection.protos.ResizeImage)
 private:
  void set_has_new_height();
  void clear_has_new_height();
  void set_has_new_width();
  void clear_has_new_width();
  void set_has_method();
  void clear_has_method();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 new_height_;
  ::google::protobuf::int32 new_width_;
  int method_;
  friend struct protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SubtractChannelMean : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.SubtractChannelMean) */ {
 public:
  SubtractChannelMean();
  virtual ~SubtractChannelMean();

  SubtractChannelMean(const SubtractChannelMean& from);

  inline SubtractChannelMean& operator=(const SubtractChannelMean& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SubtractChannelMean(SubtractChannelMean&& from) noexcept
    : SubtractChannelMean() {
    *this = ::std::move(from);
  }

  inline SubtractChannelMean& operator=(SubtractChannelMean&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubtractChannelMean& default_instance();

  static inline const SubtractChannelMean* internal_default_instance() {
    return reinterpret_cast<const SubtractChannelMean*>(
               &_SubtractChannelMean_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(SubtractChannelMean* other);
  friend void swap(SubtractChannelMean& a, SubtractChannelMean& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SubtractChannelMean* New() const PROTOBUF_FINAL { return New(NULL); }

  SubtractChannelMean* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SubtractChannelMean& from);
  void MergeFrom(const SubtractChannelMean& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SubtractChannelMean* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float means = 1;
  int means_size() const;
  void clear_means();
  static const int kMeansFieldNumber = 1;
  float means(int index) const;
  void set_means(int index, float value);
  void add_means(float value);
  const ::google::protobuf::RepeatedField< float >&
      means() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_means();

  // @@protoc_insertion_point(class_scope:object_detection.protos.SubtractChannelMean)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< float > means_;
  friend struct protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SSDRandomCropOperation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.SSDRandomCropOperation) */ {
 public:
  SSDRandomCropOperation();
  virtual ~SSDRandomCropOperation();

  SSDRandomCropOperation(const SSDRandomCropOperation& from);

  inline SSDRandomCropOperation& operator=(const SSDRandomCropOperation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SSDRandomCropOperation(SSDRandomCropOperation&& from) noexcept
    : SSDRandomCropOperation() {
    *this = ::std::move(from);
  }

  inline SSDRandomCropOperation& operator=(SSDRandomCropOperation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SSDRandomCropOperation& default_instance();

  static inline const SSDRandomCropOperation* internal_default_instance() {
    return reinterpret_cast<const SSDRandomCropOperation*>(
               &_SSDRandomCropOperation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(SSDRandomCropOperation* other);
  friend void swap(SSDRandomCropOperation& a, SSDRandomCropOperation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SSDRandomCropOperation* New() const PROTOBUF_FINAL { return New(NULL); }

  SSDRandomCropOperation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SSDRandomCropOperation& from);
  void MergeFrom(const SSDRandomCropOperation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SSDRandomCropOperation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float min_object_covered = 1;
  bool has_min_object_covered() const;
  void clear_min_object_covered();
  static const int kMinObjectCoveredFieldNumber = 1;
  float min_object_covered() const;
  void set_min_object_covered(float value);

  // optional float min_aspect_ratio = 2;
  bool has_min_aspect_ratio() const;
  void clear_min_aspect_ratio();
  static const int kMinAspectRatioFieldNumber = 2;
  float min_aspect_ratio() const;
  void set_min_aspect_ratio(float value);

  // optional float max_aspect_ratio = 3;
  bool has_max_aspect_ratio() const;
  void clear_max_aspect_ratio();
  static const int kMaxAspectRatioFieldNumber = 3;
  float max_aspect_ratio() const;
  void set_max_aspect_ratio(float value);

  // optional float min_area = 4;
  bool has_min_area() const;
  void clear_min_area();
  static const int kMinAreaFieldNumber = 4;
  float min_area() const;
  void set_min_area(float value);

  // optional float max_area = 5;
  bool has_max_area() const;
  void clear_max_area();
  static const int kMaxAreaFieldNumber = 5;
  float max_area() const;
  void set_max_area(float value);

  // optional float overlap_thresh = 6;
  bool has_overlap_thresh() const;
  void clear_overlap_thresh();
  static const int kOverlapThreshFieldNumber = 6;
  float overlap_thresh() const;
  void set_overlap_thresh(float value);

  // optional float random_coef = 7;
  bool has_random_coef() const;
  void clear_random_coef();
  static const int kRandomCoefFieldNumber = 7;
  float random_coef() const;
  void set_random_coef(float value);

  // optional bool clip_boxes = 8 [default = true];
  bool has_clip_boxes() const;
  void clear_clip_boxes();
  static const int kClipBoxesFieldNumber = 8;
  bool clip_boxes() const;
  void set_clip_boxes(bool value);

  // @@protoc_insertion_point(class_scope:object_detection.protos.SSDRandomCropOperation)
 private:
  void set_has_min_object_covered();
  void clear_has_min_object_covered();
  void set_has_min_aspect_ratio();
  void clear_has_min_aspect_ratio();
  void set_has_max_aspect_ratio();
  void clear_has_max_aspect_ratio();
  void set_has_min_area();
  void clear_has_min_area();
  void set_has_max_area();
  void clear_has_max_area();
  void set_has_overlap_thresh();
  void clear_has_overlap_thresh();
  void set_has_clip_boxes();
  void clear_has_clip_boxes();
  void set_has_random_coef();
  void clear_has_random_coef();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float min_object_covered_;
  float min_aspect_ratio_;
  float max_aspect_ratio_;
  float min_area_;
  float max_area_;
  float overlap_thresh_;
  float random_coef_;
  bool clip_boxes_;
  friend struct protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SSDRandomCrop : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.SSDRandomCrop) */ {
 public:
  SSDRandomCrop();
  virtual ~SSDRandomCrop();

  SSDRandomCrop(const SSDRandomCrop& from);

  inline SSDRandomCrop& operator=(const SSDRandomCrop& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SSDRandomCrop(SSDRandomCrop&& from) noexcept
    : SSDRandomCrop() {
    *this = ::std::move(from);
  }

  inline SSDRandomCrop& operator=(SSDRandomCrop&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SSDRandomCrop& default_instance();

  static inline const SSDRandomCrop* internal_default_instance() {
    return reinterpret_cast<const SSDRandomCrop*>(
               &_SSDRandomCrop_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(SSDRandomCrop* other);
  friend void swap(SSDRandomCrop& a, SSDRandomCrop& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SSDRandomCrop* New() const PROTOBUF_FINAL { return New(NULL); }

  SSDRandomCrop* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SSDRandomCrop& from);
  void MergeFrom(const SSDRandomCrop& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SSDRandomCrop* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .object_detection.protos.SSDRandomCropOperation operations = 1;
  int operations_size() const;
  void clear_operations();
  static const int kOperationsFieldNumber = 1;
  const ::object_detection::protos::SSDRandomCropOperation& operations(int index) const;
  ::object_detection::protos::SSDRandomCropOperation* mutable_operations(int index);
  ::object_detection::protos::SSDRandomCropOperation* add_operations();
  ::google::protobuf::RepeatedPtrField< ::object_detection::protos::SSDRandomCropOperation >*
      mutable_operations();
  const ::google::protobuf::RepeatedPtrField< ::object_detection::protos::SSDRandomCropOperation >&
      operations() const;

  // @@protoc_insertion_point(class_scope:object_detection.protos.SSDRandomCrop)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::object_detection::protos::SSDRandomCropOperation > operations_;
  friend struct protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SSDRandomCropPadOperation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.SSDRandomCropPadOperation) */ {
 public:
  SSDRandomCropPadOperation();
  virtual ~SSDRandomCropPadOperation();

  SSDRandomCropPadOperation(const SSDRandomCropPadOperation& from);

  inline SSDRandomCropPadOperation& operator=(const SSDRandomCropPadOperation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SSDRandomCropPadOperation(SSDRandomCropPadOperation&& from) noexcept
    : SSDRandomCropPadOperation() {
    *this = ::std::move(from);
  }

  inline SSDRandomCropPadOperation& operator=(SSDRandomCropPadOperation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SSDRandomCropPadOperation& default_instance();

  static inline const SSDRandomCropPadOperation* internal_default_instance() {
    return reinterpret_cast<const SSDRandomCropPadOperation*>(
               &_SSDRandomCropPadOperation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(SSDRandomCropPadOperation* other);
  friend void swap(SSDRandomCropPadOperation& a, SSDRandomCropPadOperation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SSDRandomCropPadOperation* New() const PROTOBUF_FINAL { return New(NULL); }

  SSDRandomCropPadOperation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SSDRandomCropPadOperation& from);
  void MergeFrom(const SSDRandomCropPadOperation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SSDRandomCropPadOperation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float min_padded_size_ratio = 8;
  int min_padded_size_ratio_size() const;
  void clear_min_padded_size_ratio();
  static const int kMinPaddedSizeRatioFieldNumber = 8;
  float min_padded_size_ratio(int index) const;
  void set_min_padded_size_ratio(int index, float value);
  void add_min_padded_size_ratio(float value);
  const ::google::protobuf::RepeatedField< float >&
      min_padded_size_ratio() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_min_padded_size_ratio();

  // repeated float max_padded_size_ratio = 9;
  int max_padded_size_ratio_size() const;
  void clear_max_padded_size_ratio();
  static const int kMaxPaddedSizeRatioFieldNumber = 9;
  float max_padded_size_ratio(int index) const;
  void set_max_padded_size_ratio(int index, float value);
  void add_max_padded_size_ratio(float value);
  const ::google::protobuf::RepeatedField< float >&
      max_padded_size_ratio() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_max_padded_size_ratio();

  // optional float min_object_covered = 1;
  bool has_min_object_covered() const;
  void clear_min_object_covered();
  static const int kMinObjectCoveredFieldNumber = 1;
  float min_object_covered() const;
  void set_min_object_covered(float value);

  // optional float min_aspect_ratio = 2;
  bool has_min_aspect_ratio() const;
  void clear_min_aspect_ratio();
  static const int kMinAspectRatioFieldNumber = 2;
  float min_aspect_ratio() const;
  void set_min_aspect_ratio(float value);

  // optional float max_aspect_ratio = 3;
  bool has_max_aspect_ratio() const;
  void clear_max_aspect_ratio();
  static const int kMaxAspectRatioFieldNumber = 3;
  float max_aspect_ratio() const;
  void set_max_aspect_ratio(float value);

  // optional float min_area = 4;
  bool has_min_area() const;
  void clear_min_area();
  static const int kMinAreaFieldNumber = 4;
  float min_area() const;
  void set_min_area(float value);

  // optional float max_area = 5;
  bool has_max_area() const;
  void clear_max_area();
  static const int kMaxAreaFieldNumber = 5;
  float max_area() const;
  void set_max_area(float value);

  // optional float overlap_thresh = 6;
  bool has_overlap_thresh() const;
  void clear_overlap_thresh();
  static const int kOverlapThreshFieldNumber = 6;
  float overlap_thresh() const;
  void set_overlap_thresh(float value);

  // optional float random_coef = 7;
  bool has_random_coef() const;
  void clear_random_coef();
  static const int kRandomCoefFieldNumber = 7;
  float random_coef() const;
  void set_random_coef(float value);

  // optional float pad_color_r = 10;
  bool has_pad_color_r() const;
  void clear_pad_color_r();
  static const int kPadColorRFieldNumber = 10;
  float pad_color_r() const;
  void set_pad_color_r(float value);

  // optional float pad_color_g = 11;
  bool has_pad_color_g() const;
  void clear_pad_color_g();
  static const int kPadColorGFieldNumber = 11;
  float pad_color_g() const;
  void set_pad_color_g(float value);

  // optional float pad_color_b = 12;
  bool has_pad_color_b() const;
  void clear_pad_color_b();
  static const int kPadColorBFieldNumber = 12;
  float pad_color_b() const;
  void set_pad_color_b(float value);

  // optional bool clip_boxes = 13 [default = true];
  bool has_clip_boxes() const;
  void clear_clip_boxes();
  static const int kClipBoxesFieldNumber = 13;
  bool clip_boxes() const;
  void set_clip_boxes(bool value);

  // @@protoc_insertion_point(class_scope:object_detection.protos.SSDRandomCropPadOperation)
 private:
  void set_has_min_object_covered();
  void clear_has_min_object_covered();
  void set_has_min_aspect_ratio();
  void clear_has_min_aspect_ratio();
  void set_has_max_aspect_ratio();
  void clear_has_max_aspect_ratio();
  void set_has_min_area();
  void clear_has_min_area();
  void set_has_max_area();
  void clear_has_max_area();
  void set_has_overlap_thresh();
  void clear_has_overlap_thresh();
  void set_has_clip_boxes();
  void clear_has_clip_boxes();
  void set_has_random_coef();
  void clear_has_random_coef();
  void set_has_pad_color_r();
  void clear_has_pad_color_r();
  void set_has_pad_color_g();
  void clear_has_pad_color_g();
  void set_has_pad_color_b();
  void clear_has_pad_color_b();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< float > min_padded_size_ratio_;
  ::google::protobuf::RepeatedField< float > max_padded_size_ratio_;
  float min_object_covered_;
  float min_aspect_ratio_;
  float max_aspect_ratio_;
  float min_area_;
  float max_area_;
  float overlap_thresh_;
  float random_coef_;
  float pad_color_r_;
  float pad_color_g_;
  float pad_color_b_;
  bool clip_boxes_;
  friend struct protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SSDRandomCropPad : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.SSDRandomCropPad) */ {
 public:
  SSDRandomCropPad();
  virtual ~SSDRandomCropPad();

  SSDRandomCropPad(const SSDRandomCropPad& from);

  inline SSDRandomCropPad& operator=(const SSDRandomCropPad& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SSDRandomCropPad(SSDRandomCropPad&& from) noexcept
    : SSDRandomCropPad() {
    *this = ::std::move(from);
  }

  inline SSDRandomCropPad& operator=(SSDRandomCropPad&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SSDRandomCropPad& default_instance();

  static inline const SSDRandomCropPad* internal_default_instance() {
    return reinterpret_cast<const SSDRandomCropPad*>(
               &_SSDRandomCropPad_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(SSDRandomCropPad* other);
  friend void swap(SSDRandomCropPad& a, SSDRandomCropPad& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SSDRandomCropPad* New() const PROTOBUF_FINAL { return New(NULL); }

  SSDRandomCropPad* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SSDRandomCropPad& from);
  void MergeFrom(const SSDRandomCropPad& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SSDRandomCropPad* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .object_detection.protos.SSDRandomCropPadOperation operations = 1;
  int operations_size() const;
  void clear_operations();
  static const int kOperationsFieldNumber = 1;
  const ::object_detection::protos::SSDRandomCropPadOperation& operations(int index) const;
  ::object_detection::protos::SSDRandomCropPadOperation* mutable_operations(int index);
  ::object_detection::protos::SSDRandomCropPadOperation* add_operations();
  ::google::protobuf::RepeatedPtrField< ::object_detection::protos::SSDRandomCropPadOperation >*
      mutable_operations();
  const ::google::protobuf::RepeatedPtrField< ::object_detection::protos::SSDRandomCropPadOperation >&
      operations() const;

  // @@protoc_insertion_point(class_scope:object_detection.protos.SSDRandomCropPad)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::object_detection::protos::SSDRandomCropPadOperation > operations_;
  friend struct protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SSDRandomCropFixedAspectRatioOperation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.SSDRandomCropFixedAspectRatioOperation) */ {
 public:
  SSDRandomCropFixedAspectRatioOperation();
  virtual ~SSDRandomCropFixedAspectRatioOperation();

  SSDRandomCropFixedAspectRatioOperation(const SSDRandomCropFixedAspectRatioOperation& from);

  inline SSDRandomCropFixedAspectRatioOperation& operator=(const SSDRandomCropFixedAspectRatioOperation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SSDRandomCropFixedAspectRatioOperation(SSDRandomCropFixedAspectRatioOperation&& from) noexcept
    : SSDRandomCropFixedAspectRatioOperation() {
    *this = ::std::move(from);
  }

  inline SSDRandomCropFixedAspectRatioOperation& operator=(SSDRandomCropFixedAspectRatioOperation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SSDRandomCropFixedAspectRatioOperation& default_instance();

  static inline const SSDRandomCropFixedAspectRatioOperation* internal_default_instance() {
    return reinterpret_cast<const SSDRandomCropFixedAspectRatioOperation*>(
               &_SSDRandomCropFixedAspectRatioOperation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(SSDRandomCropFixedAspectRatioOperation* other);
  friend void swap(SSDRandomCropFixedAspectRatioOperation& a, SSDRandomCropFixedAspectRatioOperation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SSDRandomCropFixedAspectRatioOperation* New() const PROTOBUF_FINAL { return New(NULL); }

  SSDRandomCropFixedAspectRatioOperation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SSDRandomCropFixedAspectRatioOperation& from);
  void MergeFrom(const SSDRandomCropFixedAspectRatioOperation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SSDRandomCropFixedAspectRatioOperation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float min_object_covered = 1;
  bool has_min_object_covered() const;
  void clear_min_object_covered();
  static const int kMinObjectCoveredFieldNumber = 1;
  float min_object_covered() const;
  void set_min_object_covered(float value);

  // optional float min_area = 4;
  bool has_min_area() const;
  void clear_min_area();
  static const int kMinAreaFieldNumber = 4;
  float min_area() const;
  void set_min_area(float value);

  // optional float max_area = 5;
  bool has_max_area() const;
  void clear_max_area();
  static const int kMaxAreaFieldNumber = 5;
  float max_area() const;
  void set_max_area(float value);

  // optional float overlap_thresh = 6;
  bool has_overlap_thresh() const;
  void clear_overlap_thresh();
  static const int kOverlapThreshFieldNumber = 6;
  float overlap_thresh() const;
  void set_overlap_thresh(float value);

  // optional float random_coef = 7;
  bool has_random_coef() const;
  void clear_random_coef();
  static const int kRandomCoefFieldNumber = 7;
  float random_coef() const;
  void set_random_coef(float value);

  // optional bool clip_boxes = 8 [default = true];
  bool has_clip_boxes() const;
  void clear_clip_boxes();
  static const int kClipBoxesFieldNumber = 8;
  bool clip_boxes() const;
  void set_clip_boxes(bool value);

  // @@protoc_insertion_point(class_scope:object_detection.protos.SSDRandomCropFixedAspectRatioOperation)
 private:
  void set_has_min_object_covered();
  void clear_has_min_object_covered();
  void set_has_min_area();
  void clear_has_min_area();
  void set_has_max_area();
  void clear_has_max_area();
  void set_has_overlap_thresh();
  void clear_has_overlap_thresh();
  void set_has_clip_boxes();
  void clear_has_clip_boxes();
  void set_has_random_coef();
  void clear_has_random_coef();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float min_object_covered_;
  float min_area_;
  float max_area_;
  float overlap_thresh_;
  float random_coef_;
  bool clip_boxes_;
  friend struct protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SSDRandomCropFixedAspectRatio : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.SSDRandomCropFixedAspectRatio) */ {
 public:
  SSDRandomCropFixedAspectRatio();
  virtual ~SSDRandomCropFixedAspectRatio();

  SSDRandomCropFixedAspectRatio(const SSDRandomCropFixedAspectRatio& from);

  inline SSDRandomCropFixedAspectRatio& operator=(const SSDRandomCropFixedAspectRatio& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SSDRandomCropFixedAspectRatio(SSDRandomCropFixedAspectRatio&& from) noexcept
    : SSDRandomCropFixedAspectRatio() {
    *this = ::std::move(from);
  }

  inline SSDRandomCropFixedAspectRatio& operator=(SSDRandomCropFixedAspectRatio&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SSDRandomCropFixedAspectRatio& default_instance();

  static inline const SSDRandomCropFixedAspectRatio* internal_default_instance() {
    return reinterpret_cast<const SSDRandomCropFixedAspectRatio*>(
               &_SSDRandomCropFixedAspectRatio_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void Swap(SSDRandomCropFixedAspectRatio* other);
  friend void swap(SSDRandomCropFixedAspectRatio& a, SSDRandomCropFixedAspectRatio& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SSDRandomCropFixedAspectRatio* New() const PROTOBUF_FINAL { return New(NULL); }

  SSDRandomCropFixedAspectRatio* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SSDRandomCropFixedAspectRatio& from);
  void MergeFrom(const SSDRandomCropFixedAspectRatio& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SSDRandomCropFixedAspectRatio* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .object_detection.protos.SSDRandomCropFixedAspectRatioOperation operations = 1;
  int operations_size() const;
  void clear_operations();
  static const int kOperationsFieldNumber = 1;
  const ::object_detection::protos::SSDRandomCropFixedAspectRatioOperation& operations(int index) const;
  ::object_detection::protos::SSDRandomCropFixedAspectRatioOperation* mutable_operations(int index);
  ::object_detection::protos::SSDRandomCropFixedAspectRatioOperation* add_operations();
  ::google::protobuf::RepeatedPtrField< ::object_detection::protos::SSDRandomCropFixedAspectRatioOperation >*
      mutable_operations();
  const ::google::protobuf::RepeatedPtrField< ::object_detection::protos::SSDRandomCropFixedAspectRatioOperation >&
      operations() const;

  // optional float aspect_ratio = 2 [default = 1];
  bool has_aspect_ratio() const;
  void clear_aspect_ratio();
  static const int kAspectRatioFieldNumber = 2;
  float aspect_ratio() const;
  void set_aspect_ratio(float value);

  // @@protoc_insertion_point(class_scope:object_detection.protos.SSDRandomCropFixedAspectRatio)
 private:
  void set_has_aspect_ratio();
  void clear_has_aspect_ratio();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::object_detection::protos::SSDRandomCropFixedAspectRatioOperation > operations_;
  float aspect_ratio_;
  friend struct protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SSDRandomCropPadFixedAspectRatioOperation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.SSDRandomCropPadFixedAspectRatioOperation) */ {
 public:
  SSDRandomCropPadFixedAspectRatioOperation();
  virtual ~SSDRandomCropPadFixedAspectRatioOperation();

  SSDRandomCropPadFixedAspectRatioOperation(const SSDRandomCropPadFixedAspectRatioOperation& from);

  inline SSDRandomCropPadFixedAspectRatioOperation& operator=(const SSDRandomCropPadFixedAspectRatioOperation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SSDRandomCropPadFixedAspectRatioOperation(SSDRandomCropPadFixedAspectRatioOperation&& from) noexcept
    : SSDRandomCropPadFixedAspectRatioOperation() {
    *this = ::std::move(from);
  }

  inline SSDRandomCropPadFixedAspectRatioOperation& operator=(SSDRandomCropPadFixedAspectRatioOperation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SSDRandomCropPadFixedAspectRatioOperation& default_instance();

  static inline const SSDRandomCropPadFixedAspectRatioOperation* internal_default_instance() {
    return reinterpret_cast<const SSDRandomCropPadFixedAspectRatioOperation*>(
               &_SSDRandomCropPadFixedAspectRatioOperation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void Swap(SSDRandomCropPadFixedAspectRatioOperation* other);
  friend void swap(SSDRandomCropPadFixedAspectRatioOperation& a, SSDRandomCropPadFixedAspectRatioOperation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SSDRandomCropPadFixedAspectRatioOperation* New() const PROTOBUF_FINAL { return New(NULL); }

  SSDRandomCropPadFixedAspectRatioOperation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SSDRandomCropPadFixedAspectRatioOperation& from);
  void MergeFrom(const SSDRandomCropPadFixedAspectRatioOperation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SSDRandomCropPadFixedAspectRatioOperation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float min_object_covered = 1;
  bool has_min_object_covered() const;
  void clear_min_object_covered();
  static const int kMinObjectCoveredFieldNumber = 1;
  float min_object_covered() const;
  void set_min_object_covered(float value);

  // optional float min_aspect_ratio = 2;
  bool has_min_aspect_ratio() const;
  void clear_min_aspect_ratio();
  static const int kMinAspectRatioFieldNumber = 2;
  float min_aspect_ratio() const;
  void set_min_aspect_ratio(float value);

  // optional float max_aspect_ratio = 3;
  bool has_max_aspect_ratio() const;
  void clear_max_aspect_ratio();
  static const int kMaxAspectRatioFieldNumber = 3;
  float max_aspect_ratio() const;
  void set_max_aspect_ratio(float value);

  // optional float min_area = 4;
  bool has_min_area() const;
  void clear_min_area();
  static const int kMinAreaFieldNumber = 4;
  float min_area() const;
  void set_min_area(float value);

  // optional float max_area = 5;
  bool has_max_area() const;
  void clear_max_area();
  static const int kMaxAreaFieldNumber = 5;
  float max_area() const;
  void set_max_area(float value);

  // optional float overlap_thresh = 6;
  bool has_overlap_thresh() const;
  void clear_overlap_thresh();
  static const int kOverlapThreshFieldNumber = 6;
  float overlap_thresh() const;
  void set_overlap_thresh(float value);

  // optional float random_coef = 7;
  bool has_random_coef() const;
  void clear_random_coef();
  static const int kRandomCoefFieldNumber = 7;
  float random_coef() const;
  void set_random_coef(float value);

  // optional bool clip_boxes = 8 [default = true];
  bool has_clip_boxes() const;
  void clear_clip_boxes();
  static const int kClipBoxesFieldNumber = 8;
  bool clip_boxes() const;
  void set_clip_boxes(bool value);

  // @@protoc_insertion_point(class_scope:object_detection.protos.SSDRandomCropPadFixedAspectRatioOperation)
 private:
  void set_has_min_object_covered();
  void clear_has_min_object_covered();
  void set_has_min_aspect_ratio();
  void clear_has_min_aspect_ratio();
  void set_has_max_aspect_ratio();
  void clear_has_max_aspect_ratio();
  void set_has_min_area();
  void clear_has_min_area();
  void set_has_max_area();
  void clear_has_max_area();
  void set_has_overlap_thresh();
  void clear_has_overlap_thresh();
  void set_has_clip_boxes();
  void clear_has_clip_boxes();
  void set_has_random_coef();
  void clear_has_random_coef();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float min_object_covered_;
  float min_aspect_ratio_;
  float max_aspect_ratio_;
  float min_area_;
  float max_area_;
  float overlap_thresh_;
  float random_coef_;
  bool clip_boxes_;
  friend struct protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SSDRandomCropPadFixedAspectRatio : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.SSDRandomCropPadFixedAspectRatio) */ {
 public:
  SSDRandomCropPadFixedAspectRatio();
  virtual ~SSDRandomCropPadFixedAspectRatio();

  SSDRandomCropPadFixedAspectRatio(const SSDRandomCropPadFixedAspectRatio& from);

  inline SSDRandomCropPadFixedAspectRatio& operator=(const SSDRandomCropPadFixedAspectRatio& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SSDRandomCropPadFixedAspectRatio(SSDRandomCropPadFixedAspectRatio&& from) noexcept
    : SSDRandomCropPadFixedAspectRatio() {
    *this = ::std::move(from);
  }

  inline SSDRandomCropPadFixedAspectRatio& operator=(SSDRandomCropPadFixedAspectRatio&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SSDRandomCropPadFixedAspectRatio& default_instance();

  static inline const SSDRandomCropPadFixedAspectRatio* internal_default_instance() {
    return reinterpret_cast<const SSDRandomCropPadFixedAspectRatio*>(
               &_SSDRandomCropPadFixedAspectRatio_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void Swap(SSDRandomCropPadFixedAspectRatio* other);
  friend void swap(SSDRandomCropPadFixedAspectRatio& a, SSDRandomCropPadFixedAspectRatio& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SSDRandomCropPadFixedAspectRatio* New() const PROTOBUF_FINAL { return New(NULL); }

  SSDRandomCropPadFixedAspectRatio* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SSDRandomCropPadFixedAspectRatio& from);
  void MergeFrom(const SSDRandomCropPadFixedAspectRatio& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SSDRandomCropPadFixedAspectRatio* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .object_detection.protos.SSDRandomCropPadFixedAspectRatioOperation operations = 1;
  int operations_size() const;
  void clear_operations();
  static const int kOperationsFieldNumber = 1;
  const ::object_detection::protos::SSDRandomCropPadFixedAspectRatioOperation& operations(int index) const;
  ::object_detection::protos::SSDRandomCropPadFixedAspectRatioOperation* mutable_operations(int index);
  ::object_detection::protos::SSDRandomCropPadFixedAspectRatioOperation* add_operations();
  ::google::protobuf::RepeatedPtrField< ::object_detection::protos::SSDRandomCropPadFixedAspectRatioOperation >*
      mutable_operations();
  const ::google::protobuf::RepeatedPtrField< ::object_detection::protos::SSDRandomCropPadFixedAspectRatioOperation >&
      operations() const;

  // repeated float min_padded_size_ratio = 3;
  int min_padded_size_ratio_size() const;
  void clear_min_padded_size_ratio();
  static const int kMinPaddedSizeRatioFieldNumber = 3;
  float min_padded_size_ratio(int index) const;
  void set_min_padded_size_ratio(int index, float value);
  void add_min_padded_size_ratio(float value);
  const ::google::protobuf::RepeatedField< float >&
      min_padded_size_ratio() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_min_padded_size_ratio();

  // repeated float max_padded_size_ratio = 4;
  int max_padded_size_ratio_size() const;
  void clear_max_padded_size_ratio();
  static const int kMaxPaddedSizeRatioFieldNumber = 4;
  float max_padded_size_ratio(int index) const;
  void set_max_padded_size_ratio(int index, float value);
  void add_max_padded_size_ratio(float value);
  const ::google::protobuf::RepeatedField< float >&
      max_padded_size_ratio() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_max_padded_size_ratio();

  // optional float aspect_ratio = 2 [default = 1];
  bool has_aspect_ratio() const;
  void clear_aspect_ratio();
  static const int kAspectRatioFieldNumber = 2;
  float aspect_ratio() const;
  void set_aspect_ratio(float value);

  // @@protoc_insertion_point(class_scope:object_detection.protos.SSDRandomCropPadFixedAspectRatio)
 private:
  void set_has_aspect_ratio();
  void clear_has_aspect_ratio();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::object_detection::protos::SSDRandomCropPadFixedAspectRatioOperation > operations_;
  ::google::protobuf::RepeatedField< float > min_padded_size_ratio_;
  ::google::protobuf::RepeatedField< float > max_padded_size_ratio_;
  float aspect_ratio_;
  friend struct protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConvertClassLogitsToSoftmax : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.ConvertClassLogitsToSoftmax) */ {
 public:
  ConvertClassLogitsToSoftmax();
  virtual ~ConvertClassLogitsToSoftmax();

  ConvertClassLogitsToSoftmax(const ConvertClassLogitsToSoftmax& from);

  inline ConvertClassLogitsToSoftmax& operator=(const ConvertClassLogitsToSoftmax& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConvertClassLogitsToSoftmax(ConvertClassLogitsToSoftmax&& from) noexcept
    : ConvertClassLogitsToSoftmax() {
    *this = ::std::move(from);
  }

  inline ConvertClassLogitsToSoftmax& operator=(ConvertClassLogitsToSoftmax&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConvertClassLogitsToSoftmax& default_instance();

  static inline const ConvertClassLogitsToSoftmax* internal_default_instance() {
    return reinterpret_cast<const ConvertClassLogitsToSoftmax*>(
               &_ConvertClassLogitsToSoftmax_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    33;

  void Swap(ConvertClassLogitsToSoftmax* other);
  friend void swap(ConvertClassLogitsToSoftmax& a, ConvertClassLogitsToSoftmax& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConvertClassLogitsToSoftmax* New() const PROTOBUF_FINAL { return New(NULL); }

  ConvertClassLogitsToSoftmax* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ConvertClassLogitsToSoftmax& from);
  void MergeFrom(const ConvertClassLogitsToSoftmax& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ConvertClassLogitsToSoftmax* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float temperature = 1 [default = 1];
  bool has_temperature() const;
  void clear_temperature();
  static const int kTemperatureFieldNumber = 1;
  float temperature() const;
  void set_temperature(float value);

  // @@protoc_insertion_point(class_scope:object_detection.protos.ConvertClassLogitsToSoftmax)
 private:
  void set_has_temperature();
  void clear_has_temperature();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float temperature_;
  friend struct protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RandomSelfConcatImage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.RandomSelfConcatImage) */ {
 public:
  RandomSelfConcatImage();
  virtual ~RandomSelfConcatImage();

  RandomSelfConcatImage(const RandomSelfConcatImage& from);

  inline RandomSelfConcatImage& operator=(const RandomSelfConcatImage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RandomSelfConcatImage(RandomSelfConcatImage&& from) noexcept
    : RandomSelfConcatImage() {
    *this = ::std::move(from);
  }

  inline RandomSelfConcatImage& operator=(RandomSelfConcatImage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RandomSelfConcatImage& default_instance();

  static inline const RandomSelfConcatImage* internal_default_instance() {
    return reinterpret_cast<const RandomSelfConcatImage*>(
               &_RandomSelfConcatImage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    34;

  void Swap(RandomSelfConcatImage* other);
  friend void swap(RandomSelfConcatImage& a, RandomSelfConcatImage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RandomSelfConcatImage* New() const PROTOBUF_FINAL { return New(NULL); }

  RandomSelfConcatImage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RandomSelfConcatImage& from);
  void MergeFrom(const RandomSelfConcatImage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RandomSelfConcatImage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float concat_vertical_probability = 1 [default = 0.1];
  bool has_concat_vertical_probability() const;
  void clear_concat_vertical_probability();
  static const int kConcatVerticalProbabilityFieldNumber = 1;
  float concat_vertical_probability() const;
  void set_concat_vertical_probability(float value);

  // optional float concat_horizontal_probability = 2 [default = 0.1];
  bool has_concat_horizontal_probability() const;
  void clear_concat_horizontal_probability();
  static const int kConcatHorizontalProbabilityFieldNumber = 2;
  float concat_horizontal_probability() const;
  void set_concat_horizontal_probability(float value);

  // @@protoc_insertion_point(class_scope:object_detection.protos.RandomSelfConcatImage)
 private:
  void set_has_concat_vertical_probability();
  void clear_has_concat_vertical_probability();
  void set_has_concat_horizontal_probability();
  void clear_has_concat_horizontal_probability();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float concat_vertical_probability_;
  float concat_horizontal_probability_;
  friend struct protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AutoAugmentImage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.AutoAugmentImage) */ {
 public:
  AutoAugmentImage();
  virtual ~AutoAugmentImage();

  AutoAugmentImage(const AutoAugmentImage& from);

  inline AutoAugmentImage& operator=(const AutoAugmentImage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AutoAugmentImage(AutoAugmentImage&& from) noexcept
    : AutoAugmentImage() {
    *this = ::std::move(from);
  }

  inline AutoAugmentImage& operator=(AutoAugmentImage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AutoAugmentImage& default_instance();

  static inline const AutoAugmentImage* internal_default_instance() {
    return reinterpret_cast<const AutoAugmentImage*>(
               &_AutoAugmentImage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void Swap(AutoAugmentImage* other);
  friend void swap(AutoAugmentImage& a, AutoAugmentImage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AutoAugmentImage* New() const PROTOBUF_FINAL { return New(NULL); }

  AutoAugmentImage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AutoAugmentImage& from);
  void MergeFrom(const AutoAugmentImage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AutoAugmentImage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string policy_name = 1 [default = "v0"];
  bool has_policy_name() const;
  void clear_policy_name();
  static const int kPolicyNameFieldNumber = 1;
  const ::std::string& policy_name() const;
  void set_policy_name(const ::std::string& value);
  #if LANG_CXX11
  void set_policy_name(::std::string&& value);
  #endif
  void set_policy_name(const char* value);
  void set_policy_name(const char* value, size_t size);
  ::std::string* mutable_policy_name();
  ::std::string* release_policy_name();
  void set_allocated_policy_name(::std::string* policy_name);

  // @@protoc_insertion_point(class_scope:object_detection.protos.AutoAugmentImage)
 private:
  void set_has_policy_name();
  void clear_has_policy_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _default_policy_name_;
  ::google::protobuf::internal::ArenaStringPtr policy_name_;
  friend struct protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DropLabelProbabilistically : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.DropLabelProbabilistically) */ {
 public:
  DropLabelProbabilistically();
  virtual ~DropLabelProbabilistically();

  DropLabelProbabilistically(const DropLabelProbabilistically& from);

  inline DropLabelProbabilistically& operator=(const DropLabelProbabilistically& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DropLabelProbabilistically(DropLabelProbabilistically&& from) noexcept
    : DropLabelProbabilistically() {
    *this = ::std::move(from);
  }

  inline DropLabelProbabilistically& operator=(DropLabelProbabilistically&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DropLabelProbabilistically& default_instance();

  static inline const DropLabelProbabilistically* internal_default_instance() {
    return reinterpret_cast<const DropLabelProbabilistically*>(
               &_DropLabelProbabilistically_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    36;

  void Swap(DropLabelProbabilistically* other);
  friend void swap(DropLabelProbabilistically& a, DropLabelProbabilistically& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DropLabelProbabilistically* New() const PROTOBUF_FINAL { return New(NULL); }

  DropLabelProbabilistically* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DropLabelProbabilistically& from);
  void MergeFrom(const DropLabelProbabilistically& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DropLabelProbabilistically* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 label = 1;
  bool has_label() const;
  void clear_label();
  static const int kLabelFieldNumber = 1;
  ::google::protobuf::int32 label() const;
  void set_label(::google::protobuf::int32 value);

  // optional float drop_probability = 2 [default = 1];
  bool has_drop_probability() const;
  void clear_drop_probability();
  static const int kDropProbabilityFieldNumber = 2;
  float drop_probability() const;
  void set_drop_probability(float value);

  // @@protoc_insertion_point(class_scope:object_detection.protos.DropLabelProbabilistically)
 private:
  void set_has_label();
  void clear_has_label();
  void set_has_drop_probability();
  void clear_has_drop_probability();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 label_;
  float drop_probability_;
  friend struct protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RemapLabels : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.RemapLabels) */ {
 public:
  RemapLabels();
  virtual ~RemapLabels();

  RemapLabels(const RemapLabels& from);

  inline RemapLabels& operator=(const RemapLabels& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RemapLabels(RemapLabels&& from) noexcept
    : RemapLabels() {
    *this = ::std::move(from);
  }

  inline RemapLabels& operator=(RemapLabels&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemapLabels& default_instance();

  static inline const RemapLabels* internal_default_instance() {
    return reinterpret_cast<const RemapLabels*>(
               &_RemapLabels_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    37;

  void Swap(RemapLabels* other);
  friend void swap(RemapLabels& a, RemapLabels& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RemapLabels* New() const PROTOBUF_FINAL { return New(NULL); }

  RemapLabels* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RemapLabels& from);
  void MergeFrom(const RemapLabels& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RemapLabels* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 original_labels = 1;
  int original_labels_size() const;
  void clear_original_labels();
  static const int kOriginalLabelsFieldNumber = 1;
  ::google::protobuf::int32 original_labels(int index) const;
  void set_original_labels(int index, ::google::protobuf::int32 value);
  void add_original_labels(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      original_labels() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_original_labels();

  // optional int32 new_label = 2;
  bool has_new_label() const;
  void clear_new_label();
  static const int kNewLabelFieldNumber = 2;
  ::google::protobuf::int32 new_label() const;
  void set_new_label(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:object_detection.protos.RemapLabels)
 private:
  void set_has_new_label();
  void clear_has_new_label();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > original_labels_;
  ::google::protobuf::int32 new_label_;
  friend struct protobuf_object_5fdetection_2fprotos_2fpreprocessor_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PreprocessingStep

// optional .object_detection.protos.NormalizeImage normalize_image = 1;
inline bool PreprocessingStep::has_normalize_image() const {
  return preprocessing_step_case() == kNormalizeImage;
}
inline void PreprocessingStep::set_has_normalize_image() {
  _oneof_case_[0] = kNormalizeImage;
}
inline void PreprocessingStep::clear_normalize_image() {
  if (has_normalize_image()) {
    delete preprocessing_step_.normalize_image_;
    clear_has_preprocessing_step();
  }
}
inline  const ::object_detection::protos::NormalizeImage& PreprocessingStep::normalize_image() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.PreprocessingStep.normalize_image)
  return has_normalize_image()
      ? *preprocessing_step_.normalize_image_
      : ::object_detection::protos::NormalizeImage::default_instance();
}
inline ::object_detection::protos::NormalizeImage* PreprocessingStep::mutable_normalize_image() {
  if (!has_normalize_image()) {
    clear_preprocessing_step();
    set_has_normalize_image();
    preprocessing_step_.normalize_image_ = new ::object_detection::protos::NormalizeImage;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.PreprocessingStep.normalize_image)
  return preprocessing_step_.normalize_image_;
}
inline ::object_detection::protos::NormalizeImage* PreprocessingStep::release_normalize_image() {
  // @@protoc_insertion_point(field_release:object_detection.protos.PreprocessingStep.normalize_image)
  if (has_normalize_image()) {
    clear_has_preprocessing_step();
    ::object_detection::protos::NormalizeImage* temp = preprocessing_step_.normalize_image_;
    preprocessing_step_.normalize_image_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PreprocessingStep::set_allocated_normalize_image(::object_detection::protos::NormalizeImage* normalize_image) {
  clear_preprocessing_step();
  if (normalize_image) {
    set_has_normalize_image();
    preprocessing_step_.normalize_image_ = normalize_image;
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.PreprocessingStep.normalize_image)
}

// optional .object_detection.protos.RandomHorizontalFlip random_horizontal_flip = 2;
inline bool PreprocessingStep::has_random_horizontal_flip() const {
  return preprocessing_step_case() == kRandomHorizontalFlip;
}
inline void PreprocessingStep::set_has_random_horizontal_flip() {
  _oneof_case_[0] = kRandomHorizontalFlip;
}
inline void PreprocessingStep::clear_random_horizontal_flip() {
  if (has_random_horizontal_flip()) {
    delete preprocessing_step_.random_horizontal_flip_;
    clear_has_preprocessing_step();
  }
}
inline  const ::object_detection::protos::RandomHorizontalFlip& PreprocessingStep::random_horizontal_flip() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.PreprocessingStep.random_horizontal_flip)
  return has_random_horizontal_flip()
      ? *preprocessing_step_.random_horizontal_flip_
      : ::object_detection::protos::RandomHorizontalFlip::default_instance();
}
inline ::object_detection::protos::RandomHorizontalFlip* PreprocessingStep::mutable_random_horizontal_flip() {
  if (!has_random_horizontal_flip()) {
    clear_preprocessing_step();
    set_has_random_horizontal_flip();
    preprocessing_step_.random_horizontal_flip_ = new ::object_detection::protos::RandomHorizontalFlip;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.PreprocessingStep.random_horizontal_flip)
  return preprocessing_step_.random_horizontal_flip_;
}
inline ::object_detection::protos::RandomHorizontalFlip* PreprocessingStep::release_random_horizontal_flip() {
  // @@protoc_insertion_point(field_release:object_detection.protos.PreprocessingStep.random_horizontal_flip)
  if (has_random_horizontal_flip()) {
    clear_has_preprocessing_step();
    ::object_detection::protos::RandomHorizontalFlip* temp = preprocessing_step_.random_horizontal_flip_;
    preprocessing_step_.random_horizontal_flip_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PreprocessingStep::set_allocated_random_horizontal_flip(::object_detection::protos::RandomHorizontalFlip* random_horizontal_flip) {
  clear_preprocessing_step();
  if (random_horizontal_flip) {
    set_has_random_horizontal_flip();
    preprocessing_step_.random_horizontal_flip_ = random_horizontal_flip;
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.PreprocessingStep.random_horizontal_flip)
}

// optional .object_detection.protos.RandomPixelValueScale random_pixel_value_scale = 3;
inline bool PreprocessingStep::has_random_pixel_value_scale() const {
  return preprocessing_step_case() == kRandomPixelValueScale;
}
inline void PreprocessingStep::set_has_random_pixel_value_scale() {
  _oneof_case_[0] = kRandomPixelValueScale;
}
inline void PreprocessingStep::clear_random_pixel_value_scale() {
  if (has_random_pixel_value_scale()) {
    delete preprocessing_step_.random_pixel_value_scale_;
    clear_has_preprocessing_step();
  }
}
inline  const ::object_detection::protos::RandomPixelValueScale& PreprocessingStep::random_pixel_value_scale() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.PreprocessingStep.random_pixel_value_scale)
  return has_random_pixel_value_scale()
      ? *preprocessing_step_.random_pixel_value_scale_
      : ::object_detection::protos::RandomPixelValueScale::default_instance();
}
inline ::object_detection::protos::RandomPixelValueScale* PreprocessingStep::mutable_random_pixel_value_scale() {
  if (!has_random_pixel_value_scale()) {
    clear_preprocessing_step();
    set_has_random_pixel_value_scale();
    preprocessing_step_.random_pixel_value_scale_ = new ::object_detection::protos::RandomPixelValueScale;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.PreprocessingStep.random_pixel_value_scale)
  return preprocessing_step_.random_pixel_value_scale_;
}
inline ::object_detection::protos::RandomPixelValueScale* PreprocessingStep::release_random_pixel_value_scale() {
  // @@protoc_insertion_point(field_release:object_detection.protos.PreprocessingStep.random_pixel_value_scale)
  if (has_random_pixel_value_scale()) {
    clear_has_preprocessing_step();
    ::object_detection::protos::RandomPixelValueScale* temp = preprocessing_step_.random_pixel_value_scale_;
    preprocessing_step_.random_pixel_value_scale_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PreprocessingStep::set_allocated_random_pixel_value_scale(::object_detection::protos::RandomPixelValueScale* random_pixel_value_scale) {
  clear_preprocessing_step();
  if (random_pixel_value_scale) {
    set_has_random_pixel_value_scale();
    preprocessing_step_.random_pixel_value_scale_ = random_pixel_value_scale;
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.PreprocessingStep.random_pixel_value_scale)
}

// optional .object_detection.protos.RandomImageScale random_image_scale = 4;
inline bool PreprocessingStep::has_random_image_scale() const {
  return preprocessing_step_case() == kRandomImageScale;
}
inline void PreprocessingStep::set_has_random_image_scale() {
  _oneof_case_[0] = kRandomImageScale;
}
inline void PreprocessingStep::clear_random_image_scale() {
  if (has_random_image_scale()) {
    delete preprocessing_step_.random_image_scale_;
    clear_has_preprocessing_step();
  }
}
inline  const ::object_detection::protos::RandomImageScale& PreprocessingStep::random_image_scale() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.PreprocessingStep.random_image_scale)
  return has_random_image_scale()
      ? *preprocessing_step_.random_image_scale_
      : ::object_detection::protos::RandomImageScale::default_instance();
}
inline ::object_detection::protos::RandomImageScale* PreprocessingStep::mutable_random_image_scale() {
  if (!has_random_image_scale()) {
    clear_preprocessing_step();
    set_has_random_image_scale();
    preprocessing_step_.random_image_scale_ = new ::object_detection::protos::RandomImageScale;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.PreprocessingStep.random_image_scale)
  return preprocessing_step_.random_image_scale_;
}
inline ::object_detection::protos::RandomImageScale* PreprocessingStep::release_random_image_scale() {
  // @@protoc_insertion_point(field_release:object_detection.protos.PreprocessingStep.random_image_scale)
  if (has_random_image_scale()) {
    clear_has_preprocessing_step();
    ::object_detection::protos::RandomImageScale* temp = preprocessing_step_.random_image_scale_;
    preprocessing_step_.random_image_scale_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PreprocessingStep::set_allocated_random_image_scale(::object_detection::protos::RandomImageScale* random_image_scale) {
  clear_preprocessing_step();
  if (random_image_scale) {
    set_has_random_image_scale();
    preprocessing_step_.random_image_scale_ = random_image_scale;
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.PreprocessingStep.random_image_scale)
}

// optional .object_detection.protos.RandomRGBtoGray random_rgb_to_gray = 5;
inline bool PreprocessingStep::has_random_rgb_to_gray() const {
  return preprocessing_step_case() == kRandomRgbToGray;
}
inline void PreprocessingStep::set_has_random_rgb_to_gray() {
  _oneof_case_[0] = kRandomRgbToGray;
}
inline void PreprocessingStep::clear_random_rgb_to_gray() {
  if (has_random_rgb_to_gray()) {
    delete preprocessing_step_.random_rgb_to_gray_;
    clear_has_preprocessing_step();
  }
}
inline  const ::object_detection::protos::RandomRGBtoGray& PreprocessingStep::random_rgb_to_gray() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.PreprocessingStep.random_rgb_to_gray)
  return has_random_rgb_to_gray()
      ? *preprocessing_step_.random_rgb_to_gray_
      : ::object_detection::protos::RandomRGBtoGray::default_instance();
}
inline ::object_detection::protos::RandomRGBtoGray* PreprocessingStep::mutable_random_rgb_to_gray() {
  if (!has_random_rgb_to_gray()) {
    clear_preprocessing_step();
    set_has_random_rgb_to_gray();
    preprocessing_step_.random_rgb_to_gray_ = new ::object_detection::protos::RandomRGBtoGray;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.PreprocessingStep.random_rgb_to_gray)
  return preprocessing_step_.random_rgb_to_gray_;
}
inline ::object_detection::protos::RandomRGBtoGray* PreprocessingStep::release_random_rgb_to_gray() {
  // @@protoc_insertion_point(field_release:object_detection.protos.PreprocessingStep.random_rgb_to_gray)
  if (has_random_rgb_to_gray()) {
    clear_has_preprocessing_step();
    ::object_detection::protos::RandomRGBtoGray* temp = preprocessing_step_.random_rgb_to_gray_;
    preprocessing_step_.random_rgb_to_gray_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PreprocessingStep::set_allocated_random_rgb_to_gray(::object_detection::protos::RandomRGBtoGray* random_rgb_to_gray) {
  clear_preprocessing_step();
  if (random_rgb_to_gray) {
    set_has_random_rgb_to_gray();
    preprocessing_step_.random_rgb_to_gray_ = random_rgb_to_gray;
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.PreprocessingStep.random_rgb_to_gray)
}

// optional .object_detection.protos.RandomAdjustBrightness random_adjust_brightness = 6;
inline bool PreprocessingStep::has_random_adjust_brightness() const {
  return preprocessing_step_case() == kRandomAdjustBrightness;
}
inline void PreprocessingStep::set_has_random_adjust_brightness() {
  _oneof_case_[0] = kRandomAdjustBrightness;
}
inline void PreprocessingStep::clear_random_adjust_brightness() {
  if (has_random_adjust_brightness()) {
    delete preprocessing_step_.random_adjust_brightness_;
    clear_has_preprocessing_step();
  }
}
inline  const ::object_detection::protos::RandomAdjustBrightness& PreprocessingStep::random_adjust_brightness() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.PreprocessingStep.random_adjust_brightness)
  return has_random_adjust_brightness()
      ? *preprocessing_step_.random_adjust_brightness_
      : ::object_detection::protos::RandomAdjustBrightness::default_instance();
}
inline ::object_detection::protos::RandomAdjustBrightness* PreprocessingStep::mutable_random_adjust_brightness() {
  if (!has_random_adjust_brightness()) {
    clear_preprocessing_step();
    set_has_random_adjust_brightness();
    preprocessing_step_.random_adjust_brightness_ = new ::object_detection::protos::RandomAdjustBrightness;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.PreprocessingStep.random_adjust_brightness)
  return preprocessing_step_.random_adjust_brightness_;
}
inline ::object_detection::protos::RandomAdjustBrightness* PreprocessingStep::release_random_adjust_brightness() {
  // @@protoc_insertion_point(field_release:object_detection.protos.PreprocessingStep.random_adjust_brightness)
  if (has_random_adjust_brightness()) {
    clear_has_preprocessing_step();
    ::object_detection::protos::RandomAdjustBrightness* temp = preprocessing_step_.random_adjust_brightness_;
    preprocessing_step_.random_adjust_brightness_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PreprocessingStep::set_allocated_random_adjust_brightness(::object_detection::protos::RandomAdjustBrightness* random_adjust_brightness) {
  clear_preprocessing_step();
  if (random_adjust_brightness) {
    set_has_random_adjust_brightness();
    preprocessing_step_.random_adjust_brightness_ = random_adjust_brightness;
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.PreprocessingStep.random_adjust_brightness)
}

// optional .object_detection.protos.RandomAdjustContrast random_adjust_contrast = 7;
inline bool PreprocessingStep::has_random_adjust_contrast() const {
  return preprocessing_step_case() == kRandomAdjustContrast;
}
inline void PreprocessingStep::set_has_random_adjust_contrast() {
  _oneof_case_[0] = kRandomAdjustContrast;
}
inline void PreprocessingStep::clear_random_adjust_contrast() {
  if (has_random_adjust_contrast()) {
    delete preprocessing_step_.random_adjust_contrast_;
    clear_has_preprocessing_step();
  }
}
inline  const ::object_detection::protos::RandomAdjustContrast& PreprocessingStep::random_adjust_contrast() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.PreprocessingStep.random_adjust_contrast)
  return has_random_adjust_contrast()
      ? *preprocessing_step_.random_adjust_contrast_
      : ::object_detection::protos::RandomAdjustContrast::default_instance();
}
inline ::object_detection::protos::RandomAdjustContrast* PreprocessingStep::mutable_random_adjust_contrast() {
  if (!has_random_adjust_contrast()) {
    clear_preprocessing_step();
    set_has_random_adjust_contrast();
    preprocessing_step_.random_adjust_contrast_ = new ::object_detection::protos::RandomAdjustContrast;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.PreprocessingStep.random_adjust_contrast)
  return preprocessing_step_.random_adjust_contrast_;
}
inline ::object_detection::protos::RandomAdjustContrast* PreprocessingStep::release_random_adjust_contrast() {
  // @@protoc_insertion_point(field_release:object_detection.protos.PreprocessingStep.random_adjust_contrast)
  if (has_random_adjust_contrast()) {
    clear_has_preprocessing_step();
    ::object_detection::protos::RandomAdjustContrast* temp = preprocessing_step_.random_adjust_contrast_;
    preprocessing_step_.random_adjust_contrast_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PreprocessingStep::set_allocated_random_adjust_contrast(::object_detection::protos::RandomAdjustContrast* random_adjust_contrast) {
  clear_preprocessing_step();
  if (random_adjust_contrast) {
    set_has_random_adjust_contrast();
    preprocessing_step_.random_adjust_contrast_ = random_adjust_contrast;
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.PreprocessingStep.random_adjust_contrast)
}

// optional .object_detection.protos.RandomAdjustHue random_adjust_hue = 8;
inline bool PreprocessingStep::has_random_adjust_hue() const {
  return preprocessing_step_case() == kRandomAdjustHue;
}
inline void PreprocessingStep::set_has_random_adjust_hue() {
  _oneof_case_[0] = kRandomAdjustHue;
}
inline void PreprocessingStep::clear_random_adjust_hue() {
  if (has_random_adjust_hue()) {
    delete preprocessing_step_.random_adjust_hue_;
    clear_has_preprocessing_step();
  }
}
inline  const ::object_detection::protos::RandomAdjustHue& PreprocessingStep::random_adjust_hue() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.PreprocessingStep.random_adjust_hue)
  return has_random_adjust_hue()
      ? *preprocessing_step_.random_adjust_hue_
      : ::object_detection::protos::RandomAdjustHue::default_instance();
}
inline ::object_detection::protos::RandomAdjustHue* PreprocessingStep::mutable_random_adjust_hue() {
  if (!has_random_adjust_hue()) {
    clear_preprocessing_step();
    set_has_random_adjust_hue();
    preprocessing_step_.random_adjust_hue_ = new ::object_detection::protos::RandomAdjustHue;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.PreprocessingStep.random_adjust_hue)
  return preprocessing_step_.random_adjust_hue_;
}
inline ::object_detection::protos::RandomAdjustHue* PreprocessingStep::release_random_adjust_hue() {
  // @@protoc_insertion_point(field_release:object_detection.protos.PreprocessingStep.random_adjust_hue)
  if (has_random_adjust_hue()) {
    clear_has_preprocessing_step();
    ::object_detection::protos::RandomAdjustHue* temp = preprocessing_step_.random_adjust_hue_;
    preprocessing_step_.random_adjust_hue_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PreprocessingStep::set_allocated_random_adjust_hue(::object_detection::protos::RandomAdjustHue* random_adjust_hue) {
  clear_preprocessing_step();
  if (random_adjust_hue) {
    set_has_random_adjust_hue();
    preprocessing_step_.random_adjust_hue_ = random_adjust_hue;
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.PreprocessingStep.random_adjust_hue)
}

// optional .object_detection.protos.RandomAdjustSaturation random_adjust_saturation = 9;
inline bool PreprocessingStep::has_random_adjust_saturation() const {
  return preprocessing_step_case() == kRandomAdjustSaturation;
}
inline void PreprocessingStep::set_has_random_adjust_saturation() {
  _oneof_case_[0] = kRandomAdjustSaturation;
}
inline void PreprocessingStep::clear_random_adjust_saturation() {
  if (has_random_adjust_saturation()) {
    delete preprocessing_step_.random_adjust_saturation_;
    clear_has_preprocessing_step();
  }
}
inline  const ::object_detection::protos::RandomAdjustSaturation& PreprocessingStep::random_adjust_saturation() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.PreprocessingStep.random_adjust_saturation)
  return has_random_adjust_saturation()
      ? *preprocessing_step_.random_adjust_saturation_
      : ::object_detection::protos::RandomAdjustSaturation::default_instance();
}
inline ::object_detection::protos::RandomAdjustSaturation* PreprocessingStep::mutable_random_adjust_saturation() {
  if (!has_random_adjust_saturation()) {
    clear_preprocessing_step();
    set_has_random_adjust_saturation();
    preprocessing_step_.random_adjust_saturation_ = new ::object_detection::protos::RandomAdjustSaturation;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.PreprocessingStep.random_adjust_saturation)
  return preprocessing_step_.random_adjust_saturation_;
}
inline ::object_detection::protos::RandomAdjustSaturation* PreprocessingStep::release_random_adjust_saturation() {
  // @@protoc_insertion_point(field_release:object_detection.protos.PreprocessingStep.random_adjust_saturation)
  if (has_random_adjust_saturation()) {
    clear_has_preprocessing_step();
    ::object_detection::protos::RandomAdjustSaturation* temp = preprocessing_step_.random_adjust_saturation_;
    preprocessing_step_.random_adjust_saturation_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PreprocessingStep::set_allocated_random_adjust_saturation(::object_detection::protos::RandomAdjustSaturation* random_adjust_saturation) {
  clear_preprocessing_step();
  if (random_adjust_saturation) {
    set_has_random_adjust_saturation();
    preprocessing_step_.random_adjust_saturation_ = random_adjust_saturation;
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.PreprocessingStep.random_adjust_saturation)
}

// optional .object_detection.protos.RandomDistortColor random_distort_color = 10;
inline bool PreprocessingStep::has_random_distort_color() const {
  return preprocessing_step_case() == kRandomDistortColor;
}
inline void PreprocessingStep::set_has_random_distort_color() {
  _oneof_case_[0] = kRandomDistortColor;
}
inline void PreprocessingStep::clear_random_distort_color() {
  if (has_random_distort_color()) {
    delete preprocessing_step_.random_distort_color_;
    clear_has_preprocessing_step();
  }
}
inline  const ::object_detection::protos::RandomDistortColor& PreprocessingStep::random_distort_color() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.PreprocessingStep.random_distort_color)
  return has_random_distort_color()
      ? *preprocessing_step_.random_distort_color_
      : ::object_detection::protos::RandomDistortColor::default_instance();
}
inline ::object_detection::protos::RandomDistortColor* PreprocessingStep::mutable_random_distort_color() {
  if (!has_random_distort_color()) {
    clear_preprocessing_step();
    set_has_random_distort_color();
    preprocessing_step_.random_distort_color_ = new ::object_detection::protos::RandomDistortColor;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.PreprocessingStep.random_distort_color)
  return preprocessing_step_.random_distort_color_;
}
inline ::object_detection::protos::RandomDistortColor* PreprocessingStep::release_random_distort_color() {
  // @@protoc_insertion_point(field_release:object_detection.protos.PreprocessingStep.random_distort_color)
  if (has_random_distort_color()) {
    clear_has_preprocessing_step();
    ::object_detection::protos::RandomDistortColor* temp = preprocessing_step_.random_distort_color_;
    preprocessing_step_.random_distort_color_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PreprocessingStep::set_allocated_random_distort_color(::object_detection::protos::RandomDistortColor* random_distort_color) {
  clear_preprocessing_step();
  if (random_distort_color) {
    set_has_random_distort_color();
    preprocessing_step_.random_distort_color_ = random_distort_color;
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.PreprocessingStep.random_distort_color)
}

// optional .object_detection.protos.RandomJitterBoxes random_jitter_boxes = 11;
inline bool PreprocessingStep::has_random_jitter_boxes() const {
  return preprocessing_step_case() == kRandomJitterBoxes;
}
inline void PreprocessingStep::set_has_random_jitter_boxes() {
  _oneof_case_[0] = kRandomJitterBoxes;
}
inline void PreprocessingStep::clear_random_jitter_boxes() {
  if (has_random_jitter_boxes()) {
    delete preprocessing_step_.random_jitter_boxes_;
    clear_has_preprocessing_step();
  }
}
inline  const ::object_detection::protos::RandomJitterBoxes& PreprocessingStep::random_jitter_boxes() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.PreprocessingStep.random_jitter_boxes)
  return has_random_jitter_boxes()
      ? *preprocessing_step_.random_jitter_boxes_
      : ::object_detection::protos::RandomJitterBoxes::default_instance();
}
inline ::object_detection::protos::RandomJitterBoxes* PreprocessingStep::mutable_random_jitter_boxes() {
  if (!has_random_jitter_boxes()) {
    clear_preprocessing_step();
    set_has_random_jitter_boxes();
    preprocessing_step_.random_jitter_boxes_ = new ::object_detection::protos::RandomJitterBoxes;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.PreprocessingStep.random_jitter_boxes)
  return preprocessing_step_.random_jitter_boxes_;
}
inline ::object_detection::protos::RandomJitterBoxes* PreprocessingStep::release_random_jitter_boxes() {
  // @@protoc_insertion_point(field_release:object_detection.protos.PreprocessingStep.random_jitter_boxes)
  if (has_random_jitter_boxes()) {
    clear_has_preprocessing_step();
    ::object_detection::protos::RandomJitterBoxes* temp = preprocessing_step_.random_jitter_boxes_;
    preprocessing_step_.random_jitter_boxes_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PreprocessingStep::set_allocated_random_jitter_boxes(::object_detection::protos::RandomJitterBoxes* random_jitter_boxes) {
  clear_preprocessing_step();
  if (random_jitter_boxes) {
    set_has_random_jitter_boxes();
    preprocessing_step_.random_jitter_boxes_ = random_jitter_boxes;
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.PreprocessingStep.random_jitter_boxes)
}

// optional .object_detection.protos.RandomCropImage random_crop_image = 12;
inline bool PreprocessingStep::has_random_crop_image() const {
  return preprocessing_step_case() == kRandomCropImage;
}
inline void PreprocessingStep::set_has_random_crop_image() {
  _oneof_case_[0] = kRandomCropImage;
}
inline void PreprocessingStep::clear_random_crop_image() {
  if (has_random_crop_image()) {
    delete preprocessing_step_.random_crop_image_;
    clear_has_preprocessing_step();
  }
}
inline  const ::object_detection::protos::RandomCropImage& PreprocessingStep::random_crop_image() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.PreprocessingStep.random_crop_image)
  return has_random_crop_image()
      ? *preprocessing_step_.random_crop_image_
      : ::object_detection::protos::RandomCropImage::default_instance();
}
inline ::object_detection::protos::RandomCropImage* PreprocessingStep::mutable_random_crop_image() {
  if (!has_random_crop_image()) {
    clear_preprocessing_step();
    set_has_random_crop_image();
    preprocessing_step_.random_crop_image_ = new ::object_detection::protos::RandomCropImage;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.PreprocessingStep.random_crop_image)
  return preprocessing_step_.random_crop_image_;
}
inline ::object_detection::protos::RandomCropImage* PreprocessingStep::release_random_crop_image() {
  // @@protoc_insertion_point(field_release:object_detection.protos.PreprocessingStep.random_crop_image)
  if (has_random_crop_image()) {
    clear_has_preprocessing_step();
    ::object_detection::protos::RandomCropImage* temp = preprocessing_step_.random_crop_image_;
    preprocessing_step_.random_crop_image_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PreprocessingStep::set_allocated_random_crop_image(::object_detection::protos::RandomCropImage* random_crop_image) {
  clear_preprocessing_step();
  if (random_crop_image) {
    set_has_random_crop_image();
    preprocessing_step_.random_crop_image_ = random_crop_image;
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.PreprocessingStep.random_crop_image)
}

// optional .object_detection.protos.RandomPadImage random_pad_image = 13;
inline bool PreprocessingStep::has_random_pad_image() const {
  return preprocessing_step_case() == kRandomPadImage;
}
inline void PreprocessingStep::set_has_random_pad_image() {
  _oneof_case_[0] = kRandomPadImage;
}
inline void PreprocessingStep::clear_random_pad_image() {
  if (has_random_pad_image()) {
    delete preprocessing_step_.random_pad_image_;
    clear_has_preprocessing_step();
  }
}
inline  const ::object_detection::protos::RandomPadImage& PreprocessingStep::random_pad_image() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.PreprocessingStep.random_pad_image)
  return has_random_pad_image()
      ? *preprocessing_step_.random_pad_image_
      : ::object_detection::protos::RandomPadImage::default_instance();
}
inline ::object_detection::protos::RandomPadImage* PreprocessingStep::mutable_random_pad_image() {
  if (!has_random_pad_image()) {
    clear_preprocessing_step();
    set_has_random_pad_image();
    preprocessing_step_.random_pad_image_ = new ::object_detection::protos::RandomPadImage;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.PreprocessingStep.random_pad_image)
  return preprocessing_step_.random_pad_image_;
}
inline ::object_detection::protos::RandomPadImage* PreprocessingStep::release_random_pad_image() {
  // @@protoc_insertion_point(field_release:object_detection.protos.PreprocessingStep.random_pad_image)
  if (has_random_pad_image()) {
    clear_has_preprocessing_step();
    ::object_detection::protos::RandomPadImage* temp = preprocessing_step_.random_pad_image_;
    preprocessing_step_.random_pad_image_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PreprocessingStep::set_allocated_random_pad_image(::object_detection::protos::RandomPadImage* random_pad_image) {
  clear_preprocessing_step();
  if (random_pad_image) {
    set_has_random_pad_image();
    preprocessing_step_.random_pad_image_ = random_pad_image;
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.PreprocessingStep.random_pad_image)
}

// optional .object_detection.protos.RandomCropPadImage random_crop_pad_image = 14;
inline bool PreprocessingStep::has_random_crop_pad_image() const {
  return preprocessing_step_case() == kRandomCropPadImage;
}
inline void PreprocessingStep::set_has_random_crop_pad_image() {
  _oneof_case_[0] = kRandomCropPadImage;
}
inline void PreprocessingStep::clear_random_crop_pad_image() {
  if (has_random_crop_pad_image()) {
    delete preprocessing_step_.random_crop_pad_image_;
    clear_has_preprocessing_step();
  }
}
inline  const ::object_detection::protos::RandomCropPadImage& PreprocessingStep::random_crop_pad_image() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.PreprocessingStep.random_crop_pad_image)
  return has_random_crop_pad_image()
      ? *preprocessing_step_.random_crop_pad_image_
      : ::object_detection::protos::RandomCropPadImage::default_instance();
}
inline ::object_detection::protos::RandomCropPadImage* PreprocessingStep::mutable_random_crop_pad_image() {
  if (!has_random_crop_pad_image()) {
    clear_preprocessing_step();
    set_has_random_crop_pad_image();
    preprocessing_step_.random_crop_pad_image_ = new ::object_detection::protos::RandomCropPadImage;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.PreprocessingStep.random_crop_pad_image)
  return preprocessing_step_.random_crop_pad_image_;
}
inline ::object_detection::protos::RandomCropPadImage* PreprocessingStep::release_random_crop_pad_image() {
  // @@protoc_insertion_point(field_release:object_detection.protos.PreprocessingStep.random_crop_pad_image)
  if (has_random_crop_pad_image()) {
    clear_has_preprocessing_step();
    ::object_detection::protos::RandomCropPadImage* temp = preprocessing_step_.random_crop_pad_image_;
    preprocessing_step_.random_crop_pad_image_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PreprocessingStep::set_allocated_random_crop_pad_image(::object_detection::protos::RandomCropPadImage* random_crop_pad_image) {
  clear_preprocessing_step();
  if (random_crop_pad_image) {
    set_has_random_crop_pad_image();
    preprocessing_step_.random_crop_pad_image_ = random_crop_pad_image;
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.PreprocessingStep.random_crop_pad_image)
}

// optional .object_detection.protos.RandomCropToAspectRatio random_crop_to_aspect_ratio = 15;
inline bool PreprocessingStep::has_random_crop_to_aspect_ratio() const {
  return preprocessing_step_case() == kRandomCropToAspectRatio;
}
inline void PreprocessingStep::set_has_random_crop_to_aspect_ratio() {
  _oneof_case_[0] = kRandomCropToAspectRatio;
}
inline void PreprocessingStep::clear_random_crop_to_aspect_ratio() {
  if (has_random_crop_to_aspect_ratio()) {
    delete preprocessing_step_.random_crop_to_aspect_ratio_;
    clear_has_preprocessing_step();
  }
}
inline  const ::object_detection::protos::RandomCropToAspectRatio& PreprocessingStep::random_crop_to_aspect_ratio() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.PreprocessingStep.random_crop_to_aspect_ratio)
  return has_random_crop_to_aspect_ratio()
      ? *preprocessing_step_.random_crop_to_aspect_ratio_
      : ::object_detection::protos::RandomCropToAspectRatio::default_instance();
}
inline ::object_detection::protos::RandomCropToAspectRatio* PreprocessingStep::mutable_random_crop_to_aspect_ratio() {
  if (!has_random_crop_to_aspect_ratio()) {
    clear_preprocessing_step();
    set_has_random_crop_to_aspect_ratio();
    preprocessing_step_.random_crop_to_aspect_ratio_ = new ::object_detection::protos::RandomCropToAspectRatio;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.PreprocessingStep.random_crop_to_aspect_ratio)
  return preprocessing_step_.random_crop_to_aspect_ratio_;
}
inline ::object_detection::protos::RandomCropToAspectRatio* PreprocessingStep::release_random_crop_to_aspect_ratio() {
  // @@protoc_insertion_point(field_release:object_detection.protos.PreprocessingStep.random_crop_to_aspect_ratio)
  if (has_random_crop_to_aspect_ratio()) {
    clear_has_preprocessing_step();
    ::object_detection::protos::RandomCropToAspectRatio* temp = preprocessing_step_.random_crop_to_aspect_ratio_;
    preprocessing_step_.random_crop_to_aspect_ratio_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PreprocessingStep::set_allocated_random_crop_to_aspect_ratio(::object_detection::protos::RandomCropToAspectRatio* random_crop_to_aspect_ratio) {
  clear_preprocessing_step();
  if (random_crop_to_aspect_ratio) {
    set_has_random_crop_to_aspect_ratio();
    preprocessing_step_.random_crop_to_aspect_ratio_ = random_crop_to_aspect_ratio;
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.PreprocessingStep.random_crop_to_aspect_ratio)
}

// optional .object_detection.protos.RandomBlackPatches random_black_patches = 16;
inline bool PreprocessingStep::has_random_black_patches() const {
  return preprocessing_step_case() == kRandomBlackPatches;
}
inline void PreprocessingStep::set_has_random_black_patches() {
  _oneof_case_[0] = kRandomBlackPatches;
}
inline void PreprocessingStep::clear_random_black_patches() {
  if (has_random_black_patches()) {
    delete preprocessing_step_.random_black_patches_;
    clear_has_preprocessing_step();
  }
}
inline  const ::object_detection::protos::RandomBlackPatches& PreprocessingStep::random_black_patches() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.PreprocessingStep.random_black_patches)
  return has_random_black_patches()
      ? *preprocessing_step_.random_black_patches_
      : ::object_detection::protos::RandomBlackPatches::default_instance();
}
inline ::object_detection::protos::RandomBlackPatches* PreprocessingStep::mutable_random_black_patches() {
  if (!has_random_black_patches()) {
    clear_preprocessing_step();
    set_has_random_black_patches();
    preprocessing_step_.random_black_patches_ = new ::object_detection::protos::RandomBlackPatches;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.PreprocessingStep.random_black_patches)
  return preprocessing_step_.random_black_patches_;
}
inline ::object_detection::protos::RandomBlackPatches* PreprocessingStep::release_random_black_patches() {
  // @@protoc_insertion_point(field_release:object_detection.protos.PreprocessingStep.random_black_patches)
  if (has_random_black_patches()) {
    clear_has_preprocessing_step();
    ::object_detection::protos::RandomBlackPatches* temp = preprocessing_step_.random_black_patches_;
    preprocessing_step_.random_black_patches_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PreprocessingStep::set_allocated_random_black_patches(::object_detection::protos::RandomBlackPatches* random_black_patches) {
  clear_preprocessing_step();
  if (random_black_patches) {
    set_has_random_black_patches();
    preprocessing_step_.random_black_patches_ = random_black_patches;
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.PreprocessingStep.random_black_patches)
}

// optional .object_detection.protos.RandomResizeMethod random_resize_method = 17;
inline bool PreprocessingStep::has_random_resize_method() const {
  return preprocessing_step_case() == kRandomResizeMethod;
}
inline void PreprocessingStep::set_has_random_resize_method() {
  _oneof_case_[0] = kRandomResizeMethod;
}
inline void PreprocessingStep::clear_random_resize_method() {
  if (has_random_resize_method()) {
    delete preprocessing_step_.random_resize_method_;
    clear_has_preprocessing_step();
  }
}
inline  const ::object_detection::protos::RandomResizeMethod& PreprocessingStep::random_resize_method() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.PreprocessingStep.random_resize_method)
  return has_random_resize_method()
      ? *preprocessing_step_.random_resize_method_
      : ::object_detection::protos::RandomResizeMethod::default_instance();
}
inline ::object_detection::protos::RandomResizeMethod* PreprocessingStep::mutable_random_resize_method() {
  if (!has_random_resize_method()) {
    clear_preprocessing_step();
    set_has_random_resize_method();
    preprocessing_step_.random_resize_method_ = new ::object_detection::protos::RandomResizeMethod;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.PreprocessingStep.random_resize_method)
  return preprocessing_step_.random_resize_method_;
}
inline ::object_detection::protos::RandomResizeMethod* PreprocessingStep::release_random_resize_method() {
  // @@protoc_insertion_point(field_release:object_detection.protos.PreprocessingStep.random_resize_method)
  if (has_random_resize_method()) {
    clear_has_preprocessing_step();
    ::object_detection::protos::RandomResizeMethod* temp = preprocessing_step_.random_resize_method_;
    preprocessing_step_.random_resize_method_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PreprocessingStep::set_allocated_random_resize_method(::object_detection::protos::RandomResizeMethod* random_resize_method) {
  clear_preprocessing_step();
  if (random_resize_method) {
    set_has_random_resize_method();
    preprocessing_step_.random_resize_method_ = random_resize_method;
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.PreprocessingStep.random_resize_method)
}

// optional .object_detection.protos.ScaleBoxesToPixelCoordinates scale_boxes_to_pixel_coordinates = 18;
inline bool PreprocessingStep::has_scale_boxes_to_pixel_coordinates() const {
  return preprocessing_step_case() == kScaleBoxesToPixelCoordinates;
}
inline void PreprocessingStep::set_has_scale_boxes_to_pixel_coordinates() {
  _oneof_case_[0] = kScaleBoxesToPixelCoordinates;
}
inline void PreprocessingStep::clear_scale_boxes_to_pixel_coordinates() {
  if (has_scale_boxes_to_pixel_coordinates()) {
    delete preprocessing_step_.scale_boxes_to_pixel_coordinates_;
    clear_has_preprocessing_step();
  }
}
inline  const ::object_detection::protos::ScaleBoxesToPixelCoordinates& PreprocessingStep::scale_boxes_to_pixel_coordinates() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.PreprocessingStep.scale_boxes_to_pixel_coordinates)
  return has_scale_boxes_to_pixel_coordinates()
      ? *preprocessing_step_.scale_boxes_to_pixel_coordinates_
      : ::object_detection::protos::ScaleBoxesToPixelCoordinates::default_instance();
}
inline ::object_detection::protos::ScaleBoxesToPixelCoordinates* PreprocessingStep::mutable_scale_boxes_to_pixel_coordinates() {
  if (!has_scale_boxes_to_pixel_coordinates()) {
    clear_preprocessing_step();
    set_has_scale_boxes_to_pixel_coordinates();
    preprocessing_step_.scale_boxes_to_pixel_coordinates_ = new ::object_detection::protos::ScaleBoxesToPixelCoordinates;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.PreprocessingStep.scale_boxes_to_pixel_coordinates)
  return preprocessing_step_.scale_boxes_to_pixel_coordinates_;
}
inline ::object_detection::protos::ScaleBoxesToPixelCoordinates* PreprocessingStep::release_scale_boxes_to_pixel_coordinates() {
  // @@protoc_insertion_point(field_release:object_detection.protos.PreprocessingStep.scale_boxes_to_pixel_coordinates)
  if (has_scale_boxes_to_pixel_coordinates()) {
    clear_has_preprocessing_step();
    ::object_detection::protos::ScaleBoxesToPixelCoordinates* temp = preprocessing_step_.scale_boxes_to_pixel_coordinates_;
    preprocessing_step_.scale_boxes_to_pixel_coordinates_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PreprocessingStep::set_allocated_scale_boxes_to_pixel_coordinates(::object_detection::protos::ScaleBoxesToPixelCoordinates* scale_boxes_to_pixel_coordinates) {
  clear_preprocessing_step();
  if (scale_boxes_to_pixel_coordinates) {
    set_has_scale_boxes_to_pixel_coordinates();
    preprocessing_step_.scale_boxes_to_pixel_coordinates_ = scale_boxes_to_pixel_coordinates;
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.PreprocessingStep.scale_boxes_to_pixel_coordinates)
}

// optional .object_detection.protos.ResizeImage resize_image = 19;
inline bool PreprocessingStep::has_resize_image() const {
  return preprocessing_step_case() == kResizeImage;
}
inline void PreprocessingStep::set_has_resize_image() {
  _oneof_case_[0] = kResizeImage;
}
inline void PreprocessingStep::clear_resize_image() {
  if (has_resize_image()) {
    delete preprocessing_step_.resize_image_;
    clear_has_preprocessing_step();
  }
}
inline  const ::object_detection::protos::ResizeImage& PreprocessingStep::resize_image() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.PreprocessingStep.resize_image)
  return has_resize_image()
      ? *preprocessing_step_.resize_image_
      : ::object_detection::protos::ResizeImage::default_instance();
}
inline ::object_detection::protos::ResizeImage* PreprocessingStep::mutable_resize_image() {
  if (!has_resize_image()) {
    clear_preprocessing_step();
    set_has_resize_image();
    preprocessing_step_.resize_image_ = new ::object_detection::protos::ResizeImage;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.PreprocessingStep.resize_image)
  return preprocessing_step_.resize_image_;
}
inline ::object_detection::protos::ResizeImage* PreprocessingStep::release_resize_image() {
  // @@protoc_insertion_point(field_release:object_detection.protos.PreprocessingStep.resize_image)
  if (has_resize_image()) {
    clear_has_preprocessing_step();
    ::object_detection::protos::ResizeImage* temp = preprocessing_step_.resize_image_;
    preprocessing_step_.resize_image_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PreprocessingStep::set_allocated_resize_image(::object_detection::protos::ResizeImage* resize_image) {
  clear_preprocessing_step();
  if (resize_image) {
    set_has_resize_image();
    preprocessing_step_.resize_image_ = resize_image;
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.PreprocessingStep.resize_image)
}

// optional .object_detection.protos.SubtractChannelMean subtract_channel_mean = 20;
inline bool PreprocessingStep::has_subtract_channel_mean() const {
  return preprocessing_step_case() == kSubtractChannelMean;
}
inline void PreprocessingStep::set_has_subtract_channel_mean() {
  _oneof_case_[0] = kSubtractChannelMean;
}
inline void PreprocessingStep::clear_subtract_channel_mean() {
  if (has_subtract_channel_mean()) {
    delete preprocessing_step_.subtract_channel_mean_;
    clear_has_preprocessing_step();
  }
}
inline  const ::object_detection::protos::SubtractChannelMean& PreprocessingStep::subtract_channel_mean() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.PreprocessingStep.subtract_channel_mean)
  return has_subtract_channel_mean()
      ? *preprocessing_step_.subtract_channel_mean_
      : ::object_detection::protos::SubtractChannelMean::default_instance();
}
inline ::object_detection::protos::SubtractChannelMean* PreprocessingStep::mutable_subtract_channel_mean() {
  if (!has_subtract_channel_mean()) {
    clear_preprocessing_step();
    set_has_subtract_channel_mean();
    preprocessing_step_.subtract_channel_mean_ = new ::object_detection::protos::SubtractChannelMean;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.PreprocessingStep.subtract_channel_mean)
  return preprocessing_step_.subtract_channel_mean_;
}
inline ::object_detection::protos::SubtractChannelMean* PreprocessingStep::release_subtract_channel_mean() {
  // @@protoc_insertion_point(field_release:object_detection.protos.PreprocessingStep.subtract_channel_mean)
  if (has_subtract_channel_mean()) {
    clear_has_preprocessing_step();
    ::object_detection::protos::SubtractChannelMean* temp = preprocessing_step_.subtract_channel_mean_;
    preprocessing_step_.subtract_channel_mean_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PreprocessingStep::set_allocated_subtract_channel_mean(::object_detection::protos::SubtractChannelMean* subtract_channel_mean) {
  clear_preprocessing_step();
  if (subtract_channel_mean) {
    set_has_subtract_channel_mean();
    preprocessing_step_.subtract_channel_mean_ = subtract_channel_mean;
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.PreprocessingStep.subtract_channel_mean)
}

// optional .object_detection.protos.SSDRandomCrop ssd_random_crop = 21;
inline bool PreprocessingStep::has_ssd_random_crop() const {
  return preprocessing_step_case() == kSsdRandomCrop;
}
inline void PreprocessingStep::set_has_ssd_random_crop() {
  _oneof_case_[0] = kSsdRandomCrop;
}
inline void PreprocessingStep::clear_ssd_random_crop() {
  if (has_ssd_random_crop()) {
    delete preprocessing_step_.ssd_random_crop_;
    clear_has_preprocessing_step();
  }
}
inline  const ::object_detection::protos::SSDRandomCrop& PreprocessingStep::ssd_random_crop() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.PreprocessingStep.ssd_random_crop)
  return has_ssd_random_crop()
      ? *preprocessing_step_.ssd_random_crop_
      : ::object_detection::protos::SSDRandomCrop::default_instance();
}
inline ::object_detection::protos::SSDRandomCrop* PreprocessingStep::mutable_ssd_random_crop() {
  if (!has_ssd_random_crop()) {
    clear_preprocessing_step();
    set_has_ssd_random_crop();
    preprocessing_step_.ssd_random_crop_ = new ::object_detection::protos::SSDRandomCrop;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.PreprocessingStep.ssd_random_crop)
  return preprocessing_step_.ssd_random_crop_;
}
inline ::object_detection::protos::SSDRandomCrop* PreprocessingStep::release_ssd_random_crop() {
  // @@protoc_insertion_point(field_release:object_detection.protos.PreprocessingStep.ssd_random_crop)
  if (has_ssd_random_crop()) {
    clear_has_preprocessing_step();
    ::object_detection::protos::SSDRandomCrop* temp = preprocessing_step_.ssd_random_crop_;
    preprocessing_step_.ssd_random_crop_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PreprocessingStep::set_allocated_ssd_random_crop(::object_detection::protos::SSDRandomCrop* ssd_random_crop) {
  clear_preprocessing_step();
  if (ssd_random_crop) {
    set_has_ssd_random_crop();
    preprocessing_step_.ssd_random_crop_ = ssd_random_crop;
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.PreprocessingStep.ssd_random_crop)
}

// optional .object_detection.protos.SSDRandomCropPad ssd_random_crop_pad = 22;
inline bool PreprocessingStep::has_ssd_random_crop_pad() const {
  return preprocessing_step_case() == kSsdRandomCropPad;
}
inline void PreprocessingStep::set_has_ssd_random_crop_pad() {
  _oneof_case_[0] = kSsdRandomCropPad;
}
inline void PreprocessingStep::clear_ssd_random_crop_pad() {
  if (has_ssd_random_crop_pad()) {
    delete preprocessing_step_.ssd_random_crop_pad_;
    clear_has_preprocessing_step();
  }
}
inline  const ::object_detection::protos::SSDRandomCropPad& PreprocessingStep::ssd_random_crop_pad() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.PreprocessingStep.ssd_random_crop_pad)
  return has_ssd_random_crop_pad()
      ? *preprocessing_step_.ssd_random_crop_pad_
      : ::object_detection::protos::SSDRandomCropPad::default_instance();
}
inline ::object_detection::protos::SSDRandomCropPad* PreprocessingStep::mutable_ssd_random_crop_pad() {
  if (!has_ssd_random_crop_pad()) {
    clear_preprocessing_step();
    set_has_ssd_random_crop_pad();
    preprocessing_step_.ssd_random_crop_pad_ = new ::object_detection::protos::SSDRandomCropPad;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.PreprocessingStep.ssd_random_crop_pad)
  return preprocessing_step_.ssd_random_crop_pad_;
}
inline ::object_detection::protos::SSDRandomCropPad* PreprocessingStep::release_ssd_random_crop_pad() {
  // @@protoc_insertion_point(field_release:object_detection.protos.PreprocessingStep.ssd_random_crop_pad)
  if (has_ssd_random_crop_pad()) {
    clear_has_preprocessing_step();
    ::object_detection::protos::SSDRandomCropPad* temp = preprocessing_step_.ssd_random_crop_pad_;
    preprocessing_step_.ssd_random_crop_pad_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PreprocessingStep::set_allocated_ssd_random_crop_pad(::object_detection::protos::SSDRandomCropPad* ssd_random_crop_pad) {
  clear_preprocessing_step();
  if (ssd_random_crop_pad) {
    set_has_ssd_random_crop_pad();
    preprocessing_step_.ssd_random_crop_pad_ = ssd_random_crop_pad;
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.PreprocessingStep.ssd_random_crop_pad)
}

// optional .object_detection.protos.SSDRandomCropFixedAspectRatio ssd_random_crop_fixed_aspect_ratio = 23;
inline bool PreprocessingStep::has_ssd_random_crop_fixed_aspect_ratio() const {
  return preprocessing_step_case() == kSsdRandomCropFixedAspectRatio;
}
inline void PreprocessingStep::set_has_ssd_random_crop_fixed_aspect_ratio() {
  _oneof_case_[0] = kSsdRandomCropFixedAspectRatio;
}
inline void PreprocessingStep::clear_ssd_random_crop_fixed_aspect_ratio() {
  if (has_ssd_random_crop_fixed_aspect_ratio()) {
    delete preprocessing_step_.ssd_random_crop_fixed_aspect_ratio_;
    clear_has_preprocessing_step();
  }
}
inline  const ::object_detection::protos::SSDRandomCropFixedAspectRatio& PreprocessingStep::ssd_random_crop_fixed_aspect_ratio() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.PreprocessingStep.ssd_random_crop_fixed_aspect_ratio)
  return has_ssd_random_crop_fixed_aspect_ratio()
      ? *preprocessing_step_.ssd_random_crop_fixed_aspect_ratio_
      : ::object_detection::protos::SSDRandomCropFixedAspectRatio::default_instance();
}
inline ::object_detection::protos::SSDRandomCropFixedAspectRatio* PreprocessingStep::mutable_ssd_random_crop_fixed_aspect_ratio() {
  if (!has_ssd_random_crop_fixed_aspect_ratio()) {
    clear_preprocessing_step();
    set_has_ssd_random_crop_fixed_aspect_ratio();
    preprocessing_step_.ssd_random_crop_fixed_aspect_ratio_ = new ::object_detection::protos::SSDRandomCropFixedAspectRatio;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.PreprocessingStep.ssd_random_crop_fixed_aspect_ratio)
  return preprocessing_step_.ssd_random_crop_fixed_aspect_ratio_;
}
inline ::object_detection::protos::SSDRandomCropFixedAspectRatio* PreprocessingStep::release_ssd_random_crop_fixed_aspect_ratio() {
  // @@protoc_insertion_point(field_release:object_detection.protos.PreprocessingStep.ssd_random_crop_fixed_aspect_ratio)
  if (has_ssd_random_crop_fixed_aspect_ratio()) {
    clear_has_preprocessing_step();
    ::object_detection::protos::SSDRandomCropFixedAspectRatio* temp = preprocessing_step_.ssd_random_crop_fixed_aspect_ratio_;
    preprocessing_step_.ssd_random_crop_fixed_aspect_ratio_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PreprocessingStep::set_allocated_ssd_random_crop_fixed_aspect_ratio(::object_detection::protos::SSDRandomCropFixedAspectRatio* ssd_random_crop_fixed_aspect_ratio) {
  clear_preprocessing_step();
  if (ssd_random_crop_fixed_aspect_ratio) {
    set_has_ssd_random_crop_fixed_aspect_ratio();
    preprocessing_step_.ssd_random_crop_fixed_aspect_ratio_ = ssd_random_crop_fixed_aspect_ratio;
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.PreprocessingStep.ssd_random_crop_fixed_aspect_ratio)
}

// optional .object_detection.protos.SSDRandomCropPadFixedAspectRatio ssd_random_crop_pad_fixed_aspect_ratio = 24;
inline bool PreprocessingStep::has_ssd_random_crop_pad_fixed_aspect_ratio() const {
  return preprocessing_step_case() == kSsdRandomCropPadFixedAspectRatio;
}
inline void PreprocessingStep::set_has_ssd_random_crop_pad_fixed_aspect_ratio() {
  _oneof_case_[0] = kSsdRandomCropPadFixedAspectRatio;
}
inline void PreprocessingStep::clear_ssd_random_crop_pad_fixed_aspect_ratio() {
  if (has_ssd_random_crop_pad_fixed_aspect_ratio()) {
    delete preprocessing_step_.ssd_random_crop_pad_fixed_aspect_ratio_;
    clear_has_preprocessing_step();
  }
}
inline  const ::object_detection::protos::SSDRandomCropPadFixedAspectRatio& PreprocessingStep::ssd_random_crop_pad_fixed_aspect_ratio() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.PreprocessingStep.ssd_random_crop_pad_fixed_aspect_ratio)
  return has_ssd_random_crop_pad_fixed_aspect_ratio()
      ? *preprocessing_step_.ssd_random_crop_pad_fixed_aspect_ratio_
      : ::object_detection::protos::SSDRandomCropPadFixedAspectRatio::default_instance();
}
inline ::object_detection::protos::SSDRandomCropPadFixedAspectRatio* PreprocessingStep::mutable_ssd_random_crop_pad_fixed_aspect_ratio() {
  if (!has_ssd_random_crop_pad_fixed_aspect_ratio()) {
    clear_preprocessing_step();
    set_has_ssd_random_crop_pad_fixed_aspect_ratio();
    preprocessing_step_.ssd_random_crop_pad_fixed_aspect_ratio_ = new ::object_detection::protos::SSDRandomCropPadFixedAspectRatio;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.PreprocessingStep.ssd_random_crop_pad_fixed_aspect_ratio)
  return preprocessing_step_.ssd_random_crop_pad_fixed_aspect_ratio_;
}
inline ::object_detection::protos::SSDRandomCropPadFixedAspectRatio* PreprocessingStep::release_ssd_random_crop_pad_fixed_aspect_ratio() {
  // @@protoc_insertion_point(field_release:object_detection.protos.PreprocessingStep.ssd_random_crop_pad_fixed_aspect_ratio)
  if (has_ssd_random_crop_pad_fixed_aspect_ratio()) {
    clear_has_preprocessing_step();
    ::object_detection::protos::SSDRandomCropPadFixedAspectRatio* temp = preprocessing_step_.ssd_random_crop_pad_fixed_aspect_ratio_;
    preprocessing_step_.ssd_random_crop_pad_fixed_aspect_ratio_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PreprocessingStep::set_allocated_ssd_random_crop_pad_fixed_aspect_ratio(::object_detection::protos::SSDRandomCropPadFixedAspectRatio* ssd_random_crop_pad_fixed_aspect_ratio) {
  clear_preprocessing_step();
  if (ssd_random_crop_pad_fixed_aspect_ratio) {
    set_has_ssd_random_crop_pad_fixed_aspect_ratio();
    preprocessing_step_.ssd_random_crop_pad_fixed_aspect_ratio_ = ssd_random_crop_pad_fixed_aspect_ratio;
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.PreprocessingStep.ssd_random_crop_pad_fixed_aspect_ratio)
}

// optional .object_detection.protos.RandomVerticalFlip random_vertical_flip = 25;
inline bool PreprocessingStep::has_random_vertical_flip() const {
  return preprocessing_step_case() == kRandomVerticalFlip;
}
inline void PreprocessingStep::set_has_random_vertical_flip() {
  _oneof_case_[0] = kRandomVerticalFlip;
}
inline void PreprocessingStep::clear_random_vertical_flip() {
  if (has_random_vertical_flip()) {
    delete preprocessing_step_.random_vertical_flip_;
    clear_has_preprocessing_step();
  }
}
inline  const ::object_detection::protos::RandomVerticalFlip& PreprocessingStep::random_vertical_flip() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.PreprocessingStep.random_vertical_flip)
  return has_random_vertical_flip()
      ? *preprocessing_step_.random_vertical_flip_
      : ::object_detection::protos::RandomVerticalFlip::default_instance();
}
inline ::object_detection::protos::RandomVerticalFlip* PreprocessingStep::mutable_random_vertical_flip() {
  if (!has_random_vertical_flip()) {
    clear_preprocessing_step();
    set_has_random_vertical_flip();
    preprocessing_step_.random_vertical_flip_ = new ::object_detection::protos::RandomVerticalFlip;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.PreprocessingStep.random_vertical_flip)
  return preprocessing_step_.random_vertical_flip_;
}
inline ::object_detection::protos::RandomVerticalFlip* PreprocessingStep::release_random_vertical_flip() {
  // @@protoc_insertion_point(field_release:object_detection.protos.PreprocessingStep.random_vertical_flip)
  if (has_random_vertical_flip()) {
    clear_has_preprocessing_step();
    ::object_detection::protos::RandomVerticalFlip* temp = preprocessing_step_.random_vertical_flip_;
    preprocessing_step_.random_vertical_flip_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PreprocessingStep::set_allocated_random_vertical_flip(::object_detection::protos::RandomVerticalFlip* random_vertical_flip) {
  clear_preprocessing_step();
  if (random_vertical_flip) {
    set_has_random_vertical_flip();
    preprocessing_step_.random_vertical_flip_ = random_vertical_flip;
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.PreprocessingStep.random_vertical_flip)
}

// optional .object_detection.protos.RandomRotation90 random_rotation90 = 26;
inline bool PreprocessingStep::has_random_rotation90() const {
  return preprocessing_step_case() == kRandomRotation90;
}
inline void PreprocessingStep::set_has_random_rotation90() {
  _oneof_case_[0] = kRandomRotation90;
}
inline void PreprocessingStep::clear_random_rotation90() {
  if (has_random_rotation90()) {
    delete preprocessing_step_.random_rotation90_;
    clear_has_preprocessing_step();
  }
}
inline  const ::object_detection::protos::RandomRotation90& PreprocessingStep::random_rotation90() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.PreprocessingStep.random_rotation90)
  return has_random_rotation90()
      ? *preprocessing_step_.random_rotation90_
      : ::object_detection::protos::RandomRotation90::default_instance();
}
inline ::object_detection::protos::RandomRotation90* PreprocessingStep::mutable_random_rotation90() {
  if (!has_random_rotation90()) {
    clear_preprocessing_step();
    set_has_random_rotation90();
    preprocessing_step_.random_rotation90_ = new ::object_detection::protos::RandomRotation90;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.PreprocessingStep.random_rotation90)
  return preprocessing_step_.random_rotation90_;
}
inline ::object_detection::protos::RandomRotation90* PreprocessingStep::release_random_rotation90() {
  // @@protoc_insertion_point(field_release:object_detection.protos.PreprocessingStep.random_rotation90)
  if (has_random_rotation90()) {
    clear_has_preprocessing_step();
    ::object_detection::protos::RandomRotation90* temp = preprocessing_step_.random_rotation90_;
    preprocessing_step_.random_rotation90_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PreprocessingStep::set_allocated_random_rotation90(::object_detection::protos::RandomRotation90* random_rotation90) {
  clear_preprocessing_step();
  if (random_rotation90) {
    set_has_random_rotation90();
    preprocessing_step_.random_rotation90_ = random_rotation90;
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.PreprocessingStep.random_rotation90)
}

// optional .object_detection.protos.RGBtoGray rgb_to_gray = 27;
inline bool PreprocessingStep::has_rgb_to_gray() const {
  return preprocessing_step_case() == kRgbToGray;
}
inline void PreprocessingStep::set_has_rgb_to_gray() {
  _oneof_case_[0] = kRgbToGray;
}
inline void PreprocessingStep::clear_rgb_to_gray() {
  if (has_rgb_to_gray()) {
    delete preprocessing_step_.rgb_to_gray_;
    clear_has_preprocessing_step();
  }
}
inline  const ::object_detection::protos::RGBtoGray& PreprocessingStep::rgb_to_gray() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.PreprocessingStep.rgb_to_gray)
  return has_rgb_to_gray()
      ? *preprocessing_step_.rgb_to_gray_
      : ::object_detection::protos::RGBtoGray::default_instance();
}
inline ::object_detection::protos::RGBtoGray* PreprocessingStep::mutable_rgb_to_gray() {
  if (!has_rgb_to_gray()) {
    clear_preprocessing_step();
    set_has_rgb_to_gray();
    preprocessing_step_.rgb_to_gray_ = new ::object_detection::protos::RGBtoGray;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.PreprocessingStep.rgb_to_gray)
  return preprocessing_step_.rgb_to_gray_;
}
inline ::object_detection::protos::RGBtoGray* PreprocessingStep::release_rgb_to_gray() {
  // @@protoc_insertion_point(field_release:object_detection.protos.PreprocessingStep.rgb_to_gray)
  if (has_rgb_to_gray()) {
    clear_has_preprocessing_step();
    ::object_detection::protos::RGBtoGray* temp = preprocessing_step_.rgb_to_gray_;
    preprocessing_step_.rgb_to_gray_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PreprocessingStep::set_allocated_rgb_to_gray(::object_detection::protos::RGBtoGray* rgb_to_gray) {
  clear_preprocessing_step();
  if (rgb_to_gray) {
    set_has_rgb_to_gray();
    preprocessing_step_.rgb_to_gray_ = rgb_to_gray;
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.PreprocessingStep.rgb_to_gray)
}

// optional .object_detection.protos.ConvertClassLogitsToSoftmax convert_class_logits_to_softmax = 28;
inline bool PreprocessingStep::has_convert_class_logits_to_softmax() const {
  return preprocessing_step_case() == kConvertClassLogitsToSoftmax;
}
inline void PreprocessingStep::set_has_convert_class_logits_to_softmax() {
  _oneof_case_[0] = kConvertClassLogitsToSoftmax;
}
inline void PreprocessingStep::clear_convert_class_logits_to_softmax() {
  if (has_convert_class_logits_to_softmax()) {
    delete preprocessing_step_.convert_class_logits_to_softmax_;
    clear_has_preprocessing_step();
  }
}
inline  const ::object_detection::protos::ConvertClassLogitsToSoftmax& PreprocessingStep::convert_class_logits_to_softmax() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.PreprocessingStep.convert_class_logits_to_softmax)
  return has_convert_class_logits_to_softmax()
      ? *preprocessing_step_.convert_class_logits_to_softmax_
      : ::object_detection::protos::ConvertClassLogitsToSoftmax::default_instance();
}
inline ::object_detection::protos::ConvertClassLogitsToSoftmax* PreprocessingStep::mutable_convert_class_logits_to_softmax() {
  if (!has_convert_class_logits_to_softmax()) {
    clear_preprocessing_step();
    set_has_convert_class_logits_to_softmax();
    preprocessing_step_.convert_class_logits_to_softmax_ = new ::object_detection::protos::ConvertClassLogitsToSoftmax;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.PreprocessingStep.convert_class_logits_to_softmax)
  return preprocessing_step_.convert_class_logits_to_softmax_;
}
inline ::object_detection::protos::ConvertClassLogitsToSoftmax* PreprocessingStep::release_convert_class_logits_to_softmax() {
  // @@protoc_insertion_point(field_release:object_detection.protos.PreprocessingStep.convert_class_logits_to_softmax)
  if (has_convert_class_logits_to_softmax()) {
    clear_has_preprocessing_step();
    ::object_detection::protos::ConvertClassLogitsToSoftmax* temp = preprocessing_step_.convert_class_logits_to_softmax_;
    preprocessing_step_.convert_class_logits_to_softmax_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PreprocessingStep::set_allocated_convert_class_logits_to_softmax(::object_detection::protos::ConvertClassLogitsToSoftmax* convert_class_logits_to_softmax) {
  clear_preprocessing_step();
  if (convert_class_logits_to_softmax) {
    set_has_convert_class_logits_to_softmax();
    preprocessing_step_.convert_class_logits_to_softmax_ = convert_class_logits_to_softmax;
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.PreprocessingStep.convert_class_logits_to_softmax)
}

// optional .object_detection.protos.RandomAbsolutePadImage random_absolute_pad_image = 29;
inline bool PreprocessingStep::has_random_absolute_pad_image() const {
  return preprocessing_step_case() == kRandomAbsolutePadImage;
}
inline void PreprocessingStep::set_has_random_absolute_pad_image() {
  _oneof_case_[0] = kRandomAbsolutePadImage;
}
inline void PreprocessingStep::clear_random_absolute_pad_image() {
  if (has_random_absolute_pad_image()) {
    delete preprocessing_step_.random_absolute_pad_image_;
    clear_has_preprocessing_step();
  }
}
inline  const ::object_detection::protos::RandomAbsolutePadImage& PreprocessingStep::random_absolute_pad_image() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.PreprocessingStep.random_absolute_pad_image)
  return has_random_absolute_pad_image()
      ? *preprocessing_step_.random_absolute_pad_image_
      : ::object_detection::protos::RandomAbsolutePadImage::default_instance();
}
inline ::object_detection::protos::RandomAbsolutePadImage* PreprocessingStep::mutable_random_absolute_pad_image() {
  if (!has_random_absolute_pad_image()) {
    clear_preprocessing_step();
    set_has_random_absolute_pad_image();
    preprocessing_step_.random_absolute_pad_image_ = new ::object_detection::protos::RandomAbsolutePadImage;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.PreprocessingStep.random_absolute_pad_image)
  return preprocessing_step_.random_absolute_pad_image_;
}
inline ::object_detection::protos::RandomAbsolutePadImage* PreprocessingStep::release_random_absolute_pad_image() {
  // @@protoc_insertion_point(field_release:object_detection.protos.PreprocessingStep.random_absolute_pad_image)
  if (has_random_absolute_pad_image()) {
    clear_has_preprocessing_step();
    ::object_detection::protos::RandomAbsolutePadImage* temp = preprocessing_step_.random_absolute_pad_image_;
    preprocessing_step_.random_absolute_pad_image_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PreprocessingStep::set_allocated_random_absolute_pad_image(::object_detection::protos::RandomAbsolutePadImage* random_absolute_pad_image) {
  clear_preprocessing_step();
  if (random_absolute_pad_image) {
    set_has_random_absolute_pad_image();
    preprocessing_step_.random_absolute_pad_image_ = random_absolute_pad_image;
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.PreprocessingStep.random_absolute_pad_image)
}

// optional .object_detection.protos.RandomSelfConcatImage random_self_concat_image = 30;
inline bool PreprocessingStep::has_random_self_concat_image() const {
  return preprocessing_step_case() == kRandomSelfConcatImage;
}
inline void PreprocessingStep::set_has_random_self_concat_image() {
  _oneof_case_[0] = kRandomSelfConcatImage;
}
inline void PreprocessingStep::clear_random_self_concat_image() {
  if (has_random_self_concat_image()) {
    delete preprocessing_step_.random_self_concat_image_;
    clear_has_preprocessing_step();
  }
}
inline  const ::object_detection::protos::RandomSelfConcatImage& PreprocessingStep::random_self_concat_image() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.PreprocessingStep.random_self_concat_image)
  return has_random_self_concat_image()
      ? *preprocessing_step_.random_self_concat_image_
      : ::object_detection::protos::RandomSelfConcatImage::default_instance();
}
inline ::object_detection::protos::RandomSelfConcatImage* PreprocessingStep::mutable_random_self_concat_image() {
  if (!has_random_self_concat_image()) {
    clear_preprocessing_step();
    set_has_random_self_concat_image();
    preprocessing_step_.random_self_concat_image_ = new ::object_detection::protos::RandomSelfConcatImage;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.PreprocessingStep.random_self_concat_image)
  return preprocessing_step_.random_self_concat_image_;
}
inline ::object_detection::protos::RandomSelfConcatImage* PreprocessingStep::release_random_self_concat_image() {
  // @@protoc_insertion_point(field_release:object_detection.protos.PreprocessingStep.random_self_concat_image)
  if (has_random_self_concat_image()) {
    clear_has_preprocessing_step();
    ::object_detection::protos::RandomSelfConcatImage* temp = preprocessing_step_.random_self_concat_image_;
    preprocessing_step_.random_self_concat_image_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PreprocessingStep::set_allocated_random_self_concat_image(::object_detection::protos::RandomSelfConcatImage* random_self_concat_image) {
  clear_preprocessing_step();
  if (random_self_concat_image) {
    set_has_random_self_concat_image();
    preprocessing_step_.random_self_concat_image_ = random_self_concat_image;
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.PreprocessingStep.random_self_concat_image)
}

// optional .object_detection.protos.AutoAugmentImage autoaugment_image = 31;
inline bool PreprocessingStep::has_autoaugment_image() const {
  return preprocessing_step_case() == kAutoaugmentImage;
}
inline void PreprocessingStep::set_has_autoaugment_image() {
  _oneof_case_[0] = kAutoaugmentImage;
}
inline void PreprocessingStep::clear_autoaugment_image() {
  if (has_autoaugment_image()) {
    delete preprocessing_step_.autoaugment_image_;
    clear_has_preprocessing_step();
  }
}
inline  const ::object_detection::protos::AutoAugmentImage& PreprocessingStep::autoaugment_image() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.PreprocessingStep.autoaugment_image)
  return has_autoaugment_image()
      ? *preprocessing_step_.autoaugment_image_
      : ::object_detection::protos::AutoAugmentImage::default_instance();
}
inline ::object_detection::protos::AutoAugmentImage* PreprocessingStep::mutable_autoaugment_image() {
  if (!has_autoaugment_image()) {
    clear_preprocessing_step();
    set_has_autoaugment_image();
    preprocessing_step_.autoaugment_image_ = new ::object_detection::protos::AutoAugmentImage;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.PreprocessingStep.autoaugment_image)
  return preprocessing_step_.autoaugment_image_;
}
inline ::object_detection::protos::AutoAugmentImage* PreprocessingStep::release_autoaugment_image() {
  // @@protoc_insertion_point(field_release:object_detection.protos.PreprocessingStep.autoaugment_image)
  if (has_autoaugment_image()) {
    clear_has_preprocessing_step();
    ::object_detection::protos::AutoAugmentImage* temp = preprocessing_step_.autoaugment_image_;
    preprocessing_step_.autoaugment_image_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PreprocessingStep::set_allocated_autoaugment_image(::object_detection::protos::AutoAugmentImage* autoaugment_image) {
  clear_preprocessing_step();
  if (autoaugment_image) {
    set_has_autoaugment_image();
    preprocessing_step_.autoaugment_image_ = autoaugment_image;
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.PreprocessingStep.autoaugment_image)
}

// optional .object_detection.protos.DropLabelProbabilistically drop_label_probabilistically = 32;
inline bool PreprocessingStep::has_drop_label_probabilistically() const {
  return preprocessing_step_case() == kDropLabelProbabilistically;
}
inline void PreprocessingStep::set_has_drop_label_probabilistically() {
  _oneof_case_[0] = kDropLabelProbabilistically;
}
inline void PreprocessingStep::clear_drop_label_probabilistically() {
  if (has_drop_label_probabilistically()) {
    delete preprocessing_step_.drop_label_probabilistically_;
    clear_has_preprocessing_step();
  }
}
inline  const ::object_detection::protos::DropLabelProbabilistically& PreprocessingStep::drop_label_probabilistically() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.PreprocessingStep.drop_label_probabilistically)
  return has_drop_label_probabilistically()
      ? *preprocessing_step_.drop_label_probabilistically_
      : ::object_detection::protos::DropLabelProbabilistically::default_instance();
}
inline ::object_detection::protos::DropLabelProbabilistically* PreprocessingStep::mutable_drop_label_probabilistically() {
  if (!has_drop_label_probabilistically()) {
    clear_preprocessing_step();
    set_has_drop_label_probabilistically();
    preprocessing_step_.drop_label_probabilistically_ = new ::object_detection::protos::DropLabelProbabilistically;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.PreprocessingStep.drop_label_probabilistically)
  return preprocessing_step_.drop_label_probabilistically_;
}
inline ::object_detection::protos::DropLabelProbabilistically* PreprocessingStep::release_drop_label_probabilistically() {
  // @@protoc_insertion_point(field_release:object_detection.protos.PreprocessingStep.drop_label_probabilistically)
  if (has_drop_label_probabilistically()) {
    clear_has_preprocessing_step();
    ::object_detection::protos::DropLabelProbabilistically* temp = preprocessing_step_.drop_label_probabilistically_;
    preprocessing_step_.drop_label_probabilistically_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PreprocessingStep::set_allocated_drop_label_probabilistically(::object_detection::protos::DropLabelProbabilistically* drop_label_probabilistically) {
  clear_preprocessing_step();
  if (drop_label_probabilistically) {
    set_has_drop_label_probabilistically();
    preprocessing_step_.drop_label_probabilistically_ = drop_label_probabilistically;
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.PreprocessingStep.drop_label_probabilistically)
}

// optional .object_detection.protos.RemapLabels remap_labels = 33;
inline bool PreprocessingStep::has_remap_labels() const {
  return preprocessing_step_case() == kRemapLabels;
}
inline void PreprocessingStep::set_has_remap_labels() {
  _oneof_case_[0] = kRemapLabels;
}
inline void PreprocessingStep::clear_remap_labels() {
  if (has_remap_labels()) {
    delete preprocessing_step_.remap_labels_;
    clear_has_preprocessing_step();
  }
}
inline  const ::object_detection::protos::RemapLabels& PreprocessingStep::remap_labels() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.PreprocessingStep.remap_labels)
  return has_remap_labels()
      ? *preprocessing_step_.remap_labels_
      : ::object_detection::protos::RemapLabels::default_instance();
}
inline ::object_detection::protos::RemapLabels* PreprocessingStep::mutable_remap_labels() {
  if (!has_remap_labels()) {
    clear_preprocessing_step();
    set_has_remap_labels();
    preprocessing_step_.remap_labels_ = new ::object_detection::protos::RemapLabels;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.PreprocessingStep.remap_labels)
  return preprocessing_step_.remap_labels_;
}
inline ::object_detection::protos::RemapLabels* PreprocessingStep::release_remap_labels() {
  // @@protoc_insertion_point(field_release:object_detection.protos.PreprocessingStep.remap_labels)
  if (has_remap_labels()) {
    clear_has_preprocessing_step();
    ::object_detection::protos::RemapLabels* temp = preprocessing_step_.remap_labels_;
    preprocessing_step_.remap_labels_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PreprocessingStep::set_allocated_remap_labels(::object_detection::protos::RemapLabels* remap_labels) {
  clear_preprocessing_step();
  if (remap_labels) {
    set_has_remap_labels();
    preprocessing_step_.remap_labels_ = remap_labels;
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.PreprocessingStep.remap_labels)
}

inline bool PreprocessingStep::has_preprocessing_step() const {
  return preprocessing_step_case() != PREPROCESSING_STEP_NOT_SET;
}
inline void PreprocessingStep::clear_has_preprocessing_step() {
  _oneof_case_[0] = PREPROCESSING_STEP_NOT_SET;
}
inline PreprocessingStep::PreprocessingStepCase PreprocessingStep::preprocessing_step_case() const {
  return PreprocessingStep::PreprocessingStepCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// NormalizeImage

// optional float original_minval = 1;
inline bool NormalizeImage::has_original_minval() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NormalizeImage::set_has_original_minval() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NormalizeImage::clear_has_original_minval() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NormalizeImage::clear_original_minval() {
  original_minval_ = 0;
  clear_has_original_minval();
}
inline float NormalizeImage::original_minval() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.NormalizeImage.original_minval)
  return original_minval_;
}
inline void NormalizeImage::set_original_minval(float value) {
  set_has_original_minval();
  original_minval_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.NormalizeImage.original_minval)
}

// optional float original_maxval = 2;
inline bool NormalizeImage::has_original_maxval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NormalizeImage::set_has_original_maxval() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NormalizeImage::clear_has_original_maxval() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NormalizeImage::clear_original_maxval() {
  original_maxval_ = 0;
  clear_has_original_maxval();
}
inline float NormalizeImage::original_maxval() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.NormalizeImage.original_maxval)
  return original_maxval_;
}
inline void NormalizeImage::set_original_maxval(float value) {
  set_has_original_maxval();
  original_maxval_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.NormalizeImage.original_maxval)
}

// optional float target_minval = 3 [default = 0];
inline bool NormalizeImage::has_target_minval() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NormalizeImage::set_has_target_minval() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NormalizeImage::clear_has_target_minval() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NormalizeImage::clear_target_minval() {
  target_minval_ = 0;
  clear_has_target_minval();
}
inline float NormalizeImage::target_minval() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.NormalizeImage.target_minval)
  return target_minval_;
}
inline void NormalizeImage::set_target_minval(float value) {
  set_has_target_minval();
  target_minval_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.NormalizeImage.target_minval)
}

// optional float target_maxval = 4 [default = 1];
inline bool NormalizeImage::has_target_maxval() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NormalizeImage::set_has_target_maxval() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NormalizeImage::clear_has_target_maxval() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NormalizeImage::clear_target_maxval() {
  target_maxval_ = 1;
  clear_has_target_maxval();
}
inline float NormalizeImage::target_maxval() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.NormalizeImage.target_maxval)
  return target_maxval_;
}
inline void NormalizeImage::set_target_maxval(float value) {
  set_has_target_maxval();
  target_maxval_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.NormalizeImage.target_maxval)
}

// -------------------------------------------------------------------

// RandomHorizontalFlip

// repeated int32 keypoint_flip_permutation = 1;
inline int RandomHorizontalFlip::keypoint_flip_permutation_size() const {
  return keypoint_flip_permutation_.size();
}
inline void RandomHorizontalFlip::clear_keypoint_flip_permutation() {
  keypoint_flip_permutation_.Clear();
}
inline ::google::protobuf::int32 RandomHorizontalFlip::keypoint_flip_permutation(int index) const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomHorizontalFlip.keypoint_flip_permutation)
  return keypoint_flip_permutation_.Get(index);
}
inline void RandomHorizontalFlip::set_keypoint_flip_permutation(int index, ::google::protobuf::int32 value) {
  keypoint_flip_permutation_.Set(index, value);
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomHorizontalFlip.keypoint_flip_permutation)
}
inline void RandomHorizontalFlip::add_keypoint_flip_permutation(::google::protobuf::int32 value) {
  keypoint_flip_permutation_.Add(value);
  // @@protoc_insertion_point(field_add:object_detection.protos.RandomHorizontalFlip.keypoint_flip_permutation)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
RandomHorizontalFlip::keypoint_flip_permutation() const {
  // @@protoc_insertion_point(field_list:object_detection.protos.RandomHorizontalFlip.keypoint_flip_permutation)
  return keypoint_flip_permutation_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
RandomHorizontalFlip::mutable_keypoint_flip_permutation() {
  // @@protoc_insertion_point(field_mutable_list:object_detection.protos.RandomHorizontalFlip.keypoint_flip_permutation)
  return &keypoint_flip_permutation_;
}

// -------------------------------------------------------------------

// RandomVerticalFlip

// repeated int32 keypoint_flip_permutation = 1;
inline int RandomVerticalFlip::keypoint_flip_permutation_size() const {
  return keypoint_flip_permutation_.size();
}
inline void RandomVerticalFlip::clear_keypoint_flip_permutation() {
  keypoint_flip_permutation_.Clear();
}
inline ::google::protobuf::int32 RandomVerticalFlip::keypoint_flip_permutation(int index) const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomVerticalFlip.keypoint_flip_permutation)
  return keypoint_flip_permutation_.Get(index);
}
inline void RandomVerticalFlip::set_keypoint_flip_permutation(int index, ::google::protobuf::int32 value) {
  keypoint_flip_permutation_.Set(index, value);
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomVerticalFlip.keypoint_flip_permutation)
}
inline void RandomVerticalFlip::add_keypoint_flip_permutation(::google::protobuf::int32 value) {
  keypoint_flip_permutation_.Add(value);
  // @@protoc_insertion_point(field_add:object_detection.protos.RandomVerticalFlip.keypoint_flip_permutation)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
RandomVerticalFlip::keypoint_flip_permutation() const {
  // @@protoc_insertion_point(field_list:object_detection.protos.RandomVerticalFlip.keypoint_flip_permutation)
  return keypoint_flip_permutation_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
RandomVerticalFlip::mutable_keypoint_flip_permutation() {
  // @@protoc_insertion_point(field_mutable_list:object_detection.protos.RandomVerticalFlip.keypoint_flip_permutation)
  return &keypoint_flip_permutation_;
}

// -------------------------------------------------------------------

// RandomRotation90

// -------------------------------------------------------------------

// RandomPixelValueScale

// optional float minval = 1 [default = 0.9];
inline bool RandomPixelValueScale::has_minval() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RandomPixelValueScale::set_has_minval() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RandomPixelValueScale::clear_has_minval() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RandomPixelValueScale::clear_minval() {
  minval_ = 0.9f;
  clear_has_minval();
}
inline float RandomPixelValueScale::minval() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomPixelValueScale.minval)
  return minval_;
}
inline void RandomPixelValueScale::set_minval(float value) {
  set_has_minval();
  minval_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomPixelValueScale.minval)
}

// optional float maxval = 2 [default = 1.1];
inline bool RandomPixelValueScale::has_maxval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RandomPixelValueScale::set_has_maxval() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RandomPixelValueScale::clear_has_maxval() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RandomPixelValueScale::clear_maxval() {
  maxval_ = 1.1f;
  clear_has_maxval();
}
inline float RandomPixelValueScale::maxval() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomPixelValueScale.maxval)
  return maxval_;
}
inline void RandomPixelValueScale::set_maxval(float value) {
  set_has_maxval();
  maxval_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomPixelValueScale.maxval)
}

// -------------------------------------------------------------------

// RandomImageScale

// optional float min_scale_ratio = 1 [default = 0.5];
inline bool RandomImageScale::has_min_scale_ratio() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RandomImageScale::set_has_min_scale_ratio() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RandomImageScale::clear_has_min_scale_ratio() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RandomImageScale::clear_min_scale_ratio() {
  min_scale_ratio_ = 0.5f;
  clear_has_min_scale_ratio();
}
inline float RandomImageScale::min_scale_ratio() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomImageScale.min_scale_ratio)
  return min_scale_ratio_;
}
inline void RandomImageScale::set_min_scale_ratio(float value) {
  set_has_min_scale_ratio();
  min_scale_ratio_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomImageScale.min_scale_ratio)
}

// optional float max_scale_ratio = 2 [default = 2];
inline bool RandomImageScale::has_max_scale_ratio() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RandomImageScale::set_has_max_scale_ratio() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RandomImageScale::clear_has_max_scale_ratio() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RandomImageScale::clear_max_scale_ratio() {
  max_scale_ratio_ = 2;
  clear_has_max_scale_ratio();
}
inline float RandomImageScale::max_scale_ratio() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomImageScale.max_scale_ratio)
  return max_scale_ratio_;
}
inline void RandomImageScale::set_max_scale_ratio(float value) {
  set_has_max_scale_ratio();
  max_scale_ratio_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomImageScale.max_scale_ratio)
}

// -------------------------------------------------------------------

// RandomRGBtoGray

// optional float probability = 1 [default = 0.1];
inline bool RandomRGBtoGray::has_probability() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RandomRGBtoGray::set_has_probability() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RandomRGBtoGray::clear_has_probability() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RandomRGBtoGray::clear_probability() {
  probability_ = 0.1f;
  clear_has_probability();
}
inline float RandomRGBtoGray::probability() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomRGBtoGray.probability)
  return probability_;
}
inline void RandomRGBtoGray::set_probability(float value) {
  set_has_probability();
  probability_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomRGBtoGray.probability)
}

// -------------------------------------------------------------------

// RandomAdjustBrightness

// optional float max_delta = 1 [default = 0.2];
inline bool RandomAdjustBrightness::has_max_delta() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RandomAdjustBrightness::set_has_max_delta() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RandomAdjustBrightness::clear_has_max_delta() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RandomAdjustBrightness::clear_max_delta() {
  max_delta_ = 0.2f;
  clear_has_max_delta();
}
inline float RandomAdjustBrightness::max_delta() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomAdjustBrightness.max_delta)
  return max_delta_;
}
inline void RandomAdjustBrightness::set_max_delta(float value) {
  set_has_max_delta();
  max_delta_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomAdjustBrightness.max_delta)
}

// -------------------------------------------------------------------

// RandomAdjustContrast

// optional float min_delta = 1 [default = 0.8];
inline bool RandomAdjustContrast::has_min_delta() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RandomAdjustContrast::set_has_min_delta() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RandomAdjustContrast::clear_has_min_delta() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RandomAdjustContrast::clear_min_delta() {
  min_delta_ = 0.8f;
  clear_has_min_delta();
}
inline float RandomAdjustContrast::min_delta() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomAdjustContrast.min_delta)
  return min_delta_;
}
inline void RandomAdjustContrast::set_min_delta(float value) {
  set_has_min_delta();
  min_delta_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomAdjustContrast.min_delta)
}

// optional float max_delta = 2 [default = 1.25];
inline bool RandomAdjustContrast::has_max_delta() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RandomAdjustContrast::set_has_max_delta() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RandomAdjustContrast::clear_has_max_delta() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RandomAdjustContrast::clear_max_delta() {
  max_delta_ = 1.25f;
  clear_has_max_delta();
}
inline float RandomAdjustContrast::max_delta() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomAdjustContrast.max_delta)
  return max_delta_;
}
inline void RandomAdjustContrast::set_max_delta(float value) {
  set_has_max_delta();
  max_delta_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomAdjustContrast.max_delta)
}

// -------------------------------------------------------------------

// RandomAdjustHue

// optional float max_delta = 1 [default = 0.02];
inline bool RandomAdjustHue::has_max_delta() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RandomAdjustHue::set_has_max_delta() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RandomAdjustHue::clear_has_max_delta() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RandomAdjustHue::clear_max_delta() {
  max_delta_ = 0.02f;
  clear_has_max_delta();
}
inline float RandomAdjustHue::max_delta() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomAdjustHue.max_delta)
  return max_delta_;
}
inline void RandomAdjustHue::set_max_delta(float value) {
  set_has_max_delta();
  max_delta_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomAdjustHue.max_delta)
}

// -------------------------------------------------------------------

// RandomAdjustSaturation

// optional float min_delta = 1 [default = 0.8];
inline bool RandomAdjustSaturation::has_min_delta() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RandomAdjustSaturation::set_has_min_delta() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RandomAdjustSaturation::clear_has_min_delta() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RandomAdjustSaturation::clear_min_delta() {
  min_delta_ = 0.8f;
  clear_has_min_delta();
}
inline float RandomAdjustSaturation::min_delta() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomAdjustSaturation.min_delta)
  return min_delta_;
}
inline void RandomAdjustSaturation::set_min_delta(float value) {
  set_has_min_delta();
  min_delta_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomAdjustSaturation.min_delta)
}

// optional float max_delta = 2 [default = 1.25];
inline bool RandomAdjustSaturation::has_max_delta() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RandomAdjustSaturation::set_has_max_delta() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RandomAdjustSaturation::clear_has_max_delta() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RandomAdjustSaturation::clear_max_delta() {
  max_delta_ = 1.25f;
  clear_has_max_delta();
}
inline float RandomAdjustSaturation::max_delta() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomAdjustSaturation.max_delta)
  return max_delta_;
}
inline void RandomAdjustSaturation::set_max_delta(float value) {
  set_has_max_delta();
  max_delta_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomAdjustSaturation.max_delta)
}

// -------------------------------------------------------------------

// RandomDistortColor

// optional int32 color_ordering = 1;
inline bool RandomDistortColor::has_color_ordering() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RandomDistortColor::set_has_color_ordering() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RandomDistortColor::clear_has_color_ordering() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RandomDistortColor::clear_color_ordering() {
  color_ordering_ = 0;
  clear_has_color_ordering();
}
inline ::google::protobuf::int32 RandomDistortColor::color_ordering() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomDistortColor.color_ordering)
  return color_ordering_;
}
inline void RandomDistortColor::set_color_ordering(::google::protobuf::int32 value) {
  set_has_color_ordering();
  color_ordering_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomDistortColor.color_ordering)
}

// -------------------------------------------------------------------

// RandomJitterBoxes

// optional float ratio = 1 [default = 0.05];
inline bool RandomJitterBoxes::has_ratio() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RandomJitterBoxes::set_has_ratio() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RandomJitterBoxes::clear_has_ratio() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RandomJitterBoxes::clear_ratio() {
  ratio_ = 0.05f;
  clear_has_ratio();
}
inline float RandomJitterBoxes::ratio() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomJitterBoxes.ratio)
  return ratio_;
}
inline void RandomJitterBoxes::set_ratio(float value) {
  set_has_ratio();
  ratio_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomJitterBoxes.ratio)
}

// -------------------------------------------------------------------

// RandomCropImage

// optional float min_object_covered = 1 [default = 1];
inline bool RandomCropImage::has_min_object_covered() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RandomCropImage::set_has_min_object_covered() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RandomCropImage::clear_has_min_object_covered() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RandomCropImage::clear_min_object_covered() {
  min_object_covered_ = 1;
  clear_has_min_object_covered();
}
inline float RandomCropImage::min_object_covered() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomCropImage.min_object_covered)
  return min_object_covered_;
}
inline void RandomCropImage::set_min_object_covered(float value) {
  set_has_min_object_covered();
  min_object_covered_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomCropImage.min_object_covered)
}

// optional float min_aspect_ratio = 2 [default = 0.75];
inline bool RandomCropImage::has_min_aspect_ratio() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RandomCropImage::set_has_min_aspect_ratio() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RandomCropImage::clear_has_min_aspect_ratio() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RandomCropImage::clear_min_aspect_ratio() {
  min_aspect_ratio_ = 0.75f;
  clear_has_min_aspect_ratio();
}
inline float RandomCropImage::min_aspect_ratio() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomCropImage.min_aspect_ratio)
  return min_aspect_ratio_;
}
inline void RandomCropImage::set_min_aspect_ratio(float value) {
  set_has_min_aspect_ratio();
  min_aspect_ratio_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomCropImage.min_aspect_ratio)
}

// optional float max_aspect_ratio = 3 [default = 1.33];
inline bool RandomCropImage::has_max_aspect_ratio() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RandomCropImage::set_has_max_aspect_ratio() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RandomCropImage::clear_has_max_aspect_ratio() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RandomCropImage::clear_max_aspect_ratio() {
  max_aspect_ratio_ = 1.33f;
  clear_has_max_aspect_ratio();
}
inline float RandomCropImage::max_aspect_ratio() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomCropImage.max_aspect_ratio)
  return max_aspect_ratio_;
}
inline void RandomCropImage::set_max_aspect_ratio(float value) {
  set_has_max_aspect_ratio();
  max_aspect_ratio_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomCropImage.max_aspect_ratio)
}

// optional float min_area = 4 [default = 0.1];
inline bool RandomCropImage::has_min_area() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RandomCropImage::set_has_min_area() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RandomCropImage::clear_has_min_area() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RandomCropImage::clear_min_area() {
  min_area_ = 0.1f;
  clear_has_min_area();
}
inline float RandomCropImage::min_area() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomCropImage.min_area)
  return min_area_;
}
inline void RandomCropImage::set_min_area(float value) {
  set_has_min_area();
  min_area_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomCropImage.min_area)
}

// optional float max_area = 5 [default = 1];
inline bool RandomCropImage::has_max_area() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RandomCropImage::set_has_max_area() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RandomCropImage::clear_has_max_area() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RandomCropImage::clear_max_area() {
  max_area_ = 1;
  clear_has_max_area();
}
inline float RandomCropImage::max_area() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomCropImage.max_area)
  return max_area_;
}
inline void RandomCropImage::set_max_area(float value) {
  set_has_max_area();
  max_area_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomCropImage.max_area)
}

// optional float overlap_thresh = 6 [default = 0.3];
inline bool RandomCropImage::has_overlap_thresh() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RandomCropImage::set_has_overlap_thresh() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RandomCropImage::clear_has_overlap_thresh() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RandomCropImage::clear_overlap_thresh() {
  overlap_thresh_ = 0.3f;
  clear_has_overlap_thresh();
}
inline float RandomCropImage::overlap_thresh() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomCropImage.overlap_thresh)
  return overlap_thresh_;
}
inline void RandomCropImage::set_overlap_thresh(float value) {
  set_has_overlap_thresh();
  overlap_thresh_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomCropImage.overlap_thresh)
}

// optional bool clip_boxes = 8 [default = true];
inline bool RandomCropImage::has_clip_boxes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RandomCropImage::set_has_clip_boxes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RandomCropImage::clear_has_clip_boxes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RandomCropImage::clear_clip_boxes() {
  clip_boxes_ = true;
  clear_has_clip_boxes();
}
inline bool RandomCropImage::clip_boxes() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomCropImage.clip_boxes)
  return clip_boxes_;
}
inline void RandomCropImage::set_clip_boxes(bool value) {
  set_has_clip_boxes();
  clip_boxes_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomCropImage.clip_boxes)
}

// optional float random_coef = 7 [default = 0];
inline bool RandomCropImage::has_random_coef() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RandomCropImage::set_has_random_coef() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RandomCropImage::clear_has_random_coef() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RandomCropImage::clear_random_coef() {
  random_coef_ = 0;
  clear_has_random_coef();
}
inline float RandomCropImage::random_coef() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomCropImage.random_coef)
  return random_coef_;
}
inline void RandomCropImage::set_random_coef(float value) {
  set_has_random_coef();
  random_coef_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomCropImage.random_coef)
}

// -------------------------------------------------------------------

// RandomPadImage

// optional int32 min_image_height = 1;
inline bool RandomPadImage::has_min_image_height() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RandomPadImage::set_has_min_image_height() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RandomPadImage::clear_has_min_image_height() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RandomPadImage::clear_min_image_height() {
  min_image_height_ = 0;
  clear_has_min_image_height();
}
inline ::google::protobuf::int32 RandomPadImage::min_image_height() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomPadImage.min_image_height)
  return min_image_height_;
}
inline void RandomPadImage::set_min_image_height(::google::protobuf::int32 value) {
  set_has_min_image_height();
  min_image_height_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomPadImage.min_image_height)
}

// optional int32 min_image_width = 2;
inline bool RandomPadImage::has_min_image_width() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RandomPadImage::set_has_min_image_width() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RandomPadImage::clear_has_min_image_width() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RandomPadImage::clear_min_image_width() {
  min_image_width_ = 0;
  clear_has_min_image_width();
}
inline ::google::protobuf::int32 RandomPadImage::min_image_width() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomPadImage.min_image_width)
  return min_image_width_;
}
inline void RandomPadImage::set_min_image_width(::google::protobuf::int32 value) {
  set_has_min_image_width();
  min_image_width_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomPadImage.min_image_width)
}

// optional int32 max_image_height = 3;
inline bool RandomPadImage::has_max_image_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RandomPadImage::set_has_max_image_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RandomPadImage::clear_has_max_image_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RandomPadImage::clear_max_image_height() {
  max_image_height_ = 0;
  clear_has_max_image_height();
}
inline ::google::protobuf::int32 RandomPadImage::max_image_height() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomPadImage.max_image_height)
  return max_image_height_;
}
inline void RandomPadImage::set_max_image_height(::google::protobuf::int32 value) {
  set_has_max_image_height();
  max_image_height_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomPadImage.max_image_height)
}

// optional int32 max_image_width = 4;
inline bool RandomPadImage::has_max_image_width() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RandomPadImage::set_has_max_image_width() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RandomPadImage::clear_has_max_image_width() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RandomPadImage::clear_max_image_width() {
  max_image_width_ = 0;
  clear_has_max_image_width();
}
inline ::google::protobuf::int32 RandomPadImage::max_image_width() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomPadImage.max_image_width)
  return max_image_width_;
}
inline void RandomPadImage::set_max_image_width(::google::protobuf::int32 value) {
  set_has_max_image_width();
  max_image_width_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomPadImage.max_image_width)
}

// repeated float pad_color = 5;
inline int RandomPadImage::pad_color_size() const {
  return pad_color_.size();
}
inline void RandomPadImage::clear_pad_color() {
  pad_color_.Clear();
}
inline float RandomPadImage::pad_color(int index) const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomPadImage.pad_color)
  return pad_color_.Get(index);
}
inline void RandomPadImage::set_pad_color(int index, float value) {
  pad_color_.Set(index, value);
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomPadImage.pad_color)
}
inline void RandomPadImage::add_pad_color(float value) {
  pad_color_.Add(value);
  // @@protoc_insertion_point(field_add:object_detection.protos.RandomPadImage.pad_color)
}
inline const ::google::protobuf::RepeatedField< float >&
RandomPadImage::pad_color() const {
  // @@protoc_insertion_point(field_list:object_detection.protos.RandomPadImage.pad_color)
  return pad_color_;
}
inline ::google::protobuf::RepeatedField< float >*
RandomPadImage::mutable_pad_color() {
  // @@protoc_insertion_point(field_mutable_list:object_detection.protos.RandomPadImage.pad_color)
  return &pad_color_;
}

// -------------------------------------------------------------------

// RandomAbsolutePadImage

// optional int32 max_height_padding = 1;
inline bool RandomAbsolutePadImage::has_max_height_padding() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RandomAbsolutePadImage::set_has_max_height_padding() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RandomAbsolutePadImage::clear_has_max_height_padding() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RandomAbsolutePadImage::clear_max_height_padding() {
  max_height_padding_ = 0;
  clear_has_max_height_padding();
}
inline ::google::protobuf::int32 RandomAbsolutePadImage::max_height_padding() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomAbsolutePadImage.max_height_padding)
  return max_height_padding_;
}
inline void RandomAbsolutePadImage::set_max_height_padding(::google::protobuf::int32 value) {
  set_has_max_height_padding();
  max_height_padding_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomAbsolutePadImage.max_height_padding)
}

// optional int32 max_width_padding = 2;
inline bool RandomAbsolutePadImage::has_max_width_padding() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RandomAbsolutePadImage::set_has_max_width_padding() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RandomAbsolutePadImage::clear_has_max_width_padding() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RandomAbsolutePadImage::clear_max_width_padding() {
  max_width_padding_ = 0;
  clear_has_max_width_padding();
}
inline ::google::protobuf::int32 RandomAbsolutePadImage::max_width_padding() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomAbsolutePadImage.max_width_padding)
  return max_width_padding_;
}
inline void RandomAbsolutePadImage::set_max_width_padding(::google::protobuf::int32 value) {
  set_has_max_width_padding();
  max_width_padding_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomAbsolutePadImage.max_width_padding)
}

// repeated float pad_color = 3;
inline int RandomAbsolutePadImage::pad_color_size() const {
  return pad_color_.size();
}
inline void RandomAbsolutePadImage::clear_pad_color() {
  pad_color_.Clear();
}
inline float RandomAbsolutePadImage::pad_color(int index) const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomAbsolutePadImage.pad_color)
  return pad_color_.Get(index);
}
inline void RandomAbsolutePadImage::set_pad_color(int index, float value) {
  pad_color_.Set(index, value);
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomAbsolutePadImage.pad_color)
}
inline void RandomAbsolutePadImage::add_pad_color(float value) {
  pad_color_.Add(value);
  // @@protoc_insertion_point(field_add:object_detection.protos.RandomAbsolutePadImage.pad_color)
}
inline const ::google::protobuf::RepeatedField< float >&
RandomAbsolutePadImage::pad_color() const {
  // @@protoc_insertion_point(field_list:object_detection.protos.RandomAbsolutePadImage.pad_color)
  return pad_color_;
}
inline ::google::protobuf::RepeatedField< float >*
RandomAbsolutePadImage::mutable_pad_color() {
  // @@protoc_insertion_point(field_mutable_list:object_detection.protos.RandomAbsolutePadImage.pad_color)
  return &pad_color_;
}

// -------------------------------------------------------------------

// RandomCropPadImage

// optional float min_object_covered = 1 [default = 1];
inline bool RandomCropPadImage::has_min_object_covered() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RandomCropPadImage::set_has_min_object_covered() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RandomCropPadImage::clear_has_min_object_covered() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RandomCropPadImage::clear_min_object_covered() {
  min_object_covered_ = 1;
  clear_has_min_object_covered();
}
inline float RandomCropPadImage::min_object_covered() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomCropPadImage.min_object_covered)
  return min_object_covered_;
}
inline void RandomCropPadImage::set_min_object_covered(float value) {
  set_has_min_object_covered();
  min_object_covered_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomCropPadImage.min_object_covered)
}

// optional float min_aspect_ratio = 2 [default = 0.75];
inline bool RandomCropPadImage::has_min_aspect_ratio() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RandomCropPadImage::set_has_min_aspect_ratio() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RandomCropPadImage::clear_has_min_aspect_ratio() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RandomCropPadImage::clear_min_aspect_ratio() {
  min_aspect_ratio_ = 0.75f;
  clear_has_min_aspect_ratio();
}
inline float RandomCropPadImage::min_aspect_ratio() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomCropPadImage.min_aspect_ratio)
  return min_aspect_ratio_;
}
inline void RandomCropPadImage::set_min_aspect_ratio(float value) {
  set_has_min_aspect_ratio();
  min_aspect_ratio_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomCropPadImage.min_aspect_ratio)
}

// optional float max_aspect_ratio = 3 [default = 1.33];
inline bool RandomCropPadImage::has_max_aspect_ratio() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RandomCropPadImage::set_has_max_aspect_ratio() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RandomCropPadImage::clear_has_max_aspect_ratio() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RandomCropPadImage::clear_max_aspect_ratio() {
  max_aspect_ratio_ = 1.33f;
  clear_has_max_aspect_ratio();
}
inline float RandomCropPadImage::max_aspect_ratio() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomCropPadImage.max_aspect_ratio)
  return max_aspect_ratio_;
}
inline void RandomCropPadImage::set_max_aspect_ratio(float value) {
  set_has_max_aspect_ratio();
  max_aspect_ratio_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomCropPadImage.max_aspect_ratio)
}

// optional float min_area = 4 [default = 0.1];
inline bool RandomCropPadImage::has_min_area() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RandomCropPadImage::set_has_min_area() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RandomCropPadImage::clear_has_min_area() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RandomCropPadImage::clear_min_area() {
  min_area_ = 0.1f;
  clear_has_min_area();
}
inline float RandomCropPadImage::min_area() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomCropPadImage.min_area)
  return min_area_;
}
inline void RandomCropPadImage::set_min_area(float value) {
  set_has_min_area();
  min_area_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomCropPadImage.min_area)
}

// optional float max_area = 5 [default = 1];
inline bool RandomCropPadImage::has_max_area() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RandomCropPadImage::set_has_max_area() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RandomCropPadImage::clear_has_max_area() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RandomCropPadImage::clear_max_area() {
  max_area_ = 1;
  clear_has_max_area();
}
inline float RandomCropPadImage::max_area() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomCropPadImage.max_area)
  return max_area_;
}
inline void RandomCropPadImage::set_max_area(float value) {
  set_has_max_area();
  max_area_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomCropPadImage.max_area)
}

// optional float overlap_thresh = 6 [default = 0.3];
inline bool RandomCropPadImage::has_overlap_thresh() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RandomCropPadImage::set_has_overlap_thresh() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RandomCropPadImage::clear_has_overlap_thresh() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RandomCropPadImage::clear_overlap_thresh() {
  overlap_thresh_ = 0.3f;
  clear_has_overlap_thresh();
}
inline float RandomCropPadImage::overlap_thresh() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomCropPadImage.overlap_thresh)
  return overlap_thresh_;
}
inline void RandomCropPadImage::set_overlap_thresh(float value) {
  set_has_overlap_thresh();
  overlap_thresh_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomCropPadImage.overlap_thresh)
}

// optional bool clip_boxes = 11 [default = true];
inline bool RandomCropPadImage::has_clip_boxes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RandomCropPadImage::set_has_clip_boxes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RandomCropPadImage::clear_has_clip_boxes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RandomCropPadImage::clear_clip_boxes() {
  clip_boxes_ = true;
  clear_has_clip_boxes();
}
inline bool RandomCropPadImage::clip_boxes() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomCropPadImage.clip_boxes)
  return clip_boxes_;
}
inline void RandomCropPadImage::set_clip_boxes(bool value) {
  set_has_clip_boxes();
  clip_boxes_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomCropPadImage.clip_boxes)
}

// optional float random_coef = 7 [default = 0];
inline bool RandomCropPadImage::has_random_coef() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RandomCropPadImage::set_has_random_coef() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RandomCropPadImage::clear_has_random_coef() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RandomCropPadImage::clear_random_coef() {
  random_coef_ = 0;
  clear_has_random_coef();
}
inline float RandomCropPadImage::random_coef() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomCropPadImage.random_coef)
  return random_coef_;
}
inline void RandomCropPadImage::set_random_coef(float value) {
  set_has_random_coef();
  random_coef_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomCropPadImage.random_coef)
}

// repeated float min_padded_size_ratio = 8;
inline int RandomCropPadImage::min_padded_size_ratio_size() const {
  return min_padded_size_ratio_.size();
}
inline void RandomCropPadImage::clear_min_padded_size_ratio() {
  min_padded_size_ratio_.Clear();
}
inline float RandomCropPadImage::min_padded_size_ratio(int index) const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomCropPadImage.min_padded_size_ratio)
  return min_padded_size_ratio_.Get(index);
}
inline void RandomCropPadImage::set_min_padded_size_ratio(int index, float value) {
  min_padded_size_ratio_.Set(index, value);
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomCropPadImage.min_padded_size_ratio)
}
inline void RandomCropPadImage::add_min_padded_size_ratio(float value) {
  min_padded_size_ratio_.Add(value);
  // @@protoc_insertion_point(field_add:object_detection.protos.RandomCropPadImage.min_padded_size_ratio)
}
inline const ::google::protobuf::RepeatedField< float >&
RandomCropPadImage::min_padded_size_ratio() const {
  // @@protoc_insertion_point(field_list:object_detection.protos.RandomCropPadImage.min_padded_size_ratio)
  return min_padded_size_ratio_;
}
inline ::google::protobuf::RepeatedField< float >*
RandomCropPadImage::mutable_min_padded_size_ratio() {
  // @@protoc_insertion_point(field_mutable_list:object_detection.protos.RandomCropPadImage.min_padded_size_ratio)
  return &min_padded_size_ratio_;
}

// repeated float max_padded_size_ratio = 9;
inline int RandomCropPadImage::max_padded_size_ratio_size() const {
  return max_padded_size_ratio_.size();
}
inline void RandomCropPadImage::clear_max_padded_size_ratio() {
  max_padded_size_ratio_.Clear();
}
inline float RandomCropPadImage::max_padded_size_ratio(int index) const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomCropPadImage.max_padded_size_ratio)
  return max_padded_size_ratio_.Get(index);
}
inline void RandomCropPadImage::set_max_padded_size_ratio(int index, float value) {
  max_padded_size_ratio_.Set(index, value);
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomCropPadImage.max_padded_size_ratio)
}
inline void RandomCropPadImage::add_max_padded_size_ratio(float value) {
  max_padded_size_ratio_.Add(value);
  // @@protoc_insertion_point(field_add:object_detection.protos.RandomCropPadImage.max_padded_size_ratio)
}
inline const ::google::protobuf::RepeatedField< float >&
RandomCropPadImage::max_padded_size_ratio() const {
  // @@protoc_insertion_point(field_list:object_detection.protos.RandomCropPadImage.max_padded_size_ratio)
  return max_padded_size_ratio_;
}
inline ::google::protobuf::RepeatedField< float >*
RandomCropPadImage::mutable_max_padded_size_ratio() {
  // @@protoc_insertion_point(field_mutable_list:object_detection.protos.RandomCropPadImage.max_padded_size_ratio)
  return &max_padded_size_ratio_;
}

// repeated float pad_color = 10;
inline int RandomCropPadImage::pad_color_size() const {
  return pad_color_.size();
}
inline void RandomCropPadImage::clear_pad_color() {
  pad_color_.Clear();
}
inline float RandomCropPadImage::pad_color(int index) const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomCropPadImage.pad_color)
  return pad_color_.Get(index);
}
inline void RandomCropPadImage::set_pad_color(int index, float value) {
  pad_color_.Set(index, value);
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomCropPadImage.pad_color)
}
inline void RandomCropPadImage::add_pad_color(float value) {
  pad_color_.Add(value);
  // @@protoc_insertion_point(field_add:object_detection.protos.RandomCropPadImage.pad_color)
}
inline const ::google::protobuf::RepeatedField< float >&
RandomCropPadImage::pad_color() const {
  // @@protoc_insertion_point(field_list:object_detection.protos.RandomCropPadImage.pad_color)
  return pad_color_;
}
inline ::google::protobuf::RepeatedField< float >*
RandomCropPadImage::mutable_pad_color() {
  // @@protoc_insertion_point(field_mutable_list:object_detection.protos.RandomCropPadImage.pad_color)
  return &pad_color_;
}

// -------------------------------------------------------------------

// RandomCropToAspectRatio

// optional float aspect_ratio = 1 [default = 1];
inline bool RandomCropToAspectRatio::has_aspect_ratio() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RandomCropToAspectRatio::set_has_aspect_ratio() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RandomCropToAspectRatio::clear_has_aspect_ratio() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RandomCropToAspectRatio::clear_aspect_ratio() {
  aspect_ratio_ = 1;
  clear_has_aspect_ratio();
}
inline float RandomCropToAspectRatio::aspect_ratio() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomCropToAspectRatio.aspect_ratio)
  return aspect_ratio_;
}
inline void RandomCropToAspectRatio::set_aspect_ratio(float value) {
  set_has_aspect_ratio();
  aspect_ratio_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomCropToAspectRatio.aspect_ratio)
}

// optional float overlap_thresh = 2 [default = 0.3];
inline bool RandomCropToAspectRatio::has_overlap_thresh() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RandomCropToAspectRatio::set_has_overlap_thresh() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RandomCropToAspectRatio::clear_has_overlap_thresh() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RandomCropToAspectRatio::clear_overlap_thresh() {
  overlap_thresh_ = 0.3f;
  clear_has_overlap_thresh();
}
inline float RandomCropToAspectRatio::overlap_thresh() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomCropToAspectRatio.overlap_thresh)
  return overlap_thresh_;
}
inline void RandomCropToAspectRatio::set_overlap_thresh(float value) {
  set_has_overlap_thresh();
  overlap_thresh_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomCropToAspectRatio.overlap_thresh)
}

// optional bool clip_boxes = 3 [default = true];
inline bool RandomCropToAspectRatio::has_clip_boxes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RandomCropToAspectRatio::set_has_clip_boxes() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RandomCropToAspectRatio::clear_has_clip_boxes() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RandomCropToAspectRatio::clear_clip_boxes() {
  clip_boxes_ = true;
  clear_has_clip_boxes();
}
inline bool RandomCropToAspectRatio::clip_boxes() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomCropToAspectRatio.clip_boxes)
  return clip_boxes_;
}
inline void RandomCropToAspectRatio::set_clip_boxes(bool value) {
  set_has_clip_boxes();
  clip_boxes_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomCropToAspectRatio.clip_boxes)
}

// -------------------------------------------------------------------

// RandomBlackPatches

// optional int32 max_black_patches = 1 [default = 10];
inline bool RandomBlackPatches::has_max_black_patches() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RandomBlackPatches::set_has_max_black_patches() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RandomBlackPatches::clear_has_max_black_patches() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RandomBlackPatches::clear_max_black_patches() {
  max_black_patches_ = 10;
  clear_has_max_black_patches();
}
inline ::google::protobuf::int32 RandomBlackPatches::max_black_patches() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomBlackPatches.max_black_patches)
  return max_black_patches_;
}
inline void RandomBlackPatches::set_max_black_patches(::google::protobuf::int32 value) {
  set_has_max_black_patches();
  max_black_patches_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomBlackPatches.max_black_patches)
}

// optional float probability = 2 [default = 0.5];
inline bool RandomBlackPatches::has_probability() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RandomBlackPatches::set_has_probability() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RandomBlackPatches::clear_has_probability() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RandomBlackPatches::clear_probability() {
  probability_ = 0.5f;
  clear_has_probability();
}
inline float RandomBlackPatches::probability() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomBlackPatches.probability)
  return probability_;
}
inline void RandomBlackPatches::set_probability(float value) {
  set_has_probability();
  probability_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomBlackPatches.probability)
}

// optional float size_to_image_ratio = 3 [default = 0.1];
inline bool RandomBlackPatches::has_size_to_image_ratio() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RandomBlackPatches::set_has_size_to_image_ratio() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RandomBlackPatches::clear_has_size_to_image_ratio() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RandomBlackPatches::clear_size_to_image_ratio() {
  size_to_image_ratio_ = 0.1f;
  clear_has_size_to_image_ratio();
}
inline float RandomBlackPatches::size_to_image_ratio() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomBlackPatches.size_to_image_ratio)
  return size_to_image_ratio_;
}
inline void RandomBlackPatches::set_size_to_image_ratio(float value) {
  set_has_size_to_image_ratio();
  size_to_image_ratio_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomBlackPatches.size_to_image_ratio)
}

// -------------------------------------------------------------------

// RandomResizeMethod

// optional int32 target_height = 1;
inline bool RandomResizeMethod::has_target_height() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RandomResizeMethod::set_has_target_height() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RandomResizeMethod::clear_has_target_height() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RandomResizeMethod::clear_target_height() {
  target_height_ = 0;
  clear_has_target_height();
}
inline ::google::protobuf::int32 RandomResizeMethod::target_height() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomResizeMethod.target_height)
  return target_height_;
}
inline void RandomResizeMethod::set_target_height(::google::protobuf::int32 value) {
  set_has_target_height();
  target_height_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomResizeMethod.target_height)
}

// optional int32 target_width = 2;
inline bool RandomResizeMethod::has_target_width() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RandomResizeMethod::set_has_target_width() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RandomResizeMethod::clear_has_target_width() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RandomResizeMethod::clear_target_width() {
  target_width_ = 0;
  clear_has_target_width();
}
inline ::google::protobuf::int32 RandomResizeMethod::target_width() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomResizeMethod.target_width)
  return target_width_;
}
inline void RandomResizeMethod::set_target_width(::google::protobuf::int32 value) {
  set_has_target_width();
  target_width_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomResizeMethod.target_width)
}

// -------------------------------------------------------------------

// RGBtoGray

// -------------------------------------------------------------------

// ScaleBoxesToPixelCoordinates

// -------------------------------------------------------------------

// ResizeImage

// optional int32 new_height = 1;
inline bool ResizeImage::has_new_height() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResizeImage::set_has_new_height() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResizeImage::clear_has_new_height() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResizeImage::clear_new_height() {
  new_height_ = 0;
  clear_has_new_height();
}
inline ::google::protobuf::int32 ResizeImage::new_height() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.ResizeImage.new_height)
  return new_height_;
}
inline void ResizeImage::set_new_height(::google::protobuf::int32 value) {
  set_has_new_height();
  new_height_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.ResizeImage.new_height)
}

// optional int32 new_width = 2;
inline bool ResizeImage::has_new_width() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResizeImage::set_has_new_width() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResizeImage::clear_has_new_width() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResizeImage::clear_new_width() {
  new_width_ = 0;
  clear_has_new_width();
}
inline ::google::protobuf::int32 ResizeImage::new_width() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.ResizeImage.new_width)
  return new_width_;
}
inline void ResizeImage::set_new_width(::google::protobuf::int32 value) {
  set_has_new_width();
  new_width_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.ResizeImage.new_width)
}

// optional .object_detection.protos.ResizeImage.Method method = 3 [default = BILINEAR];
inline bool ResizeImage::has_method() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResizeImage::set_has_method() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResizeImage::clear_has_method() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResizeImage::clear_method() {
  method_ = 3;
  clear_has_method();
}
inline ::object_detection::protos::ResizeImage_Method ResizeImage::method() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.ResizeImage.method)
  return static_cast< ::object_detection::protos::ResizeImage_Method >(method_);
}
inline void ResizeImage::set_method(::object_detection::protos::ResizeImage_Method value) {
  assert(::object_detection::protos::ResizeImage_Method_IsValid(value));
  set_has_method();
  method_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.ResizeImage.method)
}

// -------------------------------------------------------------------

// SubtractChannelMean

// repeated float means = 1;
inline int SubtractChannelMean::means_size() const {
  return means_.size();
}
inline void SubtractChannelMean::clear_means() {
  means_.Clear();
}
inline float SubtractChannelMean::means(int index) const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SubtractChannelMean.means)
  return means_.Get(index);
}
inline void SubtractChannelMean::set_means(int index, float value) {
  means_.Set(index, value);
  // @@protoc_insertion_point(field_set:object_detection.protos.SubtractChannelMean.means)
}
inline void SubtractChannelMean::add_means(float value) {
  means_.Add(value);
  // @@protoc_insertion_point(field_add:object_detection.protos.SubtractChannelMean.means)
}
inline const ::google::protobuf::RepeatedField< float >&
SubtractChannelMean::means() const {
  // @@protoc_insertion_point(field_list:object_detection.protos.SubtractChannelMean.means)
  return means_;
}
inline ::google::protobuf::RepeatedField< float >*
SubtractChannelMean::mutable_means() {
  // @@protoc_insertion_point(field_mutable_list:object_detection.protos.SubtractChannelMean.means)
  return &means_;
}

// -------------------------------------------------------------------

// SSDRandomCropOperation

// optional float min_object_covered = 1;
inline bool SSDRandomCropOperation::has_min_object_covered() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SSDRandomCropOperation::set_has_min_object_covered() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SSDRandomCropOperation::clear_has_min_object_covered() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SSDRandomCropOperation::clear_min_object_covered() {
  min_object_covered_ = 0;
  clear_has_min_object_covered();
}
inline float SSDRandomCropOperation::min_object_covered() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropOperation.min_object_covered)
  return min_object_covered_;
}
inline void SSDRandomCropOperation::set_min_object_covered(float value) {
  set_has_min_object_covered();
  min_object_covered_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropOperation.min_object_covered)
}

// optional float min_aspect_ratio = 2;
inline bool SSDRandomCropOperation::has_min_aspect_ratio() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SSDRandomCropOperation::set_has_min_aspect_ratio() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SSDRandomCropOperation::clear_has_min_aspect_ratio() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SSDRandomCropOperation::clear_min_aspect_ratio() {
  min_aspect_ratio_ = 0;
  clear_has_min_aspect_ratio();
}
inline float SSDRandomCropOperation::min_aspect_ratio() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropOperation.min_aspect_ratio)
  return min_aspect_ratio_;
}
inline void SSDRandomCropOperation::set_min_aspect_ratio(float value) {
  set_has_min_aspect_ratio();
  min_aspect_ratio_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropOperation.min_aspect_ratio)
}

// optional float max_aspect_ratio = 3;
inline bool SSDRandomCropOperation::has_max_aspect_ratio() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SSDRandomCropOperation::set_has_max_aspect_ratio() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SSDRandomCropOperation::clear_has_max_aspect_ratio() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SSDRandomCropOperation::clear_max_aspect_ratio() {
  max_aspect_ratio_ = 0;
  clear_has_max_aspect_ratio();
}
inline float SSDRandomCropOperation::max_aspect_ratio() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropOperation.max_aspect_ratio)
  return max_aspect_ratio_;
}
inline void SSDRandomCropOperation::set_max_aspect_ratio(float value) {
  set_has_max_aspect_ratio();
  max_aspect_ratio_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropOperation.max_aspect_ratio)
}

// optional float min_area = 4;
inline bool SSDRandomCropOperation::has_min_area() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SSDRandomCropOperation::set_has_min_area() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SSDRandomCropOperation::clear_has_min_area() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SSDRandomCropOperation::clear_min_area() {
  min_area_ = 0;
  clear_has_min_area();
}
inline float SSDRandomCropOperation::min_area() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropOperation.min_area)
  return min_area_;
}
inline void SSDRandomCropOperation::set_min_area(float value) {
  set_has_min_area();
  min_area_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropOperation.min_area)
}

// optional float max_area = 5;
inline bool SSDRandomCropOperation::has_max_area() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SSDRandomCropOperation::set_has_max_area() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SSDRandomCropOperation::clear_has_max_area() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SSDRandomCropOperation::clear_max_area() {
  max_area_ = 0;
  clear_has_max_area();
}
inline float SSDRandomCropOperation::max_area() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropOperation.max_area)
  return max_area_;
}
inline void SSDRandomCropOperation::set_max_area(float value) {
  set_has_max_area();
  max_area_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropOperation.max_area)
}

// optional float overlap_thresh = 6;
inline bool SSDRandomCropOperation::has_overlap_thresh() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SSDRandomCropOperation::set_has_overlap_thresh() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SSDRandomCropOperation::clear_has_overlap_thresh() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SSDRandomCropOperation::clear_overlap_thresh() {
  overlap_thresh_ = 0;
  clear_has_overlap_thresh();
}
inline float SSDRandomCropOperation::overlap_thresh() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropOperation.overlap_thresh)
  return overlap_thresh_;
}
inline void SSDRandomCropOperation::set_overlap_thresh(float value) {
  set_has_overlap_thresh();
  overlap_thresh_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropOperation.overlap_thresh)
}

// optional bool clip_boxes = 8 [default = true];
inline bool SSDRandomCropOperation::has_clip_boxes() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SSDRandomCropOperation::set_has_clip_boxes() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SSDRandomCropOperation::clear_has_clip_boxes() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SSDRandomCropOperation::clear_clip_boxes() {
  clip_boxes_ = true;
  clear_has_clip_boxes();
}
inline bool SSDRandomCropOperation::clip_boxes() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropOperation.clip_boxes)
  return clip_boxes_;
}
inline void SSDRandomCropOperation::set_clip_boxes(bool value) {
  set_has_clip_boxes();
  clip_boxes_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropOperation.clip_boxes)
}

// optional float random_coef = 7;
inline bool SSDRandomCropOperation::has_random_coef() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SSDRandomCropOperation::set_has_random_coef() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SSDRandomCropOperation::clear_has_random_coef() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SSDRandomCropOperation::clear_random_coef() {
  random_coef_ = 0;
  clear_has_random_coef();
}
inline float SSDRandomCropOperation::random_coef() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropOperation.random_coef)
  return random_coef_;
}
inline void SSDRandomCropOperation::set_random_coef(float value) {
  set_has_random_coef();
  random_coef_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropOperation.random_coef)
}

// -------------------------------------------------------------------

// SSDRandomCrop

// repeated .object_detection.protos.SSDRandomCropOperation operations = 1;
inline int SSDRandomCrop::operations_size() const {
  return operations_.size();
}
inline void SSDRandomCrop::clear_operations() {
  operations_.Clear();
}
inline const ::object_detection::protos::SSDRandomCropOperation& SSDRandomCrop::operations(int index) const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCrop.operations)
  return operations_.Get(index);
}
inline ::object_detection::protos::SSDRandomCropOperation* SSDRandomCrop::mutable_operations(int index) {
  // @@protoc_insertion_point(field_mutable:object_detection.protos.SSDRandomCrop.operations)
  return operations_.Mutable(index);
}
inline ::object_detection::protos::SSDRandomCropOperation* SSDRandomCrop::add_operations() {
  // @@protoc_insertion_point(field_add:object_detection.protos.SSDRandomCrop.operations)
  return operations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::object_detection::protos::SSDRandomCropOperation >*
SSDRandomCrop::mutable_operations() {
  // @@protoc_insertion_point(field_mutable_list:object_detection.protos.SSDRandomCrop.operations)
  return &operations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::object_detection::protos::SSDRandomCropOperation >&
SSDRandomCrop::operations() const {
  // @@protoc_insertion_point(field_list:object_detection.protos.SSDRandomCrop.operations)
  return operations_;
}

// -------------------------------------------------------------------

// SSDRandomCropPadOperation

// optional float min_object_covered = 1;
inline bool SSDRandomCropPadOperation::has_min_object_covered() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SSDRandomCropPadOperation::set_has_min_object_covered() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SSDRandomCropPadOperation::clear_has_min_object_covered() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SSDRandomCropPadOperation::clear_min_object_covered() {
  min_object_covered_ = 0;
  clear_has_min_object_covered();
}
inline float SSDRandomCropPadOperation::min_object_covered() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropPadOperation.min_object_covered)
  return min_object_covered_;
}
inline void SSDRandomCropPadOperation::set_min_object_covered(float value) {
  set_has_min_object_covered();
  min_object_covered_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropPadOperation.min_object_covered)
}

// optional float min_aspect_ratio = 2;
inline bool SSDRandomCropPadOperation::has_min_aspect_ratio() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SSDRandomCropPadOperation::set_has_min_aspect_ratio() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SSDRandomCropPadOperation::clear_has_min_aspect_ratio() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SSDRandomCropPadOperation::clear_min_aspect_ratio() {
  min_aspect_ratio_ = 0;
  clear_has_min_aspect_ratio();
}
inline float SSDRandomCropPadOperation::min_aspect_ratio() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropPadOperation.min_aspect_ratio)
  return min_aspect_ratio_;
}
inline void SSDRandomCropPadOperation::set_min_aspect_ratio(float value) {
  set_has_min_aspect_ratio();
  min_aspect_ratio_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropPadOperation.min_aspect_ratio)
}

// optional float max_aspect_ratio = 3;
inline bool SSDRandomCropPadOperation::has_max_aspect_ratio() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SSDRandomCropPadOperation::set_has_max_aspect_ratio() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SSDRandomCropPadOperation::clear_has_max_aspect_ratio() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SSDRandomCropPadOperation::clear_max_aspect_ratio() {
  max_aspect_ratio_ = 0;
  clear_has_max_aspect_ratio();
}
inline float SSDRandomCropPadOperation::max_aspect_ratio() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropPadOperation.max_aspect_ratio)
  return max_aspect_ratio_;
}
inline void SSDRandomCropPadOperation::set_max_aspect_ratio(float value) {
  set_has_max_aspect_ratio();
  max_aspect_ratio_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropPadOperation.max_aspect_ratio)
}

// optional float min_area = 4;
inline bool SSDRandomCropPadOperation::has_min_area() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SSDRandomCropPadOperation::set_has_min_area() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SSDRandomCropPadOperation::clear_has_min_area() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SSDRandomCropPadOperation::clear_min_area() {
  min_area_ = 0;
  clear_has_min_area();
}
inline float SSDRandomCropPadOperation::min_area() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropPadOperation.min_area)
  return min_area_;
}
inline void SSDRandomCropPadOperation::set_min_area(float value) {
  set_has_min_area();
  min_area_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropPadOperation.min_area)
}

// optional float max_area = 5;
inline bool SSDRandomCropPadOperation::has_max_area() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SSDRandomCropPadOperation::set_has_max_area() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SSDRandomCropPadOperation::clear_has_max_area() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SSDRandomCropPadOperation::clear_max_area() {
  max_area_ = 0;
  clear_has_max_area();
}
inline float SSDRandomCropPadOperation::max_area() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropPadOperation.max_area)
  return max_area_;
}
inline void SSDRandomCropPadOperation::set_max_area(float value) {
  set_has_max_area();
  max_area_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropPadOperation.max_area)
}

// optional float overlap_thresh = 6;
inline bool SSDRandomCropPadOperation::has_overlap_thresh() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SSDRandomCropPadOperation::set_has_overlap_thresh() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SSDRandomCropPadOperation::clear_has_overlap_thresh() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SSDRandomCropPadOperation::clear_overlap_thresh() {
  overlap_thresh_ = 0;
  clear_has_overlap_thresh();
}
inline float SSDRandomCropPadOperation::overlap_thresh() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropPadOperation.overlap_thresh)
  return overlap_thresh_;
}
inline void SSDRandomCropPadOperation::set_overlap_thresh(float value) {
  set_has_overlap_thresh();
  overlap_thresh_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropPadOperation.overlap_thresh)
}

// optional bool clip_boxes = 13 [default = true];
inline bool SSDRandomCropPadOperation::has_clip_boxes() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SSDRandomCropPadOperation::set_has_clip_boxes() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SSDRandomCropPadOperation::clear_has_clip_boxes() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SSDRandomCropPadOperation::clear_clip_boxes() {
  clip_boxes_ = true;
  clear_has_clip_boxes();
}
inline bool SSDRandomCropPadOperation::clip_boxes() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropPadOperation.clip_boxes)
  return clip_boxes_;
}
inline void SSDRandomCropPadOperation::set_clip_boxes(bool value) {
  set_has_clip_boxes();
  clip_boxes_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropPadOperation.clip_boxes)
}

// optional float random_coef = 7;
inline bool SSDRandomCropPadOperation::has_random_coef() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SSDRandomCropPadOperation::set_has_random_coef() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SSDRandomCropPadOperation::clear_has_random_coef() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SSDRandomCropPadOperation::clear_random_coef() {
  random_coef_ = 0;
  clear_has_random_coef();
}
inline float SSDRandomCropPadOperation::random_coef() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropPadOperation.random_coef)
  return random_coef_;
}
inline void SSDRandomCropPadOperation::set_random_coef(float value) {
  set_has_random_coef();
  random_coef_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropPadOperation.random_coef)
}

// repeated float min_padded_size_ratio = 8;
inline int SSDRandomCropPadOperation::min_padded_size_ratio_size() const {
  return min_padded_size_ratio_.size();
}
inline void SSDRandomCropPadOperation::clear_min_padded_size_ratio() {
  min_padded_size_ratio_.Clear();
}
inline float SSDRandomCropPadOperation::min_padded_size_ratio(int index) const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropPadOperation.min_padded_size_ratio)
  return min_padded_size_ratio_.Get(index);
}
inline void SSDRandomCropPadOperation::set_min_padded_size_ratio(int index, float value) {
  min_padded_size_ratio_.Set(index, value);
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropPadOperation.min_padded_size_ratio)
}
inline void SSDRandomCropPadOperation::add_min_padded_size_ratio(float value) {
  min_padded_size_ratio_.Add(value);
  // @@protoc_insertion_point(field_add:object_detection.protos.SSDRandomCropPadOperation.min_padded_size_ratio)
}
inline const ::google::protobuf::RepeatedField< float >&
SSDRandomCropPadOperation::min_padded_size_ratio() const {
  // @@protoc_insertion_point(field_list:object_detection.protos.SSDRandomCropPadOperation.min_padded_size_ratio)
  return min_padded_size_ratio_;
}
inline ::google::protobuf::RepeatedField< float >*
SSDRandomCropPadOperation::mutable_min_padded_size_ratio() {
  // @@protoc_insertion_point(field_mutable_list:object_detection.protos.SSDRandomCropPadOperation.min_padded_size_ratio)
  return &min_padded_size_ratio_;
}

// repeated float max_padded_size_ratio = 9;
inline int SSDRandomCropPadOperation::max_padded_size_ratio_size() const {
  return max_padded_size_ratio_.size();
}
inline void SSDRandomCropPadOperation::clear_max_padded_size_ratio() {
  max_padded_size_ratio_.Clear();
}
inline float SSDRandomCropPadOperation::max_padded_size_ratio(int index) const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropPadOperation.max_padded_size_ratio)
  return max_padded_size_ratio_.Get(index);
}
inline void SSDRandomCropPadOperation::set_max_padded_size_ratio(int index, float value) {
  max_padded_size_ratio_.Set(index, value);
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropPadOperation.max_padded_size_ratio)
}
inline void SSDRandomCropPadOperation::add_max_padded_size_ratio(float value) {
  max_padded_size_ratio_.Add(value);
  // @@protoc_insertion_point(field_add:object_detection.protos.SSDRandomCropPadOperation.max_padded_size_ratio)
}
inline const ::google::protobuf::RepeatedField< float >&
SSDRandomCropPadOperation::max_padded_size_ratio() const {
  // @@protoc_insertion_point(field_list:object_detection.protos.SSDRandomCropPadOperation.max_padded_size_ratio)
  return max_padded_size_ratio_;
}
inline ::google::protobuf::RepeatedField< float >*
SSDRandomCropPadOperation::mutable_max_padded_size_ratio() {
  // @@protoc_insertion_point(field_mutable_list:object_detection.protos.SSDRandomCropPadOperation.max_padded_size_ratio)
  return &max_padded_size_ratio_;
}

// optional float pad_color_r = 10;
inline bool SSDRandomCropPadOperation::has_pad_color_r() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SSDRandomCropPadOperation::set_has_pad_color_r() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SSDRandomCropPadOperation::clear_has_pad_color_r() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SSDRandomCropPadOperation::clear_pad_color_r() {
  pad_color_r_ = 0;
  clear_has_pad_color_r();
}
inline float SSDRandomCropPadOperation::pad_color_r() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropPadOperation.pad_color_r)
  return pad_color_r_;
}
inline void SSDRandomCropPadOperation::set_pad_color_r(float value) {
  set_has_pad_color_r();
  pad_color_r_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropPadOperation.pad_color_r)
}

// optional float pad_color_g = 11;
inline bool SSDRandomCropPadOperation::has_pad_color_g() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SSDRandomCropPadOperation::set_has_pad_color_g() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SSDRandomCropPadOperation::clear_has_pad_color_g() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SSDRandomCropPadOperation::clear_pad_color_g() {
  pad_color_g_ = 0;
  clear_has_pad_color_g();
}
inline float SSDRandomCropPadOperation::pad_color_g() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropPadOperation.pad_color_g)
  return pad_color_g_;
}
inline void SSDRandomCropPadOperation::set_pad_color_g(float value) {
  set_has_pad_color_g();
  pad_color_g_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropPadOperation.pad_color_g)
}

// optional float pad_color_b = 12;
inline bool SSDRandomCropPadOperation::has_pad_color_b() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SSDRandomCropPadOperation::set_has_pad_color_b() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SSDRandomCropPadOperation::clear_has_pad_color_b() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SSDRandomCropPadOperation::clear_pad_color_b() {
  pad_color_b_ = 0;
  clear_has_pad_color_b();
}
inline float SSDRandomCropPadOperation::pad_color_b() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropPadOperation.pad_color_b)
  return pad_color_b_;
}
inline void SSDRandomCropPadOperation::set_pad_color_b(float value) {
  set_has_pad_color_b();
  pad_color_b_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropPadOperation.pad_color_b)
}

// -------------------------------------------------------------------

// SSDRandomCropPad

// repeated .object_detection.protos.SSDRandomCropPadOperation operations = 1;
inline int SSDRandomCropPad::operations_size() const {
  return operations_.size();
}
inline void SSDRandomCropPad::clear_operations() {
  operations_.Clear();
}
inline const ::object_detection::protos::SSDRandomCropPadOperation& SSDRandomCropPad::operations(int index) const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropPad.operations)
  return operations_.Get(index);
}
inline ::object_detection::protos::SSDRandomCropPadOperation* SSDRandomCropPad::mutable_operations(int index) {
  // @@protoc_insertion_point(field_mutable:object_detection.protos.SSDRandomCropPad.operations)
  return operations_.Mutable(index);
}
inline ::object_detection::protos::SSDRandomCropPadOperation* SSDRandomCropPad::add_operations() {
  // @@protoc_insertion_point(field_add:object_detection.protos.SSDRandomCropPad.operations)
  return operations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::object_detection::protos::SSDRandomCropPadOperation >*
SSDRandomCropPad::mutable_operations() {
  // @@protoc_insertion_point(field_mutable_list:object_detection.protos.SSDRandomCropPad.operations)
  return &operations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::object_detection::protos::SSDRandomCropPadOperation >&
SSDRandomCropPad::operations() const {
  // @@protoc_insertion_point(field_list:object_detection.protos.SSDRandomCropPad.operations)
  return operations_;
}

// -------------------------------------------------------------------

// SSDRandomCropFixedAspectRatioOperation

// optional float min_object_covered = 1;
inline bool SSDRandomCropFixedAspectRatioOperation::has_min_object_covered() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SSDRandomCropFixedAspectRatioOperation::set_has_min_object_covered() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SSDRandomCropFixedAspectRatioOperation::clear_has_min_object_covered() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SSDRandomCropFixedAspectRatioOperation::clear_min_object_covered() {
  min_object_covered_ = 0;
  clear_has_min_object_covered();
}
inline float SSDRandomCropFixedAspectRatioOperation::min_object_covered() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropFixedAspectRatioOperation.min_object_covered)
  return min_object_covered_;
}
inline void SSDRandomCropFixedAspectRatioOperation::set_min_object_covered(float value) {
  set_has_min_object_covered();
  min_object_covered_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropFixedAspectRatioOperation.min_object_covered)
}

// optional float min_area = 4;
inline bool SSDRandomCropFixedAspectRatioOperation::has_min_area() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SSDRandomCropFixedAspectRatioOperation::set_has_min_area() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SSDRandomCropFixedAspectRatioOperation::clear_has_min_area() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SSDRandomCropFixedAspectRatioOperation::clear_min_area() {
  min_area_ = 0;
  clear_has_min_area();
}
inline float SSDRandomCropFixedAspectRatioOperation::min_area() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropFixedAspectRatioOperation.min_area)
  return min_area_;
}
inline void SSDRandomCropFixedAspectRatioOperation::set_min_area(float value) {
  set_has_min_area();
  min_area_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropFixedAspectRatioOperation.min_area)
}

// optional float max_area = 5;
inline bool SSDRandomCropFixedAspectRatioOperation::has_max_area() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SSDRandomCropFixedAspectRatioOperation::set_has_max_area() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SSDRandomCropFixedAspectRatioOperation::clear_has_max_area() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SSDRandomCropFixedAspectRatioOperation::clear_max_area() {
  max_area_ = 0;
  clear_has_max_area();
}
inline float SSDRandomCropFixedAspectRatioOperation::max_area() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropFixedAspectRatioOperation.max_area)
  return max_area_;
}
inline void SSDRandomCropFixedAspectRatioOperation::set_max_area(float value) {
  set_has_max_area();
  max_area_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropFixedAspectRatioOperation.max_area)
}

// optional float overlap_thresh = 6;
inline bool SSDRandomCropFixedAspectRatioOperation::has_overlap_thresh() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SSDRandomCropFixedAspectRatioOperation::set_has_overlap_thresh() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SSDRandomCropFixedAspectRatioOperation::clear_has_overlap_thresh() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SSDRandomCropFixedAspectRatioOperation::clear_overlap_thresh() {
  overlap_thresh_ = 0;
  clear_has_overlap_thresh();
}
inline float SSDRandomCropFixedAspectRatioOperation::overlap_thresh() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropFixedAspectRatioOperation.overlap_thresh)
  return overlap_thresh_;
}
inline void SSDRandomCropFixedAspectRatioOperation::set_overlap_thresh(float value) {
  set_has_overlap_thresh();
  overlap_thresh_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropFixedAspectRatioOperation.overlap_thresh)
}

// optional bool clip_boxes = 8 [default = true];
inline bool SSDRandomCropFixedAspectRatioOperation::has_clip_boxes() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SSDRandomCropFixedAspectRatioOperation::set_has_clip_boxes() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SSDRandomCropFixedAspectRatioOperation::clear_has_clip_boxes() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SSDRandomCropFixedAspectRatioOperation::clear_clip_boxes() {
  clip_boxes_ = true;
  clear_has_clip_boxes();
}
inline bool SSDRandomCropFixedAspectRatioOperation::clip_boxes() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropFixedAspectRatioOperation.clip_boxes)
  return clip_boxes_;
}
inline void SSDRandomCropFixedAspectRatioOperation::set_clip_boxes(bool value) {
  set_has_clip_boxes();
  clip_boxes_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropFixedAspectRatioOperation.clip_boxes)
}

// optional float random_coef = 7;
inline bool SSDRandomCropFixedAspectRatioOperation::has_random_coef() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SSDRandomCropFixedAspectRatioOperation::set_has_random_coef() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SSDRandomCropFixedAspectRatioOperation::clear_has_random_coef() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SSDRandomCropFixedAspectRatioOperation::clear_random_coef() {
  random_coef_ = 0;
  clear_has_random_coef();
}
inline float SSDRandomCropFixedAspectRatioOperation::random_coef() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropFixedAspectRatioOperation.random_coef)
  return random_coef_;
}
inline void SSDRandomCropFixedAspectRatioOperation::set_random_coef(float value) {
  set_has_random_coef();
  random_coef_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropFixedAspectRatioOperation.random_coef)
}

// -------------------------------------------------------------------

// SSDRandomCropFixedAspectRatio

// repeated .object_detection.protos.SSDRandomCropFixedAspectRatioOperation operations = 1;
inline int SSDRandomCropFixedAspectRatio::operations_size() const {
  return operations_.size();
}
inline void SSDRandomCropFixedAspectRatio::clear_operations() {
  operations_.Clear();
}
inline const ::object_detection::protos::SSDRandomCropFixedAspectRatioOperation& SSDRandomCropFixedAspectRatio::operations(int index) const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropFixedAspectRatio.operations)
  return operations_.Get(index);
}
inline ::object_detection::protos::SSDRandomCropFixedAspectRatioOperation* SSDRandomCropFixedAspectRatio::mutable_operations(int index) {
  // @@protoc_insertion_point(field_mutable:object_detection.protos.SSDRandomCropFixedAspectRatio.operations)
  return operations_.Mutable(index);
}
inline ::object_detection::protos::SSDRandomCropFixedAspectRatioOperation* SSDRandomCropFixedAspectRatio::add_operations() {
  // @@protoc_insertion_point(field_add:object_detection.protos.SSDRandomCropFixedAspectRatio.operations)
  return operations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::object_detection::protos::SSDRandomCropFixedAspectRatioOperation >*
SSDRandomCropFixedAspectRatio::mutable_operations() {
  // @@protoc_insertion_point(field_mutable_list:object_detection.protos.SSDRandomCropFixedAspectRatio.operations)
  return &operations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::object_detection::protos::SSDRandomCropFixedAspectRatioOperation >&
SSDRandomCropFixedAspectRatio::operations() const {
  // @@protoc_insertion_point(field_list:object_detection.protos.SSDRandomCropFixedAspectRatio.operations)
  return operations_;
}

// optional float aspect_ratio = 2 [default = 1];
inline bool SSDRandomCropFixedAspectRatio::has_aspect_ratio() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SSDRandomCropFixedAspectRatio::set_has_aspect_ratio() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SSDRandomCropFixedAspectRatio::clear_has_aspect_ratio() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SSDRandomCropFixedAspectRatio::clear_aspect_ratio() {
  aspect_ratio_ = 1;
  clear_has_aspect_ratio();
}
inline float SSDRandomCropFixedAspectRatio::aspect_ratio() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropFixedAspectRatio.aspect_ratio)
  return aspect_ratio_;
}
inline void SSDRandomCropFixedAspectRatio::set_aspect_ratio(float value) {
  set_has_aspect_ratio();
  aspect_ratio_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropFixedAspectRatio.aspect_ratio)
}

// -------------------------------------------------------------------

// SSDRandomCropPadFixedAspectRatioOperation

// optional float min_object_covered = 1;
inline bool SSDRandomCropPadFixedAspectRatioOperation::has_min_object_covered() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SSDRandomCropPadFixedAspectRatioOperation::set_has_min_object_covered() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SSDRandomCropPadFixedAspectRatioOperation::clear_has_min_object_covered() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SSDRandomCropPadFixedAspectRatioOperation::clear_min_object_covered() {
  min_object_covered_ = 0;
  clear_has_min_object_covered();
}
inline float SSDRandomCropPadFixedAspectRatioOperation::min_object_covered() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropPadFixedAspectRatioOperation.min_object_covered)
  return min_object_covered_;
}
inline void SSDRandomCropPadFixedAspectRatioOperation::set_min_object_covered(float value) {
  set_has_min_object_covered();
  min_object_covered_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropPadFixedAspectRatioOperation.min_object_covered)
}

// optional float min_aspect_ratio = 2;
inline bool SSDRandomCropPadFixedAspectRatioOperation::has_min_aspect_ratio() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SSDRandomCropPadFixedAspectRatioOperation::set_has_min_aspect_ratio() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SSDRandomCropPadFixedAspectRatioOperation::clear_has_min_aspect_ratio() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SSDRandomCropPadFixedAspectRatioOperation::clear_min_aspect_ratio() {
  min_aspect_ratio_ = 0;
  clear_has_min_aspect_ratio();
}
inline float SSDRandomCropPadFixedAspectRatioOperation::min_aspect_ratio() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropPadFixedAspectRatioOperation.min_aspect_ratio)
  return min_aspect_ratio_;
}
inline void SSDRandomCropPadFixedAspectRatioOperation::set_min_aspect_ratio(float value) {
  set_has_min_aspect_ratio();
  min_aspect_ratio_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropPadFixedAspectRatioOperation.min_aspect_ratio)
}

// optional float max_aspect_ratio = 3;
inline bool SSDRandomCropPadFixedAspectRatioOperation::has_max_aspect_ratio() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SSDRandomCropPadFixedAspectRatioOperation::set_has_max_aspect_ratio() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SSDRandomCropPadFixedAspectRatioOperation::clear_has_max_aspect_ratio() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SSDRandomCropPadFixedAspectRatioOperation::clear_max_aspect_ratio() {
  max_aspect_ratio_ = 0;
  clear_has_max_aspect_ratio();
}
inline float SSDRandomCropPadFixedAspectRatioOperation::max_aspect_ratio() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropPadFixedAspectRatioOperation.max_aspect_ratio)
  return max_aspect_ratio_;
}
inline void SSDRandomCropPadFixedAspectRatioOperation::set_max_aspect_ratio(float value) {
  set_has_max_aspect_ratio();
  max_aspect_ratio_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropPadFixedAspectRatioOperation.max_aspect_ratio)
}

// optional float min_area = 4;
inline bool SSDRandomCropPadFixedAspectRatioOperation::has_min_area() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SSDRandomCropPadFixedAspectRatioOperation::set_has_min_area() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SSDRandomCropPadFixedAspectRatioOperation::clear_has_min_area() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SSDRandomCropPadFixedAspectRatioOperation::clear_min_area() {
  min_area_ = 0;
  clear_has_min_area();
}
inline float SSDRandomCropPadFixedAspectRatioOperation::min_area() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropPadFixedAspectRatioOperation.min_area)
  return min_area_;
}
inline void SSDRandomCropPadFixedAspectRatioOperation::set_min_area(float value) {
  set_has_min_area();
  min_area_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropPadFixedAspectRatioOperation.min_area)
}

// optional float max_area = 5;
inline bool SSDRandomCropPadFixedAspectRatioOperation::has_max_area() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SSDRandomCropPadFixedAspectRatioOperation::set_has_max_area() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SSDRandomCropPadFixedAspectRatioOperation::clear_has_max_area() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SSDRandomCropPadFixedAspectRatioOperation::clear_max_area() {
  max_area_ = 0;
  clear_has_max_area();
}
inline float SSDRandomCropPadFixedAspectRatioOperation::max_area() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropPadFixedAspectRatioOperation.max_area)
  return max_area_;
}
inline void SSDRandomCropPadFixedAspectRatioOperation::set_max_area(float value) {
  set_has_max_area();
  max_area_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropPadFixedAspectRatioOperation.max_area)
}

// optional float overlap_thresh = 6;
inline bool SSDRandomCropPadFixedAspectRatioOperation::has_overlap_thresh() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SSDRandomCropPadFixedAspectRatioOperation::set_has_overlap_thresh() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SSDRandomCropPadFixedAspectRatioOperation::clear_has_overlap_thresh() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SSDRandomCropPadFixedAspectRatioOperation::clear_overlap_thresh() {
  overlap_thresh_ = 0;
  clear_has_overlap_thresh();
}
inline float SSDRandomCropPadFixedAspectRatioOperation::overlap_thresh() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropPadFixedAspectRatioOperation.overlap_thresh)
  return overlap_thresh_;
}
inline void SSDRandomCropPadFixedAspectRatioOperation::set_overlap_thresh(float value) {
  set_has_overlap_thresh();
  overlap_thresh_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropPadFixedAspectRatioOperation.overlap_thresh)
}

// optional bool clip_boxes = 8 [default = true];
inline bool SSDRandomCropPadFixedAspectRatioOperation::has_clip_boxes() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SSDRandomCropPadFixedAspectRatioOperation::set_has_clip_boxes() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SSDRandomCropPadFixedAspectRatioOperation::clear_has_clip_boxes() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SSDRandomCropPadFixedAspectRatioOperation::clear_clip_boxes() {
  clip_boxes_ = true;
  clear_has_clip_boxes();
}
inline bool SSDRandomCropPadFixedAspectRatioOperation::clip_boxes() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropPadFixedAspectRatioOperation.clip_boxes)
  return clip_boxes_;
}
inline void SSDRandomCropPadFixedAspectRatioOperation::set_clip_boxes(bool value) {
  set_has_clip_boxes();
  clip_boxes_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropPadFixedAspectRatioOperation.clip_boxes)
}

// optional float random_coef = 7;
inline bool SSDRandomCropPadFixedAspectRatioOperation::has_random_coef() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SSDRandomCropPadFixedAspectRatioOperation::set_has_random_coef() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SSDRandomCropPadFixedAspectRatioOperation::clear_has_random_coef() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SSDRandomCropPadFixedAspectRatioOperation::clear_random_coef() {
  random_coef_ = 0;
  clear_has_random_coef();
}
inline float SSDRandomCropPadFixedAspectRatioOperation::random_coef() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropPadFixedAspectRatioOperation.random_coef)
  return random_coef_;
}
inline void SSDRandomCropPadFixedAspectRatioOperation::set_random_coef(float value) {
  set_has_random_coef();
  random_coef_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropPadFixedAspectRatioOperation.random_coef)
}

// -------------------------------------------------------------------

// SSDRandomCropPadFixedAspectRatio

// repeated .object_detection.protos.SSDRandomCropPadFixedAspectRatioOperation operations = 1;
inline int SSDRandomCropPadFixedAspectRatio::operations_size() const {
  return operations_.size();
}
inline void SSDRandomCropPadFixedAspectRatio::clear_operations() {
  operations_.Clear();
}
inline const ::object_detection::protos::SSDRandomCropPadFixedAspectRatioOperation& SSDRandomCropPadFixedAspectRatio::operations(int index) const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropPadFixedAspectRatio.operations)
  return operations_.Get(index);
}
inline ::object_detection::protos::SSDRandomCropPadFixedAspectRatioOperation* SSDRandomCropPadFixedAspectRatio::mutable_operations(int index) {
  // @@protoc_insertion_point(field_mutable:object_detection.protos.SSDRandomCropPadFixedAspectRatio.operations)
  return operations_.Mutable(index);
}
inline ::object_detection::protos::SSDRandomCropPadFixedAspectRatioOperation* SSDRandomCropPadFixedAspectRatio::add_operations() {
  // @@protoc_insertion_point(field_add:object_detection.protos.SSDRandomCropPadFixedAspectRatio.operations)
  return operations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::object_detection::protos::SSDRandomCropPadFixedAspectRatioOperation >*
SSDRandomCropPadFixedAspectRatio::mutable_operations() {
  // @@protoc_insertion_point(field_mutable_list:object_detection.protos.SSDRandomCropPadFixedAspectRatio.operations)
  return &operations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::object_detection::protos::SSDRandomCropPadFixedAspectRatioOperation >&
SSDRandomCropPadFixedAspectRatio::operations() const {
  // @@protoc_insertion_point(field_list:object_detection.protos.SSDRandomCropPadFixedAspectRatio.operations)
  return operations_;
}

// optional float aspect_ratio = 2 [default = 1];
inline bool SSDRandomCropPadFixedAspectRatio::has_aspect_ratio() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SSDRandomCropPadFixedAspectRatio::set_has_aspect_ratio() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SSDRandomCropPadFixedAspectRatio::clear_has_aspect_ratio() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SSDRandomCropPadFixedAspectRatio::clear_aspect_ratio() {
  aspect_ratio_ = 1;
  clear_has_aspect_ratio();
}
inline float SSDRandomCropPadFixedAspectRatio::aspect_ratio() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropPadFixedAspectRatio.aspect_ratio)
  return aspect_ratio_;
}
inline void SSDRandomCropPadFixedAspectRatio::set_aspect_ratio(float value) {
  set_has_aspect_ratio();
  aspect_ratio_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropPadFixedAspectRatio.aspect_ratio)
}

// repeated float min_padded_size_ratio = 3;
inline int SSDRandomCropPadFixedAspectRatio::min_padded_size_ratio_size() const {
  return min_padded_size_ratio_.size();
}
inline void SSDRandomCropPadFixedAspectRatio::clear_min_padded_size_ratio() {
  min_padded_size_ratio_.Clear();
}
inline float SSDRandomCropPadFixedAspectRatio::min_padded_size_ratio(int index) const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropPadFixedAspectRatio.min_padded_size_ratio)
  return min_padded_size_ratio_.Get(index);
}
inline void SSDRandomCropPadFixedAspectRatio::set_min_padded_size_ratio(int index, float value) {
  min_padded_size_ratio_.Set(index, value);
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropPadFixedAspectRatio.min_padded_size_ratio)
}
inline void SSDRandomCropPadFixedAspectRatio::add_min_padded_size_ratio(float value) {
  min_padded_size_ratio_.Add(value);
  // @@protoc_insertion_point(field_add:object_detection.protos.SSDRandomCropPadFixedAspectRatio.min_padded_size_ratio)
}
inline const ::google::protobuf::RepeatedField< float >&
SSDRandomCropPadFixedAspectRatio::min_padded_size_ratio() const {
  // @@protoc_insertion_point(field_list:object_detection.protos.SSDRandomCropPadFixedAspectRatio.min_padded_size_ratio)
  return min_padded_size_ratio_;
}
inline ::google::protobuf::RepeatedField< float >*
SSDRandomCropPadFixedAspectRatio::mutable_min_padded_size_ratio() {
  // @@protoc_insertion_point(field_mutable_list:object_detection.protos.SSDRandomCropPadFixedAspectRatio.min_padded_size_ratio)
  return &min_padded_size_ratio_;
}

// repeated float max_padded_size_ratio = 4;
inline int SSDRandomCropPadFixedAspectRatio::max_padded_size_ratio_size() const {
  return max_padded_size_ratio_.size();
}
inline void SSDRandomCropPadFixedAspectRatio::clear_max_padded_size_ratio() {
  max_padded_size_ratio_.Clear();
}
inline float SSDRandomCropPadFixedAspectRatio::max_padded_size_ratio(int index) const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SSDRandomCropPadFixedAspectRatio.max_padded_size_ratio)
  return max_padded_size_ratio_.Get(index);
}
inline void SSDRandomCropPadFixedAspectRatio::set_max_padded_size_ratio(int index, float value) {
  max_padded_size_ratio_.Set(index, value);
  // @@protoc_insertion_point(field_set:object_detection.protos.SSDRandomCropPadFixedAspectRatio.max_padded_size_ratio)
}
inline void SSDRandomCropPadFixedAspectRatio::add_max_padded_size_ratio(float value) {
  max_padded_size_ratio_.Add(value);
  // @@protoc_insertion_point(field_add:object_detection.protos.SSDRandomCropPadFixedAspectRatio.max_padded_size_ratio)
}
inline const ::google::protobuf::RepeatedField< float >&
SSDRandomCropPadFixedAspectRatio::max_padded_size_ratio() const {
  // @@protoc_insertion_point(field_list:object_detection.protos.SSDRandomCropPadFixedAspectRatio.max_padded_size_ratio)
  return max_padded_size_ratio_;
}
inline ::google::protobuf::RepeatedField< float >*
SSDRandomCropPadFixedAspectRatio::mutable_max_padded_size_ratio() {
  // @@protoc_insertion_point(field_mutable_list:object_detection.protos.SSDRandomCropPadFixedAspectRatio.max_padded_size_ratio)
  return &max_padded_size_ratio_;
}

// -------------------------------------------------------------------

// ConvertClassLogitsToSoftmax

// optional float temperature = 1 [default = 1];
inline bool ConvertClassLogitsToSoftmax::has_temperature() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConvertClassLogitsToSoftmax::set_has_temperature() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConvertClassLogitsToSoftmax::clear_has_temperature() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConvertClassLogitsToSoftmax::clear_temperature() {
  temperature_ = 1;
  clear_has_temperature();
}
inline float ConvertClassLogitsToSoftmax::temperature() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.ConvertClassLogitsToSoftmax.temperature)
  return temperature_;
}
inline void ConvertClassLogitsToSoftmax::set_temperature(float value) {
  set_has_temperature();
  temperature_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.ConvertClassLogitsToSoftmax.temperature)
}

// -------------------------------------------------------------------

// RandomSelfConcatImage

// optional float concat_vertical_probability = 1 [default = 0.1];
inline bool RandomSelfConcatImage::has_concat_vertical_probability() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RandomSelfConcatImage::set_has_concat_vertical_probability() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RandomSelfConcatImage::clear_has_concat_vertical_probability() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RandomSelfConcatImage::clear_concat_vertical_probability() {
  concat_vertical_probability_ = 0.1f;
  clear_has_concat_vertical_probability();
}
inline float RandomSelfConcatImage::concat_vertical_probability() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomSelfConcatImage.concat_vertical_probability)
  return concat_vertical_probability_;
}
inline void RandomSelfConcatImage::set_concat_vertical_probability(float value) {
  set_has_concat_vertical_probability();
  concat_vertical_probability_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomSelfConcatImage.concat_vertical_probability)
}

// optional float concat_horizontal_probability = 2 [default = 0.1];
inline bool RandomSelfConcatImage::has_concat_horizontal_probability() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RandomSelfConcatImage::set_has_concat_horizontal_probability() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RandomSelfConcatImage::clear_has_concat_horizontal_probability() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RandomSelfConcatImage::clear_concat_horizontal_probability() {
  concat_horizontal_probability_ = 0.1f;
  clear_has_concat_horizontal_probability();
}
inline float RandomSelfConcatImage::concat_horizontal_probability() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RandomSelfConcatImage.concat_horizontal_probability)
  return concat_horizontal_probability_;
}
inline void RandomSelfConcatImage::set_concat_horizontal_probability(float value) {
  set_has_concat_horizontal_probability();
  concat_horizontal_probability_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RandomSelfConcatImage.concat_horizontal_probability)
}

// -------------------------------------------------------------------

// AutoAugmentImage

// optional string policy_name = 1 [default = "v0"];
inline bool AutoAugmentImage::has_policy_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AutoAugmentImage::set_has_policy_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AutoAugmentImage::clear_has_policy_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AutoAugmentImage::clear_policy_name() {
  policy_name_.ClearToDefaultNoArena(&AutoAugmentImage::_default_policy_name_.get());
  clear_has_policy_name();
}
inline const ::std::string& AutoAugmentImage::policy_name() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.AutoAugmentImage.policy_name)
  return policy_name_.GetNoArena();
}
inline void AutoAugmentImage::set_policy_name(const ::std::string& value) {
  set_has_policy_name();
  policy_name_.SetNoArena(&AutoAugmentImage::_default_policy_name_.get(), value);
  // @@protoc_insertion_point(field_set:object_detection.protos.AutoAugmentImage.policy_name)
}
#if LANG_CXX11
inline void AutoAugmentImage::set_policy_name(::std::string&& value) {
  set_has_policy_name();
  policy_name_.SetNoArena(
    &AutoAugmentImage::_default_policy_name_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:object_detection.protos.AutoAugmentImage.policy_name)
}
#endif
inline void AutoAugmentImage::set_policy_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_policy_name();
  policy_name_.SetNoArena(&AutoAugmentImage::_default_policy_name_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:object_detection.protos.AutoAugmentImage.policy_name)
}
inline void AutoAugmentImage::set_policy_name(const char* value, size_t size) {
  set_has_policy_name();
  policy_name_.SetNoArena(&AutoAugmentImage::_default_policy_name_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:object_detection.protos.AutoAugmentImage.policy_name)
}
inline ::std::string* AutoAugmentImage::mutable_policy_name() {
  set_has_policy_name();
  // @@protoc_insertion_point(field_mutable:object_detection.protos.AutoAugmentImage.policy_name)
  return policy_name_.MutableNoArena(&AutoAugmentImage::_default_policy_name_.get());
}
inline ::std::string* AutoAugmentImage::release_policy_name() {
  // @@protoc_insertion_point(field_release:object_detection.protos.AutoAugmentImage.policy_name)
  clear_has_policy_name();
  return policy_name_.ReleaseNoArena(&AutoAugmentImage::_default_policy_name_.get());
}
inline void AutoAugmentImage::set_allocated_policy_name(::std::string* policy_name) {
  if (policy_name != NULL) {
    set_has_policy_name();
  } else {
    clear_has_policy_name();
  }
  policy_name_.SetAllocatedNoArena(&AutoAugmentImage::_default_policy_name_.get(), policy_name);
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.AutoAugmentImage.policy_name)
}

// -------------------------------------------------------------------

// DropLabelProbabilistically

// optional int32 label = 1;
inline bool DropLabelProbabilistically::has_label() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DropLabelProbabilistically::set_has_label() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DropLabelProbabilistically::clear_has_label() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DropLabelProbabilistically::clear_label() {
  label_ = 0;
  clear_has_label();
}
inline ::google::protobuf::int32 DropLabelProbabilistically::label() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.DropLabelProbabilistically.label)
  return label_;
}
inline void DropLabelProbabilistically::set_label(::google::protobuf::int32 value) {
  set_has_label();
  label_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.DropLabelProbabilistically.label)
}

// optional float drop_probability = 2 [default = 1];
inline bool DropLabelProbabilistically::has_drop_probability() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DropLabelProbabilistically::set_has_drop_probability() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DropLabelProbabilistically::clear_has_drop_probability() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DropLabelProbabilistically::clear_drop_probability() {
  drop_probability_ = 1;
  clear_has_drop_probability();
}
inline float DropLabelProbabilistically::drop_probability() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.DropLabelProbabilistically.drop_probability)
  return drop_probability_;
}
inline void DropLabelProbabilistically::set_drop_probability(float value) {
  set_has_drop_probability();
  drop_probability_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.DropLabelProbabilistically.drop_probability)
}

// -------------------------------------------------------------------

// RemapLabels

// repeated int32 original_labels = 1;
inline int RemapLabels::original_labels_size() const {
  return original_labels_.size();
}
inline void RemapLabels::clear_original_labels() {
  original_labels_.Clear();
}
inline ::google::protobuf::int32 RemapLabels::original_labels(int index) const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RemapLabels.original_labels)
  return original_labels_.Get(index);
}
inline void RemapLabels::set_original_labels(int index, ::google::protobuf::int32 value) {
  original_labels_.Set(index, value);
  // @@protoc_insertion_point(field_set:object_detection.protos.RemapLabels.original_labels)
}
inline void RemapLabels::add_original_labels(::google::protobuf::int32 value) {
  original_labels_.Add(value);
  // @@protoc_insertion_point(field_add:object_detection.protos.RemapLabels.original_labels)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
RemapLabels::original_labels() const {
  // @@protoc_insertion_point(field_list:object_detection.protos.RemapLabels.original_labels)
  return original_labels_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
RemapLabels::mutable_original_labels() {
  // @@protoc_insertion_point(field_mutable_list:object_detection.protos.RemapLabels.original_labels)
  return &original_labels_;
}

// optional int32 new_label = 2;
inline bool RemapLabels::has_new_label() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemapLabels::set_has_new_label() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemapLabels::clear_has_new_label() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemapLabels::clear_new_label() {
  new_label_ = 0;
  clear_has_new_label();
}
inline ::google::protobuf::int32 RemapLabels::new_label() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RemapLabels.new_label)
  return new_label_;
}
inline void RemapLabels::set_new_label(::google::protobuf::int32 value) {
  set_has_new_label();
  new_label_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.RemapLabels.new_label)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace protos
}  // namespace object_detection

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::object_detection::protos::ResizeImage_Method> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::object_detection::protos::ResizeImage_Method>() {
  return ::object_detection::protos::ResizeImage_Method_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_object_5fdetection_2fprotos_2fpreprocessor_2eproto__INCLUDED
