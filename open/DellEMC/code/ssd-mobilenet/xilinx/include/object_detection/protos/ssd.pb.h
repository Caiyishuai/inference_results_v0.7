// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: object_detection/protos/ssd.proto

#ifndef PROTOBUF_object_5fdetection_2fprotos_2fssd_2eproto__INCLUDED
#define PROTOBUF_object_5fdetection_2fprotos_2fssd_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "object_detection/protos/anchor_generator.pb.h"
#include "object_detection/protos/box_coder.pb.h"
#include "object_detection/protos/box_predictor.pb.h"
#include "object_detection/protos/hyperparams.pb.h"
#include "object_detection/protos/image_resizer.pb.h"
#include "object_detection/protos/losses.pb.h"
#include "object_detection/protos/matcher.pb.h"
#include "object_detection/protos/post_processing.pb.h"
#include "object_detection/protos/region_similarity_calculator.pb.h"
// @@protoc_insertion_point(includes)
namespace object_detection {
namespace protos {
class FeaturePyramidNetworks;
class FeaturePyramidNetworksDefaultTypeInternal;
extern FeaturePyramidNetworksDefaultTypeInternal _FeaturePyramidNetworks_default_instance_;
class Ssd;
class SsdDefaultTypeInternal;
extern SsdDefaultTypeInternal _Ssd_default_instance_;
class SsdFeatureExtractor;
class SsdFeatureExtractorDefaultTypeInternal;
extern SsdFeatureExtractorDefaultTypeInternal _SsdFeatureExtractor_default_instance_;
class Ssd_MaskHead;
class Ssd_MaskHeadDefaultTypeInternal;
extern Ssd_MaskHeadDefaultTypeInternal _Ssd_MaskHead_default_instance_;
}  // namespace protos
}  // namespace object_detection

namespace object_detection {
namespace protos {

namespace protobuf_object_5fdetection_2fprotos_2fssd_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_object_5fdetection_2fprotos_2fssd_2eproto

// ===================================================================

class Ssd_MaskHead : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.Ssd.MaskHead) */ {
 public:
  Ssd_MaskHead();
  virtual ~Ssd_MaskHead();

  Ssd_MaskHead(const Ssd_MaskHead& from);

  inline Ssd_MaskHead& operator=(const Ssd_MaskHead& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Ssd_MaskHead(Ssd_MaskHead&& from) noexcept
    : Ssd_MaskHead() {
    *this = ::std::move(from);
  }

  inline Ssd_MaskHead& operator=(Ssd_MaskHead&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ssd_MaskHead& default_instance();

  static inline const Ssd_MaskHead* internal_default_instance() {
    return reinterpret_cast<const Ssd_MaskHead*>(
               &_Ssd_MaskHead_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Ssd_MaskHead* other);
  friend void swap(Ssd_MaskHead& a, Ssd_MaskHead& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Ssd_MaskHead* New() const PROTOBUF_FINAL { return New(NULL); }

  Ssd_MaskHead* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Ssd_MaskHead& from);
  void MergeFrom(const Ssd_MaskHead& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Ssd_MaskHead* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .object_detection.protos.Hyperparams conv_hyperparams = 9;
  bool has_conv_hyperparams() const;
  void clear_conv_hyperparams();
  static const int kConvHyperparamsFieldNumber = 9;
  const ::object_detection::protos::Hyperparams& conv_hyperparams() const;
  ::object_detection::protos::Hyperparams* mutable_conv_hyperparams();
  ::object_detection::protos::Hyperparams* release_conv_hyperparams();
  void set_allocated_conv_hyperparams(::object_detection::protos::Hyperparams* conv_hyperparams);

  // optional bool convolve_then_upsample_masks = 6 [default = false];
  bool has_convolve_then_upsample_masks() const;
  void clear_convolve_then_upsample_masks();
  static const int kConvolveThenUpsampleMasksFieldNumber = 6;
  bool convolve_then_upsample_masks() const;
  void set_convolve_then_upsample_masks(bool value);

  // optional int32 mask_height = 1 [default = 15];
  bool has_mask_height() const;
  void clear_mask_height();
  static const int kMaskHeightFieldNumber = 1;
  ::google::protobuf::int32 mask_height() const;
  void set_mask_height(::google::protobuf::int32 value);

  // optional int32 mask_width = 2 [default = 15];
  bool has_mask_width() const;
  void clear_mask_width();
  static const int kMaskWidthFieldNumber = 2;
  ::google::protobuf::int32 mask_width() const;
  void set_mask_width(::google::protobuf::int32 value);

  // optional bool masks_are_class_agnostic = 3 [default = true];
  bool has_masks_are_class_agnostic() const;
  void clear_masks_are_class_agnostic();
  static const int kMasksAreClassAgnosticFieldNumber = 3;
  bool masks_are_class_agnostic() const;
  void set_masks_are_class_agnostic(bool value);

  // optional int32 mask_prediction_conv_depth = 4 [default = 256];
  bool has_mask_prediction_conv_depth() const;
  void clear_mask_prediction_conv_depth();
  static const int kMaskPredictionConvDepthFieldNumber = 4;
  ::google::protobuf::int32 mask_prediction_conv_depth() const;
  void set_mask_prediction_conv_depth(::google::protobuf::int32 value);

  // optional int32 mask_prediction_num_conv_layers = 5 [default = 2];
  bool has_mask_prediction_num_conv_layers() const;
  void clear_mask_prediction_num_conv_layers();
  static const int kMaskPredictionNumConvLayersFieldNumber = 5;
  ::google::protobuf::int32 mask_prediction_num_conv_layers() const;
  void set_mask_prediction_num_conv_layers(::google::protobuf::int32 value);

  // optional float mask_loss_weight = 7 [default = 5];
  bool has_mask_loss_weight() const;
  void clear_mask_loss_weight();
  static const int kMaskLossWeightFieldNumber = 7;
  float mask_loss_weight() const;
  void set_mask_loss_weight(float value);

  // optional int32 mask_loss_sample_size = 8 [default = 16];
  bool has_mask_loss_sample_size() const;
  void clear_mask_loss_sample_size();
  static const int kMaskLossSampleSizeFieldNumber = 8;
  ::google::protobuf::int32 mask_loss_sample_size() const;
  void set_mask_loss_sample_size(::google::protobuf::int32 value);

  // optional int32 initial_crop_size = 10 [default = 15];
  bool has_initial_crop_size() const;
  void clear_initial_crop_size();
  static const int kInitialCropSizeFieldNumber = 10;
  ::google::protobuf::int32 initial_crop_size() const;
  void set_initial_crop_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:object_detection.protos.Ssd.MaskHead)
 private:
  void set_has_mask_height();
  void clear_has_mask_height();
  void set_has_mask_width();
  void clear_has_mask_width();
  void set_has_masks_are_class_agnostic();
  void clear_has_masks_are_class_agnostic();
  void set_has_mask_prediction_conv_depth();
  void clear_has_mask_prediction_conv_depth();
  void set_has_mask_prediction_num_conv_layers();
  void clear_has_mask_prediction_num_conv_layers();
  void set_has_convolve_then_upsample_masks();
  void clear_has_convolve_then_upsample_masks();
  void set_has_mask_loss_weight();
  void clear_has_mask_loss_weight();
  void set_has_mask_loss_sample_size();
  void clear_has_mask_loss_sample_size();
  void set_has_conv_hyperparams();
  void clear_has_conv_hyperparams();
  void set_has_initial_crop_size();
  void clear_has_initial_crop_size();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::object_detection::protos::Hyperparams* conv_hyperparams_;
  bool convolve_then_upsample_masks_;
  ::google::protobuf::int32 mask_height_;
  ::google::protobuf::int32 mask_width_;
  bool masks_are_class_agnostic_;
  ::google::protobuf::int32 mask_prediction_conv_depth_;
  ::google::protobuf::int32 mask_prediction_num_conv_layers_;
  float mask_loss_weight_;
  ::google::protobuf::int32 mask_loss_sample_size_;
  ::google::protobuf::int32 initial_crop_size_;
  friend struct protobuf_object_5fdetection_2fprotos_2fssd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Ssd : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.Ssd) */ {
 public:
  Ssd();
  virtual ~Ssd();

  Ssd(const Ssd& from);

  inline Ssd& operator=(const Ssd& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Ssd(Ssd&& from) noexcept
    : Ssd() {
    *this = ::std::move(from);
  }

  inline Ssd& operator=(Ssd&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ssd& default_instance();

  static inline const Ssd* internal_default_instance() {
    return reinterpret_cast<const Ssd*>(
               &_Ssd_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Ssd* other);
  friend void swap(Ssd& a, Ssd& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Ssd* New() const PROTOBUF_FINAL { return New(NULL); }

  Ssd* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Ssd& from);
  void MergeFrom(const Ssd& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Ssd* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Ssd_MaskHead MaskHead;

  // accessors -------------------------------------------------------

  // optional .object_detection.protos.ImageResizer image_resizer = 2;
  bool has_image_resizer() const;
  void clear_image_resizer();
  static const int kImageResizerFieldNumber = 2;
  const ::object_detection::protos::ImageResizer& image_resizer() const;
  ::object_detection::protos::ImageResizer* mutable_image_resizer();
  ::object_detection::protos::ImageResizer* release_image_resizer();
  void set_allocated_image_resizer(::object_detection::protos::ImageResizer* image_resizer);

  // optional .object_detection.protos.SsdFeatureExtractor feature_extractor = 3;
  bool has_feature_extractor() const;
  void clear_feature_extractor();
  static const int kFeatureExtractorFieldNumber = 3;
  const ::object_detection::protos::SsdFeatureExtractor& feature_extractor() const;
  ::object_detection::protos::SsdFeatureExtractor* mutable_feature_extractor();
  ::object_detection::protos::SsdFeatureExtractor* release_feature_extractor();
  void set_allocated_feature_extractor(::object_detection::protos::SsdFeatureExtractor* feature_extractor);

  // optional .object_detection.protos.BoxCoder box_coder = 4;
  bool has_box_coder() const;
  void clear_box_coder();
  static const int kBoxCoderFieldNumber = 4;
  const ::object_detection::protos::BoxCoder& box_coder() const;
  ::object_detection::protos::BoxCoder* mutable_box_coder();
  ::object_detection::protos::BoxCoder* release_box_coder();
  void set_allocated_box_coder(::object_detection::protos::BoxCoder* box_coder);

  // optional .object_detection.protos.Matcher matcher = 5;
  bool has_matcher() const;
  void clear_matcher();
  static const int kMatcherFieldNumber = 5;
  const ::object_detection::protos::Matcher& matcher() const;
  ::object_detection::protos::Matcher* mutable_matcher();
  ::object_detection::protos::Matcher* release_matcher();
  void set_allocated_matcher(::object_detection::protos::Matcher* matcher);

  // optional .object_detection.protos.RegionSimilarityCalculator similarity_calculator = 6;
  bool has_similarity_calculator() const;
  void clear_similarity_calculator();
  static const int kSimilarityCalculatorFieldNumber = 6;
  const ::object_detection::protos::RegionSimilarityCalculator& similarity_calculator() const;
  ::object_detection::protos::RegionSimilarityCalculator* mutable_similarity_calculator();
  ::object_detection::protos::RegionSimilarityCalculator* release_similarity_calculator();
  void set_allocated_similarity_calculator(::object_detection::protos::RegionSimilarityCalculator* similarity_calculator);

  // optional .object_detection.protos.BoxPredictor box_predictor = 7;
  bool has_box_predictor() const;
  void clear_box_predictor();
  static const int kBoxPredictorFieldNumber = 7;
  const ::object_detection::protos::BoxPredictor& box_predictor() const;
  ::object_detection::protos::BoxPredictor* mutable_box_predictor();
  ::object_detection::protos::BoxPredictor* release_box_predictor();
  void set_allocated_box_predictor(::object_detection::protos::BoxPredictor* box_predictor);

  // optional .object_detection.protos.AnchorGenerator anchor_generator = 8;
  bool has_anchor_generator() const;
  void clear_anchor_generator();
  static const int kAnchorGeneratorFieldNumber = 8;
  const ::object_detection::protos::AnchorGenerator& anchor_generator() const;
  ::object_detection::protos::AnchorGenerator* mutable_anchor_generator();
  ::object_detection::protos::AnchorGenerator* release_anchor_generator();
  void set_allocated_anchor_generator(::object_detection::protos::AnchorGenerator* anchor_generator);

  // optional .object_detection.protos.PostProcessing post_processing = 9;
  bool has_post_processing() const;
  void clear_post_processing();
  static const int kPostProcessingFieldNumber = 9;
  const ::object_detection::protos::PostProcessing& post_processing() const;
  ::object_detection::protos::PostProcessing* mutable_post_processing();
  ::object_detection::protos::PostProcessing* release_post_processing();
  void set_allocated_post_processing(::object_detection::protos::PostProcessing* post_processing);

  // optional .object_detection.protos.Loss loss = 11;
  bool has_loss() const;
  void clear_loss();
  static const int kLossFieldNumber = 11;
  const ::object_detection::protos::Loss& loss() const;
  ::object_detection::protos::Loss* mutable_loss();
  ::object_detection::protos::Loss* release_loss();
  void set_allocated_loss(::object_detection::protos::Loss* loss);

  // optional .object_detection.protos.Ssd.MaskHead mask_head_config = 25;
  bool has_mask_head_config() const;
  void clear_mask_head_config();
  static const int kMaskHeadConfigFieldNumber = 25;
  const ::object_detection::protos::Ssd_MaskHead& mask_head_config() const;
  ::object_detection::protos::Ssd_MaskHead* mutable_mask_head_config();
  ::object_detection::protos::Ssd_MaskHead* release_mask_head_config();
  void set_allocated_mask_head_config(::object_detection::protos::Ssd_MaskHead* mask_head_config);

  // optional int32 num_classes = 1;
  bool has_num_classes() const;
  void clear_num_classes();
  static const int kNumClassesFieldNumber = 1;
  ::google::protobuf::int32 num_classes() const;
  void set_num_classes(::google::protobuf::int32 value);

  // optional bool encode_background_as_zeros = 12 [default = false];
  bool has_encode_background_as_zeros() const;
  void clear_encode_background_as_zeros();
  static const int kEncodeBackgroundAsZerosFieldNumber = 12;
  bool encode_background_as_zeros() const;
  void set_encode_background_as_zeros(bool value);

  // optional bool normalize_loc_loss_by_codesize = 14 [default = false];
  bool has_normalize_loc_loss_by_codesize() const;
  void clear_normalize_loc_loss_by_codesize();
  static const int kNormalizeLocLossByCodesizeFieldNumber = 14;
  bool normalize_loc_loss_by_codesize() const;
  void set_normalize_loc_loss_by_codesize(bool value);

  // optional bool freeze_batchnorm = 16 [default = false];
  bool has_freeze_batchnorm() const;
  void clear_freeze_batchnorm();
  static const int kFreezeBatchnormFieldNumber = 16;
  bool freeze_batchnorm() const;
  void set_freeze_batchnorm(bool value);

  // optional bool inplace_batchnorm_update = 15 [default = false];
  bool has_inplace_batchnorm_update() const;
  void clear_inplace_batchnorm_update();
  static const int kInplaceBatchnormUpdateFieldNumber = 15;
  bool inplace_batchnorm_update() const;
  void set_inplace_batchnorm_update(bool value);

  // optional bool explicit_background_class = 24 [default = false];
  bool has_explicit_background_class() const;
  void clear_explicit_background_class();
  static const int kExplicitBackgroundClassFieldNumber = 24;
  bool explicit_background_class() const;
  void set_explicit_background_class(bool value);

  // optional bool use_confidences_as_targets = 22 [default = false];
  bool has_use_confidences_as_targets() const;
  void clear_use_confidences_as_targets();
  static const int kUseConfidencesAsTargetsFieldNumber = 22;
  bool use_confidences_as_targets() const;
  void set_use_confidences_as_targets(bool value);

  // optional float implicit_example_weight = 23 [default = 1];
  bool has_implicit_example_weight() const;
  void clear_implicit_example_weight();
  static const int kImplicitExampleWeightFieldNumber = 23;
  float implicit_example_weight() const;
  void set_implicit_example_weight(float value);

  // optional float negative_class_weight = 13 [default = 1];
  bool has_negative_class_weight() const;
  void clear_negative_class_weight();
  static const int kNegativeClassWeightFieldNumber = 13;
  float negative_class_weight() const;
  void set_negative_class_weight(float value);

  // optional bool normalize_loss_by_num_matches = 10 [default = true];
  bool has_normalize_loss_by_num_matches() const;
  void clear_normalize_loss_by_num_matches();
  static const int kNormalizeLossByNumMatchesFieldNumber = 10;
  bool normalize_loss_by_num_matches() const;
  void set_normalize_loss_by_num_matches(bool value);

  // optional bool add_background_class = 21 [default = true];
  bool has_add_background_class() const;
  void clear_add_background_class();
  static const int kAddBackgroundClassFieldNumber = 21;
  bool add_background_class() const;
  void set_add_background_class(bool value);

  // @@protoc_insertion_point(class_scope:object_detection.protos.Ssd)
 private:
  void set_has_num_classes();
  void clear_has_num_classes();
  void set_has_image_resizer();
  void clear_has_image_resizer();
  void set_has_feature_extractor();
  void clear_has_feature_extractor();
  void set_has_box_coder();
  void clear_has_box_coder();
  void set_has_matcher();
  void clear_has_matcher();
  void set_has_similarity_calculator();
  void clear_has_similarity_calculator();
  void set_has_encode_background_as_zeros();
  void clear_has_encode_background_as_zeros();
  void set_has_negative_class_weight();
  void clear_has_negative_class_weight();
  void set_has_box_predictor();
  void clear_has_box_predictor();
  void set_has_anchor_generator();
  void clear_has_anchor_generator();
  void set_has_post_processing();
  void clear_has_post_processing();
  void set_has_normalize_loss_by_num_matches();
  void clear_has_normalize_loss_by_num_matches();
  void set_has_normalize_loc_loss_by_codesize();
  void clear_has_normalize_loc_loss_by_codesize();
  void set_has_loss();
  void clear_has_loss();
  void set_has_freeze_batchnorm();
  void clear_has_freeze_batchnorm();
  void set_has_inplace_batchnorm_update();
  void clear_has_inplace_batchnorm_update();
  void set_has_add_background_class();
  void clear_has_add_background_class();
  void set_has_explicit_background_class();
  void clear_has_explicit_background_class();
  void set_has_use_confidences_as_targets();
  void clear_has_use_confidences_as_targets();
  void set_has_implicit_example_weight();
  void clear_has_implicit_example_weight();
  void set_has_mask_head_config();
  void clear_has_mask_head_config();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::object_detection::protos::ImageResizer* image_resizer_;
  ::object_detection::protos::SsdFeatureExtractor* feature_extractor_;
  ::object_detection::protos::BoxCoder* box_coder_;
  ::object_detection::protos::Matcher* matcher_;
  ::object_detection::protos::RegionSimilarityCalculator* similarity_calculator_;
  ::object_detection::protos::BoxPredictor* box_predictor_;
  ::object_detection::protos::AnchorGenerator* anchor_generator_;
  ::object_detection::protos::PostProcessing* post_processing_;
  ::object_detection::protos::Loss* loss_;
  ::object_detection::protos::Ssd_MaskHead* mask_head_config_;
  ::google::protobuf::int32 num_classes_;
  bool encode_background_as_zeros_;
  bool normalize_loc_loss_by_codesize_;
  bool freeze_batchnorm_;
  bool inplace_batchnorm_update_;
  bool explicit_background_class_;
  bool use_confidences_as_targets_;
  float implicit_example_weight_;
  float negative_class_weight_;
  bool normalize_loss_by_num_matches_;
  bool add_background_class_;
  friend struct protobuf_object_5fdetection_2fprotos_2fssd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SsdFeatureExtractor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.SsdFeatureExtractor) */ {
 public:
  SsdFeatureExtractor();
  virtual ~SsdFeatureExtractor();

  SsdFeatureExtractor(const SsdFeatureExtractor& from);

  inline SsdFeatureExtractor& operator=(const SsdFeatureExtractor& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SsdFeatureExtractor(SsdFeatureExtractor&& from) noexcept
    : SsdFeatureExtractor() {
    *this = ::std::move(from);
  }

  inline SsdFeatureExtractor& operator=(SsdFeatureExtractor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SsdFeatureExtractor& default_instance();

  static inline const SsdFeatureExtractor* internal_default_instance() {
    return reinterpret_cast<const SsdFeatureExtractor*>(
               &_SsdFeatureExtractor_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(SsdFeatureExtractor* other);
  friend void swap(SsdFeatureExtractor& a, SsdFeatureExtractor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SsdFeatureExtractor* New() const PROTOBUF_FINAL { return New(NULL); }

  SsdFeatureExtractor* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SsdFeatureExtractor& from);
  void MergeFrom(const SsdFeatureExtractor& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SsdFeatureExtractor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional .object_detection.protos.Hyperparams conv_hyperparams = 4;
  bool has_conv_hyperparams() const;
  void clear_conv_hyperparams();
  static const int kConvHyperparamsFieldNumber = 4;
  const ::object_detection::protos::Hyperparams& conv_hyperparams() const;
  ::object_detection::protos::Hyperparams* mutable_conv_hyperparams();
  ::object_detection::protos::Hyperparams* release_conv_hyperparams();
  void set_allocated_conv_hyperparams(::object_detection::protos::Hyperparams* conv_hyperparams);

  // optional .object_detection.protos.FeaturePyramidNetworks fpn = 10;
  bool has_fpn() const;
  void clear_fpn();
  static const int kFpnFieldNumber = 10;
  const ::object_detection::protos::FeaturePyramidNetworks& fpn() const;
  ::object_detection::protos::FeaturePyramidNetworks* mutable_fpn();
  ::object_detection::protos::FeaturePyramidNetworks* release_fpn();
  void set_allocated_fpn(::object_detection::protos::FeaturePyramidNetworks* fpn);

  // optional bool override_base_feature_extractor_hyperparams = 9 [default = false];
  bool has_override_base_feature_extractor_hyperparams() const;
  void clear_override_base_feature_extractor_hyperparams();
  static const int kOverrideBaseFeatureExtractorHyperparamsFieldNumber = 9;
  bool override_base_feature_extractor_hyperparams() const;
  void set_override_base_feature_extractor_hyperparams(bool value);

  // optional bool use_explicit_padding = 7 [default = false];
  bool has_use_explicit_padding() const;
  void clear_use_explicit_padding();
  static const int kUseExplicitPaddingFieldNumber = 7;
  bool use_explicit_padding() const;
  void set_use_explicit_padding(bool value);

  // optional bool use_depthwise = 8 [default = false];
  bool has_use_depthwise() const;
  void clear_use_depthwise();
  static const int kUseDepthwiseFieldNumber = 8;
  bool use_depthwise() const;
  void set_use_depthwise(bool value);

  // optional bool replace_preprocessor_with_placeholder = 11 [default = false];
  bool has_replace_preprocessor_with_placeholder() const;
  void clear_replace_preprocessor_with_placeholder();
  static const int kReplacePreprocessorWithPlaceholderFieldNumber = 11;
  bool replace_preprocessor_with_placeholder() const;
  void set_replace_preprocessor_with_placeholder(bool value);

  // optional float depth_multiplier = 2 [default = 1];
  bool has_depth_multiplier() const;
  void clear_depth_multiplier();
  static const int kDepthMultiplierFieldNumber = 2;
  float depth_multiplier() const;
  void set_depth_multiplier(float value);

  // optional int32 min_depth = 3 [default = 16];
  bool has_min_depth() const;
  void clear_min_depth();
  static const int kMinDepthFieldNumber = 3;
  ::google::protobuf::int32 min_depth() const;
  void set_min_depth(::google::protobuf::int32 value);

  // optional int32 pad_to_multiple = 5 [default = 1];
  bool has_pad_to_multiple() const;
  void clear_pad_to_multiple();
  static const int kPadToMultipleFieldNumber = 5;
  ::google::protobuf::int32 pad_to_multiple() const;
  void set_pad_to_multiple(::google::protobuf::int32 value);

  // optional int32 num_layers = 12 [default = 6];
  bool has_num_layers() const;
  void clear_num_layers();
  static const int kNumLayersFieldNumber = 12;
  ::google::protobuf::int32 num_layers() const;
  void set_num_layers(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:object_detection.protos.SsdFeatureExtractor)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_depth_multiplier();
  void clear_has_depth_multiplier();
  void set_has_min_depth();
  void clear_has_min_depth();
  void set_has_conv_hyperparams();
  void clear_has_conv_hyperparams();
  void set_has_override_base_feature_extractor_hyperparams();
  void clear_has_override_base_feature_extractor_hyperparams();
  void set_has_pad_to_multiple();
  void clear_has_pad_to_multiple();
  void set_has_use_explicit_padding();
  void clear_has_use_explicit_padding();
  void set_has_use_depthwise();
  void clear_has_use_depthwise();
  void set_has_fpn();
  void clear_has_fpn();
  void set_has_replace_preprocessor_with_placeholder();
  void clear_has_replace_preprocessor_with_placeholder();
  void set_has_num_layers();
  void clear_has_num_layers();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::object_detection::protos::Hyperparams* conv_hyperparams_;
  ::object_detection::protos::FeaturePyramidNetworks* fpn_;
  bool override_base_feature_extractor_hyperparams_;
  bool use_explicit_padding_;
  bool use_depthwise_;
  bool replace_preprocessor_with_placeholder_;
  float depth_multiplier_;
  ::google::protobuf::int32 min_depth_;
  ::google::protobuf::int32 pad_to_multiple_;
  ::google::protobuf::int32 num_layers_;
  friend struct protobuf_object_5fdetection_2fprotos_2fssd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FeaturePyramidNetworks : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.FeaturePyramidNetworks) */ {
 public:
  FeaturePyramidNetworks();
  virtual ~FeaturePyramidNetworks();

  FeaturePyramidNetworks(const FeaturePyramidNetworks& from);

  inline FeaturePyramidNetworks& operator=(const FeaturePyramidNetworks& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FeaturePyramidNetworks(FeaturePyramidNetworks&& from) noexcept
    : FeaturePyramidNetworks() {
    *this = ::std::move(from);
  }

  inline FeaturePyramidNetworks& operator=(FeaturePyramidNetworks&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FeaturePyramidNetworks& default_instance();

  static inline const FeaturePyramidNetworks* internal_default_instance() {
    return reinterpret_cast<const FeaturePyramidNetworks*>(
               &_FeaturePyramidNetworks_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(FeaturePyramidNetworks* other);
  friend void swap(FeaturePyramidNetworks& a, FeaturePyramidNetworks& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FeaturePyramidNetworks* New() const PROTOBUF_FINAL { return New(NULL); }

  FeaturePyramidNetworks* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FeaturePyramidNetworks& from);
  void MergeFrom(const FeaturePyramidNetworks& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FeaturePyramidNetworks* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 additional_layer_depth = 3 [default = 256];
  bool has_additional_layer_depth() const;
  void clear_additional_layer_depth();
  static const int kAdditionalLayerDepthFieldNumber = 3;
  ::google::protobuf::int32 additional_layer_depth() const;
  void set_additional_layer_depth(::google::protobuf::int32 value);

  // optional int32 min_level = 1 [default = 3];
  bool has_min_level() const;
  void clear_min_level();
  static const int kMinLevelFieldNumber = 1;
  ::google::protobuf::int32 min_level() const;
  void set_min_level(::google::protobuf::int32 value);

  // optional int32 max_level = 2 [default = 7];
  bool has_max_level() const;
  void clear_max_level();
  static const int kMaxLevelFieldNumber = 2;
  ::google::protobuf::int32 max_level() const;
  void set_max_level(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:object_detection.protos.FeaturePyramidNetworks)
 private:
  void set_has_min_level();
  void clear_has_min_level();
  void set_has_max_level();
  void clear_has_max_level();
  void set_has_additional_layer_depth();
  void clear_has_additional_layer_depth();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 additional_layer_depth_;
  ::google::protobuf::int32 min_level_;
  ::google::protobuf::int32 max_level_;
  friend struct protobuf_object_5fdetection_2fprotos_2fssd_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Ssd_MaskHead

// optional int32 mask_height = 1 [default = 15];
inline bool Ssd_MaskHead::has_mask_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Ssd_MaskHead::set_has_mask_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Ssd_MaskHead::clear_has_mask_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Ssd_MaskHead::clear_mask_height() {
  mask_height_ = 15;
  clear_has_mask_height();
}
inline ::google::protobuf::int32 Ssd_MaskHead::mask_height() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.Ssd.MaskHead.mask_height)
  return mask_height_;
}
inline void Ssd_MaskHead::set_mask_height(::google::protobuf::int32 value) {
  set_has_mask_height();
  mask_height_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.Ssd.MaskHead.mask_height)
}

// optional int32 mask_width = 2 [default = 15];
inline bool Ssd_MaskHead::has_mask_width() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Ssd_MaskHead::set_has_mask_width() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Ssd_MaskHead::clear_has_mask_width() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Ssd_MaskHead::clear_mask_width() {
  mask_width_ = 15;
  clear_has_mask_width();
}
inline ::google::protobuf::int32 Ssd_MaskHead::mask_width() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.Ssd.MaskHead.mask_width)
  return mask_width_;
}
inline void Ssd_MaskHead::set_mask_width(::google::protobuf::int32 value) {
  set_has_mask_width();
  mask_width_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.Ssd.MaskHead.mask_width)
}

// optional bool masks_are_class_agnostic = 3 [default = true];
inline bool Ssd_MaskHead::has_masks_are_class_agnostic() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Ssd_MaskHead::set_has_masks_are_class_agnostic() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Ssd_MaskHead::clear_has_masks_are_class_agnostic() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Ssd_MaskHead::clear_masks_are_class_agnostic() {
  masks_are_class_agnostic_ = true;
  clear_has_masks_are_class_agnostic();
}
inline bool Ssd_MaskHead::masks_are_class_agnostic() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.Ssd.MaskHead.masks_are_class_agnostic)
  return masks_are_class_agnostic_;
}
inline void Ssd_MaskHead::set_masks_are_class_agnostic(bool value) {
  set_has_masks_are_class_agnostic();
  masks_are_class_agnostic_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.Ssd.MaskHead.masks_are_class_agnostic)
}

// optional int32 mask_prediction_conv_depth = 4 [default = 256];
inline bool Ssd_MaskHead::has_mask_prediction_conv_depth() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Ssd_MaskHead::set_has_mask_prediction_conv_depth() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Ssd_MaskHead::clear_has_mask_prediction_conv_depth() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Ssd_MaskHead::clear_mask_prediction_conv_depth() {
  mask_prediction_conv_depth_ = 256;
  clear_has_mask_prediction_conv_depth();
}
inline ::google::protobuf::int32 Ssd_MaskHead::mask_prediction_conv_depth() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.Ssd.MaskHead.mask_prediction_conv_depth)
  return mask_prediction_conv_depth_;
}
inline void Ssd_MaskHead::set_mask_prediction_conv_depth(::google::protobuf::int32 value) {
  set_has_mask_prediction_conv_depth();
  mask_prediction_conv_depth_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.Ssd.MaskHead.mask_prediction_conv_depth)
}

// optional int32 mask_prediction_num_conv_layers = 5 [default = 2];
inline bool Ssd_MaskHead::has_mask_prediction_num_conv_layers() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Ssd_MaskHead::set_has_mask_prediction_num_conv_layers() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Ssd_MaskHead::clear_has_mask_prediction_num_conv_layers() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Ssd_MaskHead::clear_mask_prediction_num_conv_layers() {
  mask_prediction_num_conv_layers_ = 2;
  clear_has_mask_prediction_num_conv_layers();
}
inline ::google::protobuf::int32 Ssd_MaskHead::mask_prediction_num_conv_layers() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.Ssd.MaskHead.mask_prediction_num_conv_layers)
  return mask_prediction_num_conv_layers_;
}
inline void Ssd_MaskHead::set_mask_prediction_num_conv_layers(::google::protobuf::int32 value) {
  set_has_mask_prediction_num_conv_layers();
  mask_prediction_num_conv_layers_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.Ssd.MaskHead.mask_prediction_num_conv_layers)
}

// optional bool convolve_then_upsample_masks = 6 [default = false];
inline bool Ssd_MaskHead::has_convolve_then_upsample_masks() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ssd_MaskHead::set_has_convolve_then_upsample_masks() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ssd_MaskHead::clear_has_convolve_then_upsample_masks() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ssd_MaskHead::clear_convolve_then_upsample_masks() {
  convolve_then_upsample_masks_ = false;
  clear_has_convolve_then_upsample_masks();
}
inline bool Ssd_MaskHead::convolve_then_upsample_masks() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.Ssd.MaskHead.convolve_then_upsample_masks)
  return convolve_then_upsample_masks_;
}
inline void Ssd_MaskHead::set_convolve_then_upsample_masks(bool value) {
  set_has_convolve_then_upsample_masks();
  convolve_then_upsample_masks_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.Ssd.MaskHead.convolve_then_upsample_masks)
}

// optional float mask_loss_weight = 7 [default = 5];
inline bool Ssd_MaskHead::has_mask_loss_weight() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Ssd_MaskHead::set_has_mask_loss_weight() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Ssd_MaskHead::clear_has_mask_loss_weight() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Ssd_MaskHead::clear_mask_loss_weight() {
  mask_loss_weight_ = 5;
  clear_has_mask_loss_weight();
}
inline float Ssd_MaskHead::mask_loss_weight() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.Ssd.MaskHead.mask_loss_weight)
  return mask_loss_weight_;
}
inline void Ssd_MaskHead::set_mask_loss_weight(float value) {
  set_has_mask_loss_weight();
  mask_loss_weight_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.Ssd.MaskHead.mask_loss_weight)
}

// optional int32 mask_loss_sample_size = 8 [default = 16];
inline bool Ssd_MaskHead::has_mask_loss_sample_size() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Ssd_MaskHead::set_has_mask_loss_sample_size() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Ssd_MaskHead::clear_has_mask_loss_sample_size() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Ssd_MaskHead::clear_mask_loss_sample_size() {
  mask_loss_sample_size_ = 16;
  clear_has_mask_loss_sample_size();
}
inline ::google::protobuf::int32 Ssd_MaskHead::mask_loss_sample_size() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.Ssd.MaskHead.mask_loss_sample_size)
  return mask_loss_sample_size_;
}
inline void Ssd_MaskHead::set_mask_loss_sample_size(::google::protobuf::int32 value) {
  set_has_mask_loss_sample_size();
  mask_loss_sample_size_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.Ssd.MaskHead.mask_loss_sample_size)
}

// optional .object_detection.protos.Hyperparams conv_hyperparams = 9;
inline bool Ssd_MaskHead::has_conv_hyperparams() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ssd_MaskHead::set_has_conv_hyperparams() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ssd_MaskHead::clear_has_conv_hyperparams() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ssd_MaskHead::clear_conv_hyperparams() {
  if (conv_hyperparams_ != NULL) conv_hyperparams_->::object_detection::protos::Hyperparams::Clear();
  clear_has_conv_hyperparams();
}
inline const ::object_detection::protos::Hyperparams& Ssd_MaskHead::conv_hyperparams() const {
  const ::object_detection::protos::Hyperparams* p = conv_hyperparams_;
  // @@protoc_insertion_point(field_get:object_detection.protos.Ssd.MaskHead.conv_hyperparams)
  return p != NULL ? *p : *reinterpret_cast<const ::object_detection::protos::Hyperparams*>(
      &::object_detection::protos::_Hyperparams_default_instance_);
}
inline ::object_detection::protos::Hyperparams* Ssd_MaskHead::mutable_conv_hyperparams() {
  set_has_conv_hyperparams();
  if (conv_hyperparams_ == NULL) {
    conv_hyperparams_ = new ::object_detection::protos::Hyperparams;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.Ssd.MaskHead.conv_hyperparams)
  return conv_hyperparams_;
}
inline ::object_detection::protos::Hyperparams* Ssd_MaskHead::release_conv_hyperparams() {
  // @@protoc_insertion_point(field_release:object_detection.protos.Ssd.MaskHead.conv_hyperparams)
  clear_has_conv_hyperparams();
  ::object_detection::protos::Hyperparams* temp = conv_hyperparams_;
  conv_hyperparams_ = NULL;
  return temp;
}
inline void Ssd_MaskHead::set_allocated_conv_hyperparams(::object_detection::protos::Hyperparams* conv_hyperparams) {
  delete conv_hyperparams_;
  conv_hyperparams_ = conv_hyperparams;
  if (conv_hyperparams) {
    set_has_conv_hyperparams();
  } else {
    clear_has_conv_hyperparams();
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.Ssd.MaskHead.conv_hyperparams)
}

// optional int32 initial_crop_size = 10 [default = 15];
inline bool Ssd_MaskHead::has_initial_crop_size() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Ssd_MaskHead::set_has_initial_crop_size() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Ssd_MaskHead::clear_has_initial_crop_size() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Ssd_MaskHead::clear_initial_crop_size() {
  initial_crop_size_ = 15;
  clear_has_initial_crop_size();
}
inline ::google::protobuf::int32 Ssd_MaskHead::initial_crop_size() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.Ssd.MaskHead.initial_crop_size)
  return initial_crop_size_;
}
inline void Ssd_MaskHead::set_initial_crop_size(::google::protobuf::int32 value) {
  set_has_initial_crop_size();
  initial_crop_size_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.Ssd.MaskHead.initial_crop_size)
}

// -------------------------------------------------------------------

// Ssd

// optional int32 num_classes = 1;
inline bool Ssd::has_num_classes() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Ssd::set_has_num_classes() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Ssd::clear_has_num_classes() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Ssd::clear_num_classes() {
  num_classes_ = 0;
  clear_has_num_classes();
}
inline ::google::protobuf::int32 Ssd::num_classes() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.Ssd.num_classes)
  return num_classes_;
}
inline void Ssd::set_num_classes(::google::protobuf::int32 value) {
  set_has_num_classes();
  num_classes_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.Ssd.num_classes)
}

// optional .object_detection.protos.ImageResizer image_resizer = 2;
inline bool Ssd::has_image_resizer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ssd::set_has_image_resizer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ssd::clear_has_image_resizer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ssd::clear_image_resizer() {
  if (image_resizer_ != NULL) image_resizer_->::object_detection::protos::ImageResizer::Clear();
  clear_has_image_resizer();
}
inline const ::object_detection::protos::ImageResizer& Ssd::image_resizer() const {
  const ::object_detection::protos::ImageResizer* p = image_resizer_;
  // @@protoc_insertion_point(field_get:object_detection.protos.Ssd.image_resizer)
  return p != NULL ? *p : *reinterpret_cast<const ::object_detection::protos::ImageResizer*>(
      &::object_detection::protos::_ImageResizer_default_instance_);
}
inline ::object_detection::protos::ImageResizer* Ssd::mutable_image_resizer() {
  set_has_image_resizer();
  if (image_resizer_ == NULL) {
    image_resizer_ = new ::object_detection::protos::ImageResizer;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.Ssd.image_resizer)
  return image_resizer_;
}
inline ::object_detection::protos::ImageResizer* Ssd::release_image_resizer() {
  // @@protoc_insertion_point(field_release:object_detection.protos.Ssd.image_resizer)
  clear_has_image_resizer();
  ::object_detection::protos::ImageResizer* temp = image_resizer_;
  image_resizer_ = NULL;
  return temp;
}
inline void Ssd::set_allocated_image_resizer(::object_detection::protos::ImageResizer* image_resizer) {
  delete image_resizer_;
  image_resizer_ = image_resizer;
  if (image_resizer) {
    set_has_image_resizer();
  } else {
    clear_has_image_resizer();
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.Ssd.image_resizer)
}

// optional .object_detection.protos.SsdFeatureExtractor feature_extractor = 3;
inline bool Ssd::has_feature_extractor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ssd::set_has_feature_extractor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ssd::clear_has_feature_extractor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ssd::clear_feature_extractor() {
  if (feature_extractor_ != NULL) feature_extractor_->::object_detection::protos::SsdFeatureExtractor::Clear();
  clear_has_feature_extractor();
}
inline const ::object_detection::protos::SsdFeatureExtractor& Ssd::feature_extractor() const {
  const ::object_detection::protos::SsdFeatureExtractor* p = feature_extractor_;
  // @@protoc_insertion_point(field_get:object_detection.protos.Ssd.feature_extractor)
  return p != NULL ? *p : *reinterpret_cast<const ::object_detection::protos::SsdFeatureExtractor*>(
      &::object_detection::protos::_SsdFeatureExtractor_default_instance_);
}
inline ::object_detection::protos::SsdFeatureExtractor* Ssd::mutable_feature_extractor() {
  set_has_feature_extractor();
  if (feature_extractor_ == NULL) {
    feature_extractor_ = new ::object_detection::protos::SsdFeatureExtractor;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.Ssd.feature_extractor)
  return feature_extractor_;
}
inline ::object_detection::protos::SsdFeatureExtractor* Ssd::release_feature_extractor() {
  // @@protoc_insertion_point(field_release:object_detection.protos.Ssd.feature_extractor)
  clear_has_feature_extractor();
  ::object_detection::protos::SsdFeatureExtractor* temp = feature_extractor_;
  feature_extractor_ = NULL;
  return temp;
}
inline void Ssd::set_allocated_feature_extractor(::object_detection::protos::SsdFeatureExtractor* feature_extractor) {
  delete feature_extractor_;
  feature_extractor_ = feature_extractor;
  if (feature_extractor) {
    set_has_feature_extractor();
  } else {
    clear_has_feature_extractor();
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.Ssd.feature_extractor)
}

// optional .object_detection.protos.BoxCoder box_coder = 4;
inline bool Ssd::has_box_coder() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Ssd::set_has_box_coder() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Ssd::clear_has_box_coder() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Ssd::clear_box_coder() {
  if (box_coder_ != NULL) box_coder_->::object_detection::protos::BoxCoder::Clear();
  clear_has_box_coder();
}
inline const ::object_detection::protos::BoxCoder& Ssd::box_coder() const {
  const ::object_detection::protos::BoxCoder* p = box_coder_;
  // @@protoc_insertion_point(field_get:object_detection.protos.Ssd.box_coder)
  return p != NULL ? *p : *reinterpret_cast<const ::object_detection::protos::BoxCoder*>(
      &::object_detection::protos::_BoxCoder_default_instance_);
}
inline ::object_detection::protos::BoxCoder* Ssd::mutable_box_coder() {
  set_has_box_coder();
  if (box_coder_ == NULL) {
    box_coder_ = new ::object_detection::protos::BoxCoder;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.Ssd.box_coder)
  return box_coder_;
}
inline ::object_detection::protos::BoxCoder* Ssd::release_box_coder() {
  // @@protoc_insertion_point(field_release:object_detection.protos.Ssd.box_coder)
  clear_has_box_coder();
  ::object_detection::protos::BoxCoder* temp = box_coder_;
  box_coder_ = NULL;
  return temp;
}
inline void Ssd::set_allocated_box_coder(::object_detection::protos::BoxCoder* box_coder) {
  delete box_coder_;
  box_coder_ = box_coder;
  if (box_coder) {
    set_has_box_coder();
  } else {
    clear_has_box_coder();
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.Ssd.box_coder)
}

// optional .object_detection.protos.Matcher matcher = 5;
inline bool Ssd::has_matcher() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Ssd::set_has_matcher() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Ssd::clear_has_matcher() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Ssd::clear_matcher() {
  if (matcher_ != NULL) matcher_->::object_detection::protos::Matcher::Clear();
  clear_has_matcher();
}
inline const ::object_detection::protos::Matcher& Ssd::matcher() const {
  const ::object_detection::protos::Matcher* p = matcher_;
  // @@protoc_insertion_point(field_get:object_detection.protos.Ssd.matcher)
  return p != NULL ? *p : *reinterpret_cast<const ::object_detection::protos::Matcher*>(
      &::object_detection::protos::_Matcher_default_instance_);
}
inline ::object_detection::protos::Matcher* Ssd::mutable_matcher() {
  set_has_matcher();
  if (matcher_ == NULL) {
    matcher_ = new ::object_detection::protos::Matcher;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.Ssd.matcher)
  return matcher_;
}
inline ::object_detection::protos::Matcher* Ssd::release_matcher() {
  // @@protoc_insertion_point(field_release:object_detection.protos.Ssd.matcher)
  clear_has_matcher();
  ::object_detection::protos::Matcher* temp = matcher_;
  matcher_ = NULL;
  return temp;
}
inline void Ssd::set_allocated_matcher(::object_detection::protos::Matcher* matcher) {
  delete matcher_;
  matcher_ = matcher;
  if (matcher) {
    set_has_matcher();
  } else {
    clear_has_matcher();
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.Ssd.matcher)
}

// optional .object_detection.protos.RegionSimilarityCalculator similarity_calculator = 6;
inline bool Ssd::has_similarity_calculator() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Ssd::set_has_similarity_calculator() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Ssd::clear_has_similarity_calculator() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Ssd::clear_similarity_calculator() {
  if (similarity_calculator_ != NULL) similarity_calculator_->::object_detection::protos::RegionSimilarityCalculator::Clear();
  clear_has_similarity_calculator();
}
inline const ::object_detection::protos::RegionSimilarityCalculator& Ssd::similarity_calculator() const {
  const ::object_detection::protos::RegionSimilarityCalculator* p = similarity_calculator_;
  // @@protoc_insertion_point(field_get:object_detection.protos.Ssd.similarity_calculator)
  return p != NULL ? *p : *reinterpret_cast<const ::object_detection::protos::RegionSimilarityCalculator*>(
      &::object_detection::protos::_RegionSimilarityCalculator_default_instance_);
}
inline ::object_detection::protos::RegionSimilarityCalculator* Ssd::mutable_similarity_calculator() {
  set_has_similarity_calculator();
  if (similarity_calculator_ == NULL) {
    similarity_calculator_ = new ::object_detection::protos::RegionSimilarityCalculator;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.Ssd.similarity_calculator)
  return similarity_calculator_;
}
inline ::object_detection::protos::RegionSimilarityCalculator* Ssd::release_similarity_calculator() {
  // @@protoc_insertion_point(field_release:object_detection.protos.Ssd.similarity_calculator)
  clear_has_similarity_calculator();
  ::object_detection::protos::RegionSimilarityCalculator* temp = similarity_calculator_;
  similarity_calculator_ = NULL;
  return temp;
}
inline void Ssd::set_allocated_similarity_calculator(::object_detection::protos::RegionSimilarityCalculator* similarity_calculator) {
  delete similarity_calculator_;
  similarity_calculator_ = similarity_calculator;
  if (similarity_calculator) {
    set_has_similarity_calculator();
  } else {
    clear_has_similarity_calculator();
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.Ssd.similarity_calculator)
}

// optional bool encode_background_as_zeros = 12 [default = false];
inline bool Ssd::has_encode_background_as_zeros() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Ssd::set_has_encode_background_as_zeros() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Ssd::clear_has_encode_background_as_zeros() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Ssd::clear_encode_background_as_zeros() {
  encode_background_as_zeros_ = false;
  clear_has_encode_background_as_zeros();
}
inline bool Ssd::encode_background_as_zeros() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.Ssd.encode_background_as_zeros)
  return encode_background_as_zeros_;
}
inline void Ssd::set_encode_background_as_zeros(bool value) {
  set_has_encode_background_as_zeros();
  encode_background_as_zeros_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.Ssd.encode_background_as_zeros)
}

// optional float negative_class_weight = 13 [default = 1];
inline bool Ssd::has_negative_class_weight() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Ssd::set_has_negative_class_weight() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Ssd::clear_has_negative_class_weight() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Ssd::clear_negative_class_weight() {
  negative_class_weight_ = 1;
  clear_has_negative_class_weight();
}
inline float Ssd::negative_class_weight() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.Ssd.negative_class_weight)
  return negative_class_weight_;
}
inline void Ssd::set_negative_class_weight(float value) {
  set_has_negative_class_weight();
  negative_class_weight_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.Ssd.negative_class_weight)
}

// optional .object_detection.protos.BoxPredictor box_predictor = 7;
inline bool Ssd::has_box_predictor() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Ssd::set_has_box_predictor() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Ssd::clear_has_box_predictor() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Ssd::clear_box_predictor() {
  if (box_predictor_ != NULL) box_predictor_->::object_detection::protos::BoxPredictor::Clear();
  clear_has_box_predictor();
}
inline const ::object_detection::protos::BoxPredictor& Ssd::box_predictor() const {
  const ::object_detection::protos::BoxPredictor* p = box_predictor_;
  // @@protoc_insertion_point(field_get:object_detection.protos.Ssd.box_predictor)
  return p != NULL ? *p : *reinterpret_cast<const ::object_detection::protos::BoxPredictor*>(
      &::object_detection::protos::_BoxPredictor_default_instance_);
}
inline ::object_detection::protos::BoxPredictor* Ssd::mutable_box_predictor() {
  set_has_box_predictor();
  if (box_predictor_ == NULL) {
    box_predictor_ = new ::object_detection::protos::BoxPredictor;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.Ssd.box_predictor)
  return box_predictor_;
}
inline ::object_detection::protos::BoxPredictor* Ssd::release_box_predictor() {
  // @@protoc_insertion_point(field_release:object_detection.protos.Ssd.box_predictor)
  clear_has_box_predictor();
  ::object_detection::protos::BoxPredictor* temp = box_predictor_;
  box_predictor_ = NULL;
  return temp;
}
inline void Ssd::set_allocated_box_predictor(::object_detection::protos::BoxPredictor* box_predictor) {
  delete box_predictor_;
  box_predictor_ = box_predictor;
  if (box_predictor) {
    set_has_box_predictor();
  } else {
    clear_has_box_predictor();
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.Ssd.box_predictor)
}

// optional .object_detection.protos.AnchorGenerator anchor_generator = 8;
inline bool Ssd::has_anchor_generator() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Ssd::set_has_anchor_generator() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Ssd::clear_has_anchor_generator() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Ssd::clear_anchor_generator() {
  if (anchor_generator_ != NULL) anchor_generator_->::object_detection::protos::AnchorGenerator::Clear();
  clear_has_anchor_generator();
}
inline const ::object_detection::protos::AnchorGenerator& Ssd::anchor_generator() const {
  const ::object_detection::protos::AnchorGenerator* p = anchor_generator_;
  // @@protoc_insertion_point(field_get:object_detection.protos.Ssd.anchor_generator)
  return p != NULL ? *p : *reinterpret_cast<const ::object_detection::protos::AnchorGenerator*>(
      &::object_detection::protos::_AnchorGenerator_default_instance_);
}
inline ::object_detection::protos::AnchorGenerator* Ssd::mutable_anchor_generator() {
  set_has_anchor_generator();
  if (anchor_generator_ == NULL) {
    anchor_generator_ = new ::object_detection::protos::AnchorGenerator;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.Ssd.anchor_generator)
  return anchor_generator_;
}
inline ::object_detection::protos::AnchorGenerator* Ssd::release_anchor_generator() {
  // @@protoc_insertion_point(field_release:object_detection.protos.Ssd.anchor_generator)
  clear_has_anchor_generator();
  ::object_detection::protos::AnchorGenerator* temp = anchor_generator_;
  anchor_generator_ = NULL;
  return temp;
}
inline void Ssd::set_allocated_anchor_generator(::object_detection::protos::AnchorGenerator* anchor_generator) {
  delete anchor_generator_;
  anchor_generator_ = anchor_generator;
  if (anchor_generator) {
    set_has_anchor_generator();
  } else {
    clear_has_anchor_generator();
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.Ssd.anchor_generator)
}

// optional .object_detection.protos.PostProcessing post_processing = 9;
inline bool Ssd::has_post_processing() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Ssd::set_has_post_processing() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Ssd::clear_has_post_processing() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Ssd::clear_post_processing() {
  if (post_processing_ != NULL) post_processing_->::object_detection::protos::PostProcessing::Clear();
  clear_has_post_processing();
}
inline const ::object_detection::protos::PostProcessing& Ssd::post_processing() const {
  const ::object_detection::protos::PostProcessing* p = post_processing_;
  // @@protoc_insertion_point(field_get:object_detection.protos.Ssd.post_processing)
  return p != NULL ? *p : *reinterpret_cast<const ::object_detection::protos::PostProcessing*>(
      &::object_detection::protos::_PostProcessing_default_instance_);
}
inline ::object_detection::protos::PostProcessing* Ssd::mutable_post_processing() {
  set_has_post_processing();
  if (post_processing_ == NULL) {
    post_processing_ = new ::object_detection::protos::PostProcessing;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.Ssd.post_processing)
  return post_processing_;
}
inline ::object_detection::protos::PostProcessing* Ssd::release_post_processing() {
  // @@protoc_insertion_point(field_release:object_detection.protos.Ssd.post_processing)
  clear_has_post_processing();
  ::object_detection::protos::PostProcessing* temp = post_processing_;
  post_processing_ = NULL;
  return temp;
}
inline void Ssd::set_allocated_post_processing(::object_detection::protos::PostProcessing* post_processing) {
  delete post_processing_;
  post_processing_ = post_processing;
  if (post_processing) {
    set_has_post_processing();
  } else {
    clear_has_post_processing();
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.Ssd.post_processing)
}

// optional bool normalize_loss_by_num_matches = 10 [default = true];
inline bool Ssd::has_normalize_loss_by_num_matches() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Ssd::set_has_normalize_loss_by_num_matches() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Ssd::clear_has_normalize_loss_by_num_matches() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Ssd::clear_normalize_loss_by_num_matches() {
  normalize_loss_by_num_matches_ = true;
  clear_has_normalize_loss_by_num_matches();
}
inline bool Ssd::normalize_loss_by_num_matches() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.Ssd.normalize_loss_by_num_matches)
  return normalize_loss_by_num_matches_;
}
inline void Ssd::set_normalize_loss_by_num_matches(bool value) {
  set_has_normalize_loss_by_num_matches();
  normalize_loss_by_num_matches_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.Ssd.normalize_loss_by_num_matches)
}

// optional bool normalize_loc_loss_by_codesize = 14 [default = false];
inline bool Ssd::has_normalize_loc_loss_by_codesize() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Ssd::set_has_normalize_loc_loss_by_codesize() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Ssd::clear_has_normalize_loc_loss_by_codesize() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Ssd::clear_normalize_loc_loss_by_codesize() {
  normalize_loc_loss_by_codesize_ = false;
  clear_has_normalize_loc_loss_by_codesize();
}
inline bool Ssd::normalize_loc_loss_by_codesize() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.Ssd.normalize_loc_loss_by_codesize)
  return normalize_loc_loss_by_codesize_;
}
inline void Ssd::set_normalize_loc_loss_by_codesize(bool value) {
  set_has_normalize_loc_loss_by_codesize();
  normalize_loc_loss_by_codesize_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.Ssd.normalize_loc_loss_by_codesize)
}

// optional .object_detection.protos.Loss loss = 11;
inline bool Ssd::has_loss() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Ssd::set_has_loss() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Ssd::clear_has_loss() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Ssd::clear_loss() {
  if (loss_ != NULL) loss_->::object_detection::protos::Loss::Clear();
  clear_has_loss();
}
inline const ::object_detection::protos::Loss& Ssd::loss() const {
  const ::object_detection::protos::Loss* p = loss_;
  // @@protoc_insertion_point(field_get:object_detection.protos.Ssd.loss)
  return p != NULL ? *p : *reinterpret_cast<const ::object_detection::protos::Loss*>(
      &::object_detection::protos::_Loss_default_instance_);
}
inline ::object_detection::protos::Loss* Ssd::mutable_loss() {
  set_has_loss();
  if (loss_ == NULL) {
    loss_ = new ::object_detection::protos::Loss;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.Ssd.loss)
  return loss_;
}
inline ::object_detection::protos::Loss* Ssd::release_loss() {
  // @@protoc_insertion_point(field_release:object_detection.protos.Ssd.loss)
  clear_has_loss();
  ::object_detection::protos::Loss* temp = loss_;
  loss_ = NULL;
  return temp;
}
inline void Ssd::set_allocated_loss(::object_detection::protos::Loss* loss) {
  delete loss_;
  loss_ = loss;
  if (loss) {
    set_has_loss();
  } else {
    clear_has_loss();
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.Ssd.loss)
}

// optional bool freeze_batchnorm = 16 [default = false];
inline bool Ssd::has_freeze_batchnorm() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Ssd::set_has_freeze_batchnorm() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Ssd::clear_has_freeze_batchnorm() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Ssd::clear_freeze_batchnorm() {
  freeze_batchnorm_ = false;
  clear_has_freeze_batchnorm();
}
inline bool Ssd::freeze_batchnorm() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.Ssd.freeze_batchnorm)
  return freeze_batchnorm_;
}
inline void Ssd::set_freeze_batchnorm(bool value) {
  set_has_freeze_batchnorm();
  freeze_batchnorm_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.Ssd.freeze_batchnorm)
}

// optional bool inplace_batchnorm_update = 15 [default = false];
inline bool Ssd::has_inplace_batchnorm_update() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Ssd::set_has_inplace_batchnorm_update() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Ssd::clear_has_inplace_batchnorm_update() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Ssd::clear_inplace_batchnorm_update() {
  inplace_batchnorm_update_ = false;
  clear_has_inplace_batchnorm_update();
}
inline bool Ssd::inplace_batchnorm_update() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.Ssd.inplace_batchnorm_update)
  return inplace_batchnorm_update_;
}
inline void Ssd::set_inplace_batchnorm_update(bool value) {
  set_has_inplace_batchnorm_update();
  inplace_batchnorm_update_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.Ssd.inplace_batchnorm_update)
}

// optional bool add_background_class = 21 [default = true];
inline bool Ssd::has_add_background_class() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Ssd::set_has_add_background_class() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Ssd::clear_has_add_background_class() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Ssd::clear_add_background_class() {
  add_background_class_ = true;
  clear_has_add_background_class();
}
inline bool Ssd::add_background_class() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.Ssd.add_background_class)
  return add_background_class_;
}
inline void Ssd::set_add_background_class(bool value) {
  set_has_add_background_class();
  add_background_class_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.Ssd.add_background_class)
}

// optional bool explicit_background_class = 24 [default = false];
inline bool Ssd::has_explicit_background_class() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Ssd::set_has_explicit_background_class() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Ssd::clear_has_explicit_background_class() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Ssd::clear_explicit_background_class() {
  explicit_background_class_ = false;
  clear_has_explicit_background_class();
}
inline bool Ssd::explicit_background_class() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.Ssd.explicit_background_class)
  return explicit_background_class_;
}
inline void Ssd::set_explicit_background_class(bool value) {
  set_has_explicit_background_class();
  explicit_background_class_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.Ssd.explicit_background_class)
}

// optional bool use_confidences_as_targets = 22 [default = false];
inline bool Ssd::has_use_confidences_as_targets() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Ssd::set_has_use_confidences_as_targets() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Ssd::clear_has_use_confidences_as_targets() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Ssd::clear_use_confidences_as_targets() {
  use_confidences_as_targets_ = false;
  clear_has_use_confidences_as_targets();
}
inline bool Ssd::use_confidences_as_targets() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.Ssd.use_confidences_as_targets)
  return use_confidences_as_targets_;
}
inline void Ssd::set_use_confidences_as_targets(bool value) {
  set_has_use_confidences_as_targets();
  use_confidences_as_targets_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.Ssd.use_confidences_as_targets)
}

// optional float implicit_example_weight = 23 [default = 1];
inline bool Ssd::has_implicit_example_weight() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Ssd::set_has_implicit_example_weight() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Ssd::clear_has_implicit_example_weight() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Ssd::clear_implicit_example_weight() {
  implicit_example_weight_ = 1;
  clear_has_implicit_example_weight();
}
inline float Ssd::implicit_example_weight() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.Ssd.implicit_example_weight)
  return implicit_example_weight_;
}
inline void Ssd::set_implicit_example_weight(float value) {
  set_has_implicit_example_weight();
  implicit_example_weight_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.Ssd.implicit_example_weight)
}

// optional .object_detection.protos.Ssd.MaskHead mask_head_config = 25;
inline bool Ssd::has_mask_head_config() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Ssd::set_has_mask_head_config() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Ssd::clear_has_mask_head_config() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Ssd::clear_mask_head_config() {
  if (mask_head_config_ != NULL) mask_head_config_->::object_detection::protos::Ssd_MaskHead::Clear();
  clear_has_mask_head_config();
}
inline const ::object_detection::protos::Ssd_MaskHead& Ssd::mask_head_config() const {
  const ::object_detection::protos::Ssd_MaskHead* p = mask_head_config_;
  // @@protoc_insertion_point(field_get:object_detection.protos.Ssd.mask_head_config)
  return p != NULL ? *p : *reinterpret_cast<const ::object_detection::protos::Ssd_MaskHead*>(
      &::object_detection::protos::_Ssd_MaskHead_default_instance_);
}
inline ::object_detection::protos::Ssd_MaskHead* Ssd::mutable_mask_head_config() {
  set_has_mask_head_config();
  if (mask_head_config_ == NULL) {
    mask_head_config_ = new ::object_detection::protos::Ssd_MaskHead;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.Ssd.mask_head_config)
  return mask_head_config_;
}
inline ::object_detection::protos::Ssd_MaskHead* Ssd::release_mask_head_config() {
  // @@protoc_insertion_point(field_release:object_detection.protos.Ssd.mask_head_config)
  clear_has_mask_head_config();
  ::object_detection::protos::Ssd_MaskHead* temp = mask_head_config_;
  mask_head_config_ = NULL;
  return temp;
}
inline void Ssd::set_allocated_mask_head_config(::object_detection::protos::Ssd_MaskHead* mask_head_config) {
  delete mask_head_config_;
  mask_head_config_ = mask_head_config;
  if (mask_head_config) {
    set_has_mask_head_config();
  } else {
    clear_has_mask_head_config();
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.Ssd.mask_head_config)
}

// -------------------------------------------------------------------

// SsdFeatureExtractor

// optional string type = 1;
inline bool SsdFeatureExtractor::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SsdFeatureExtractor::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SsdFeatureExtractor::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SsdFeatureExtractor::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& SsdFeatureExtractor::type() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SsdFeatureExtractor.type)
  return type_.GetNoArena();
}
inline void SsdFeatureExtractor::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:object_detection.protos.SsdFeatureExtractor.type)
}
#if LANG_CXX11
inline void SsdFeatureExtractor::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:object_detection.protos.SsdFeatureExtractor.type)
}
#endif
inline void SsdFeatureExtractor::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:object_detection.protos.SsdFeatureExtractor.type)
}
inline void SsdFeatureExtractor::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:object_detection.protos.SsdFeatureExtractor.type)
}
inline ::std::string* SsdFeatureExtractor::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:object_detection.protos.SsdFeatureExtractor.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SsdFeatureExtractor::release_type() {
  // @@protoc_insertion_point(field_release:object_detection.protos.SsdFeatureExtractor.type)
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SsdFeatureExtractor::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.SsdFeatureExtractor.type)
}

// optional float depth_multiplier = 2 [default = 1];
inline bool SsdFeatureExtractor::has_depth_multiplier() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SsdFeatureExtractor::set_has_depth_multiplier() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SsdFeatureExtractor::clear_has_depth_multiplier() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SsdFeatureExtractor::clear_depth_multiplier() {
  depth_multiplier_ = 1;
  clear_has_depth_multiplier();
}
inline float SsdFeatureExtractor::depth_multiplier() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SsdFeatureExtractor.depth_multiplier)
  return depth_multiplier_;
}
inline void SsdFeatureExtractor::set_depth_multiplier(float value) {
  set_has_depth_multiplier();
  depth_multiplier_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SsdFeatureExtractor.depth_multiplier)
}

// optional int32 min_depth = 3 [default = 16];
inline bool SsdFeatureExtractor::has_min_depth() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SsdFeatureExtractor::set_has_min_depth() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SsdFeatureExtractor::clear_has_min_depth() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SsdFeatureExtractor::clear_min_depth() {
  min_depth_ = 16;
  clear_has_min_depth();
}
inline ::google::protobuf::int32 SsdFeatureExtractor::min_depth() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SsdFeatureExtractor.min_depth)
  return min_depth_;
}
inline void SsdFeatureExtractor::set_min_depth(::google::protobuf::int32 value) {
  set_has_min_depth();
  min_depth_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SsdFeatureExtractor.min_depth)
}

// optional .object_detection.protos.Hyperparams conv_hyperparams = 4;
inline bool SsdFeatureExtractor::has_conv_hyperparams() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SsdFeatureExtractor::set_has_conv_hyperparams() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SsdFeatureExtractor::clear_has_conv_hyperparams() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SsdFeatureExtractor::clear_conv_hyperparams() {
  if (conv_hyperparams_ != NULL) conv_hyperparams_->::object_detection::protos::Hyperparams::Clear();
  clear_has_conv_hyperparams();
}
inline const ::object_detection::protos::Hyperparams& SsdFeatureExtractor::conv_hyperparams() const {
  const ::object_detection::protos::Hyperparams* p = conv_hyperparams_;
  // @@protoc_insertion_point(field_get:object_detection.protos.SsdFeatureExtractor.conv_hyperparams)
  return p != NULL ? *p : *reinterpret_cast<const ::object_detection::protos::Hyperparams*>(
      &::object_detection::protos::_Hyperparams_default_instance_);
}
inline ::object_detection::protos::Hyperparams* SsdFeatureExtractor::mutable_conv_hyperparams() {
  set_has_conv_hyperparams();
  if (conv_hyperparams_ == NULL) {
    conv_hyperparams_ = new ::object_detection::protos::Hyperparams;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.SsdFeatureExtractor.conv_hyperparams)
  return conv_hyperparams_;
}
inline ::object_detection::protos::Hyperparams* SsdFeatureExtractor::release_conv_hyperparams() {
  // @@protoc_insertion_point(field_release:object_detection.protos.SsdFeatureExtractor.conv_hyperparams)
  clear_has_conv_hyperparams();
  ::object_detection::protos::Hyperparams* temp = conv_hyperparams_;
  conv_hyperparams_ = NULL;
  return temp;
}
inline void SsdFeatureExtractor::set_allocated_conv_hyperparams(::object_detection::protos::Hyperparams* conv_hyperparams) {
  delete conv_hyperparams_;
  conv_hyperparams_ = conv_hyperparams;
  if (conv_hyperparams) {
    set_has_conv_hyperparams();
  } else {
    clear_has_conv_hyperparams();
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.SsdFeatureExtractor.conv_hyperparams)
}

// optional bool override_base_feature_extractor_hyperparams = 9 [default = false];
inline bool SsdFeatureExtractor::has_override_base_feature_extractor_hyperparams() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SsdFeatureExtractor::set_has_override_base_feature_extractor_hyperparams() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SsdFeatureExtractor::clear_has_override_base_feature_extractor_hyperparams() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SsdFeatureExtractor::clear_override_base_feature_extractor_hyperparams() {
  override_base_feature_extractor_hyperparams_ = false;
  clear_has_override_base_feature_extractor_hyperparams();
}
inline bool SsdFeatureExtractor::override_base_feature_extractor_hyperparams() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SsdFeatureExtractor.override_base_feature_extractor_hyperparams)
  return override_base_feature_extractor_hyperparams_;
}
inline void SsdFeatureExtractor::set_override_base_feature_extractor_hyperparams(bool value) {
  set_has_override_base_feature_extractor_hyperparams();
  override_base_feature_extractor_hyperparams_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SsdFeatureExtractor.override_base_feature_extractor_hyperparams)
}

// optional int32 pad_to_multiple = 5 [default = 1];
inline bool SsdFeatureExtractor::has_pad_to_multiple() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SsdFeatureExtractor::set_has_pad_to_multiple() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SsdFeatureExtractor::clear_has_pad_to_multiple() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SsdFeatureExtractor::clear_pad_to_multiple() {
  pad_to_multiple_ = 1;
  clear_has_pad_to_multiple();
}
inline ::google::protobuf::int32 SsdFeatureExtractor::pad_to_multiple() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SsdFeatureExtractor.pad_to_multiple)
  return pad_to_multiple_;
}
inline void SsdFeatureExtractor::set_pad_to_multiple(::google::protobuf::int32 value) {
  set_has_pad_to_multiple();
  pad_to_multiple_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SsdFeatureExtractor.pad_to_multiple)
}

// optional bool use_explicit_padding = 7 [default = false];
inline bool SsdFeatureExtractor::has_use_explicit_padding() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SsdFeatureExtractor::set_has_use_explicit_padding() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SsdFeatureExtractor::clear_has_use_explicit_padding() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SsdFeatureExtractor::clear_use_explicit_padding() {
  use_explicit_padding_ = false;
  clear_has_use_explicit_padding();
}
inline bool SsdFeatureExtractor::use_explicit_padding() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SsdFeatureExtractor.use_explicit_padding)
  return use_explicit_padding_;
}
inline void SsdFeatureExtractor::set_use_explicit_padding(bool value) {
  set_has_use_explicit_padding();
  use_explicit_padding_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SsdFeatureExtractor.use_explicit_padding)
}

// optional bool use_depthwise = 8 [default = false];
inline bool SsdFeatureExtractor::has_use_depthwise() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SsdFeatureExtractor::set_has_use_depthwise() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SsdFeatureExtractor::clear_has_use_depthwise() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SsdFeatureExtractor::clear_use_depthwise() {
  use_depthwise_ = false;
  clear_has_use_depthwise();
}
inline bool SsdFeatureExtractor::use_depthwise() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SsdFeatureExtractor.use_depthwise)
  return use_depthwise_;
}
inline void SsdFeatureExtractor::set_use_depthwise(bool value) {
  set_has_use_depthwise();
  use_depthwise_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SsdFeatureExtractor.use_depthwise)
}

// optional .object_detection.protos.FeaturePyramidNetworks fpn = 10;
inline bool SsdFeatureExtractor::has_fpn() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SsdFeatureExtractor::set_has_fpn() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SsdFeatureExtractor::clear_has_fpn() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SsdFeatureExtractor::clear_fpn() {
  if (fpn_ != NULL) fpn_->::object_detection::protos::FeaturePyramidNetworks::Clear();
  clear_has_fpn();
}
inline const ::object_detection::protos::FeaturePyramidNetworks& SsdFeatureExtractor::fpn() const {
  const ::object_detection::protos::FeaturePyramidNetworks* p = fpn_;
  // @@protoc_insertion_point(field_get:object_detection.protos.SsdFeatureExtractor.fpn)
  return p != NULL ? *p : *reinterpret_cast<const ::object_detection::protos::FeaturePyramidNetworks*>(
      &::object_detection::protos::_FeaturePyramidNetworks_default_instance_);
}
inline ::object_detection::protos::FeaturePyramidNetworks* SsdFeatureExtractor::mutable_fpn() {
  set_has_fpn();
  if (fpn_ == NULL) {
    fpn_ = new ::object_detection::protos::FeaturePyramidNetworks;
  }
  // @@protoc_insertion_point(field_mutable:object_detection.protos.SsdFeatureExtractor.fpn)
  return fpn_;
}
inline ::object_detection::protos::FeaturePyramidNetworks* SsdFeatureExtractor::release_fpn() {
  // @@protoc_insertion_point(field_release:object_detection.protos.SsdFeatureExtractor.fpn)
  clear_has_fpn();
  ::object_detection::protos::FeaturePyramidNetworks* temp = fpn_;
  fpn_ = NULL;
  return temp;
}
inline void SsdFeatureExtractor::set_allocated_fpn(::object_detection::protos::FeaturePyramidNetworks* fpn) {
  delete fpn_;
  fpn_ = fpn;
  if (fpn) {
    set_has_fpn();
  } else {
    clear_has_fpn();
  }
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.SsdFeatureExtractor.fpn)
}

// optional bool replace_preprocessor_with_placeholder = 11 [default = false];
inline bool SsdFeatureExtractor::has_replace_preprocessor_with_placeholder() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SsdFeatureExtractor::set_has_replace_preprocessor_with_placeholder() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SsdFeatureExtractor::clear_has_replace_preprocessor_with_placeholder() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SsdFeatureExtractor::clear_replace_preprocessor_with_placeholder() {
  replace_preprocessor_with_placeholder_ = false;
  clear_has_replace_preprocessor_with_placeholder();
}
inline bool SsdFeatureExtractor::replace_preprocessor_with_placeholder() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SsdFeatureExtractor.replace_preprocessor_with_placeholder)
  return replace_preprocessor_with_placeholder_;
}
inline void SsdFeatureExtractor::set_replace_preprocessor_with_placeholder(bool value) {
  set_has_replace_preprocessor_with_placeholder();
  replace_preprocessor_with_placeholder_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SsdFeatureExtractor.replace_preprocessor_with_placeholder)
}

// optional int32 num_layers = 12 [default = 6];
inline bool SsdFeatureExtractor::has_num_layers() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SsdFeatureExtractor::set_has_num_layers() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SsdFeatureExtractor::clear_has_num_layers() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SsdFeatureExtractor::clear_num_layers() {
  num_layers_ = 6;
  clear_has_num_layers();
}
inline ::google::protobuf::int32 SsdFeatureExtractor::num_layers() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.SsdFeatureExtractor.num_layers)
  return num_layers_;
}
inline void SsdFeatureExtractor::set_num_layers(::google::protobuf::int32 value) {
  set_has_num_layers();
  num_layers_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.SsdFeatureExtractor.num_layers)
}

// -------------------------------------------------------------------

// FeaturePyramidNetworks

// optional int32 min_level = 1 [default = 3];
inline bool FeaturePyramidNetworks::has_min_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FeaturePyramidNetworks::set_has_min_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FeaturePyramidNetworks::clear_has_min_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FeaturePyramidNetworks::clear_min_level() {
  min_level_ = 3;
  clear_has_min_level();
}
inline ::google::protobuf::int32 FeaturePyramidNetworks::min_level() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.FeaturePyramidNetworks.min_level)
  return min_level_;
}
inline void FeaturePyramidNetworks::set_min_level(::google::protobuf::int32 value) {
  set_has_min_level();
  min_level_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.FeaturePyramidNetworks.min_level)
}

// optional int32 max_level = 2 [default = 7];
inline bool FeaturePyramidNetworks::has_max_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FeaturePyramidNetworks::set_has_max_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FeaturePyramidNetworks::clear_has_max_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FeaturePyramidNetworks::clear_max_level() {
  max_level_ = 7;
  clear_has_max_level();
}
inline ::google::protobuf::int32 FeaturePyramidNetworks::max_level() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.FeaturePyramidNetworks.max_level)
  return max_level_;
}
inline void FeaturePyramidNetworks::set_max_level(::google::protobuf::int32 value) {
  set_has_max_level();
  max_level_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.FeaturePyramidNetworks.max_level)
}

// optional int32 additional_layer_depth = 3 [default = 256];
inline bool FeaturePyramidNetworks::has_additional_layer_depth() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FeaturePyramidNetworks::set_has_additional_layer_depth() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FeaturePyramidNetworks::clear_has_additional_layer_depth() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FeaturePyramidNetworks::clear_additional_layer_depth() {
  additional_layer_depth_ = 256;
  clear_has_additional_layer_depth();
}
inline ::google::protobuf::int32 FeaturePyramidNetworks::additional_layer_depth() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.FeaturePyramidNetworks.additional_layer_depth)
  return additional_layer_depth_;
}
inline void FeaturePyramidNetworks::set_additional_layer_depth(::google::protobuf::int32 value) {
  set_has_additional_layer_depth();
  additional_layer_depth_ = value;
  // @@protoc_insertion_point(field_set:object_detection.protos.FeaturePyramidNetworks.additional_layer_depth)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace protos
}  // namespace object_detection

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_object_5fdetection_2fprotos_2fssd_2eproto__INCLUDED
